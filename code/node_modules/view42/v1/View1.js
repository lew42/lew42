var Mod = require("mod42/v5");
var is = require("util42/is");
var ViewCaptor = require("../ViewCaptor");
var Mfn = require("mfn42/v4");

ViewCaptor.previousCaptors = [];
ViewCaptor.set_captor = function(newCaptor){
	this.previousCaptors.push(this.captor);
	this.buffer = [];
	this.captor = newCaptor;
};
ViewCaptor.restore = function(){
	this.captor.append(this.buffer);
	this.captor = this.previousCaptors.pop();
};
ViewCaptor.capture = function(view){
	if (this.captor){
		if (view.$el)
			this.captor.append(view);
		else
			this.captor.append(view.el);
	}
};
ViewCaptor.viewable = function(any){
	if (is.str(any)){
		var ret = document.createTextNode(any);
		console.log(any)
		console.dir(ret);
		window.lastTextNode = ret;
		return ret;
	} else if (any && any.constructor && any.constructor.name === "jQuery"){
		return any[0];
	} else {
		console.warn("todo");
	}
};

var View = module.exports = Mod.extend({
	name: "View1",
	tag: "div",
	autoAppend: true,
	set: {
		sub: function(self, value, parent, name){
			if (value instanceof self.constructor){
				console.warn("overriding view");
				// override
				// value.autoAppend = false; // already in .content as {_ref}
				parent.set.mfn.assignProp(parent, name, value);
			} else if (!parent.hasOwnProperty(name)) {
				console.warn("protecting and cloning view");
				parent.set.mfn.assignProp(parent, name, self.clone(value));
			} else {
				this.arg(self, value); // normal self.set(value)
			}
		},
		value: function(value, set){
			// console.log("view.set.value", value);
			// maybe .reset for the first arg in each .set() call?
			// see set_reset_vs_append.md
			this.append(value);
		},
		// this isa  remnant, probably remove it...
		handleStr: function(view, str){
			if (str.indexOf(".") === 0){
				str.replace(".", "");
				view.addClass(str);
				view.name = str;
			} else {
				view.set_content(str);
			}
		},
		assignTo: function(view, parent, name){
			// always assign
			parent[name] = view;
			view.adoption(parent, name);
		}
	},
	adoption: function(parent, name){
		var pojo = {};
		if (!this.hasOwnProperty("parent")){
			this.parent = parent;
			this.name = name;
			if (this.autoAppend){
				pojo[name] = this;
				parent.append(pojo);
				// this will initialize
			} else {
				console.warn("not sure about this");
				!this.initialized && this.initialize();
			}
			// return true;
		}
		// return false;
	},
	node: function(){
		return this.el;
	},
	set_content: function(value){
		console.info("this could be the 'reset' path.  instead of append, we're specifically saying, no, please clear content.");
	},
	config: function(){
		Mod.prototype.config.apply(this, arguments);
		this.config_tag.apply(this, arguments);
	},
	config_tag: function(o){
		if (o && is.def(o.tag)){
			this.tag = o.tag;
			delete o.tag;
		}
	},
	instantiate: function(){
		this.initialized = false;
		this.instantiate_el();
		this.constructs = arguments; // save these for later
		if (this.debug){
			return new View.Debug(this);
		}
	},
	instantiate_el: function(){
		if (this.el){
			this.el = this.el.cloneNode(false); // shallow clone, we'll rebuild it dynamically
		} else {
			this.el = document.createElement(this.tag);
		}
	},
	initialize: function(){
		this.initialized = true;
		this.set.apply(this, this.constructs);
		if (this.hasOwnProperty("name")){
			// debugger;
			// console.log(this.name);
			this.addClass(this.name);
		}
		this.init();
	},
	init: function(){}, // ORP
	addClass: function(c){
		this.el.classList.add(c);
	},
	removeClass: function(c){
		this.el.classList.remove(c);
	},
	append: Mfn({
		exec: function(self){
			self.append_callCheck = true; // used in set.value
			for (var i = 1; i < arguments.length; i++)
				this.anonArg(self, arguments[i]);

			return self;
		},
		anonArg: function(self, arg){
			var view = this.arg(self, arg);

			// console.log("append", arg, view);
			if (view){ // either undefined, or instanceof View
				// anonymous adoption

				if (view.hasOwnProperty("name")){
					if (self[view.name]){
						console.warn("That property already exists.");
					} else {
						self[view.name] = view;
					}
				}
				view.parent = self;
				!view.initialized && view.initialize();
			}
		},
		arg: function(self, arg){
			// rather than directly appending, maybe we return a view?
			// then we can pass everything back through here to resolve it to a view, and then handle the append, adopt, etc?
			if (!is.def(arg)){
				return;
			} else if (is.str(arg)){
				return this.str(self, arg);
			} else if (arg instanceof View) {
				return this.content(self, arg);
			} else if (is.pojo(arg)){
				this.pojo(self, arg);
				return;
			} else if (is.fn(arg)){
				return this.fn(self, arg);
			} else {
				console.error("uh oh");
				return;
			}
		},
		pojo: function(self, pojo){
			for (var i in pojo)
				this.prop(self, i, pojo[i]);
		},
		prop: function(self, name, value){
			var view = this.arg(self, value); // append "anonymously" --> makes the value a view, and adds it to .content
			// also 'adopt' the view:
			// console.log("append.prop", name, value);
			if (view){
				// the assignment can already be made...
				// if we use .set({ named: view }), it'll make the assignment automatically, whether we append or not.
				if (!self[name])
					self[name] = view;
				else if (self[name] !== view){
					console.error("don't append over an existing property");
				}

				view.parent = self;
				view.name = name;
				!view.initialized && view.initialize();
			} else {
				console.error("uh oh");
			}
		},
		content: function(self, view){
			// debugger;
			self.el.appendChild(view.node());

			if (self.content){
				if (self.content.isColl){
					self.content.append(view);
				} else {
					self.content = new View.Coll(self.content, view);
					self.content.parent = self;
				}
			} else {
				self.content = view;
			}

			return view; // used in append.prop()
		},
		fn: function(self, fn){
			return this.arg(self, fn.call(self)); // used in append.prop()
		},
		str: function(self, str){
			// appending a str should default to Text
			// you could also .append(View.HTML("<render>me</render>")), if you wanted to insert some random html...
			// maybe even a few:  View.UnsafeHTML
			// console.log("view.append.str");
			return this.content(self, new View.Text(str)); // used in append.prop()
		}
	}).wrapper,
	logger: function(){
		console.group(this.name + "{" + this.constructor.name + "-" + this.id + "}");
			console.log("this", this);
			console.log('el', this.el);
			console.log("content", this.content);
			if (this.content)
				this.content.logger();
		console.groupEnd();
	}
}).assign({
	/* View.a({ // a for 'append', or 'auto', or 'autoAppend'
		named: "str" --> uses append instead of set
		arr: [ append, "all", of, "these" ]
	});
	Opposed to normal, where .set is used, and plain strings just get assigned. */
	a: function(){
		// !!! this has to be built in, we can't modify instantiate after its called...
		return this.preset(arguments, {
			instantiate_append: true
		});
	},
	div: function(){
		var args = [].slice.call(arguments);

		if (is.obj(args[0])){
			args[0].tag = "div";
		} else {
			// if first arg isn't an object, there can be no vitals..
				// vitals:  props that are needed immediately, before instantiate, and are used in .config()
			// so we'll add it
			args.unshift({
				tag: "div"
			});
		}

		return this.apply(null, args);
	},
	preset: function(args, presets){
		// !! but sometimes the presets need to be first
			// name, log, tag
		/*
		maybe we should make a list of 'vitals', which are .set before?
		But, you could come up with use cases for any number of rounds of config, set, reconfig, set, initialize, etc...
		*/
		args = [].slice.call(args);
		args.push(presets);
		return this.apply(null, args);
	}
});

View.Coll = Mod.extend({
	name: "ViewColl",
	isColl: true,
	instantiate: function(){
		this.views = [];
	},
	append: function(view){
		this.views.push(view);
	},
	appendTo: function(){
		// use the docFrag to append to another
		// this nukes the docFrag...
		// either need to rebuild, or trash the whole view..
	},
	node: function(){
		console.warn("this will remove all views from their current DOM parent.."); // only use this when trying to move the nodes
		var frag = document.createFragment();
		// append all nodes
		for (var i = 0; i < this.views.length; i++){
			frag.appendChild(this.views[i].node());
		}
		return frag;
	},
	logger: function(){
		console.group("View.Coll");
		for (var i = 0; i < this.views.length; i++){
			this.views[i].logger();
		}
		console.groupEnd();
	}
});

View.Text = Mod.extend({
	// set: function(value){
	// 	console.log("View.Text.set value", value);
	// 	this.value = value;
	// },
	instantiate: function(value){
		this.initialized = false;
		this.value = value;
		this.tnode = document.createTextNode(value);
		// this.build = arguments;
	},
	initialize: function(){
		this.initialized = true;
		// console.log(this.value);
		// this.tnode.textContent = this.value;
	},
	node: function(){
		return this.tnode;
	},
	logger: function(){
		console.log("View.Text", this.value);
	}
});



// clone could be considered the way to rebuild.  rather than using the same instance to make a new DOM/view, just consider each view as a one-time use.  When you're done, you need to clone it?