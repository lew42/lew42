var Mod = require("mod42/v1a");
var is = require("util42/is");
var setfn2 = require("set42/setfn2");

var lowerCaseFirstChar = function(str){
	return str[0].toLowerCase() + str.substring(1);
};

var View = module.exports = Mod.extend({
	name: "View",
	tag: "div",
	set: setfn2,
	// I don't think auto appending is a good idea - there are plenty of times it's handy to pass references via constructor
	// _set_prop$: function(value, name){
	// 	// prototypes don't have .el, but we still might want to add a prototype.subView
	// 	if (this.el && (value instanceof View)){
	// 		this.append_view(value, name);
	// 		// return true to indicate that we've handled this property
	// 		return true;
	// 	}

	// 	// return false to do standard set procedure
	// 	return false;
	// },
	instantiate: function(){
		this.config.apply(this, arguments);
		// to ._set_value, we need el
		this.instantiate_el();
		this.prerender();
		this.set.apply(this, arguments);
		this.classify();
		this.initialize();
	},
		config: function(){
			this.config_tag.apply(this, arguments);
		},
			config_tag: function(){
				for (var i = 0; i < arguments.length; i++){
					if (is.pojo(arguments[i]) && arguments[i].tag){
						this.tag = arguments[i].tag;
					}
				}
			},
		instantiate_el: function(){
			if (this.el){
				this.el = this.el.cloneNode(false); // shallow clone, we'll rebuild it dynamically
			} else {
				this.el = document.createElement(this.tag);
			}


			// this.node = this.el;
		},
		prerender: function(){}, // orp
		// must return a meaningful value
		_set_sub: function(value, parent, name){
			if (value instanceof this.constructor){
				return value; // overrides
			} else if (parent.hasOwnProperty(name)){
				return this.set(value); // returns `this`
			} else {
				return this.clone(value);
			}
		},
		_set_value: function(value){
			if (is.fn(value)){
				this.render = value;
			} else if (is.str(value)){
				if (value[0] === "."){
					this.name = value.substring(1);
					this.addClass(this.name);
				} else {
					this.el.textContent = value;
				}
			} else {
				this.el.textContent = value;
			}
		},
		classify: function(){
			// what if class name gets changed?
			// also, if we extend List to List2, do we want both list and list2?  Probably..
			if (this.name !== lowerCaseFirstChar(this.constructor.name) && this.name !== this.tag && this.name !== "view")
				this.addClass(this.name);

			var cls = this.constructor, classes = [];
			while (cls !== View){
				classes.push(lowerCaseFirstChar(cls.name));
				cls = Object.getPrototypeOf(cls.prototype).constructor;
			}

			classes
				// .reverse()
				.forEach(function(c){
				this.addClass(c);
			}.bind(this));
		},
	initialize: function(){
		this.render();
		this.update();
	},
	toggle: function(){
		if (display === "none")
			return this.show();
		else {
			return this.hide();
		}
	},
	style: function(){
		return getComputedStyle(this.el);
	},
	hide: function(){
		this.el.style.display = "none";
		return this;
	},
	// display type vs current display prop..
	// I have no idea how the .el.style and getComputedStyle systems work (in terms of load/performance)
	// display: function(value){
	// 	if (value){
	// 		this._display = value;
	// 		this.el.style.display = value;
	// 	} else {
	// 		if (!this._display)
	// 	}
	// },

	// this requires the element to be hidden with .hide(), in order to store the initial display vlaue..
	show: function(){
		this.el.style.display = "";
		return this;
	},
	render: function(){},
	update: function(){},
	append: function(value){
		var arg;
		for (var i = 0; i < arguments.length; i++){
			arg = arguments[i];
			if (is.simple(arg)){
				this.el.append(arg.toString());
			} else if (is.pojo(arg)){
				for (var j in arg){
					this.append_prop(arg[j], j);
				}
			} else if (arg.el){
				this.append_view(arg);
				// if (!this[arg.name])
				// 	this[arg.name] = arg;
				// this.el.appendChild(arg.el);
			} else {
				this.el.append(arg);
			}
		}
		return this;
	},
	append_prop: function(value, name){
		// arg[j] ==> value
		if (value.el){
			this.append_view(value, name);
		} else {
			this[name] = document.createTextNode(value.toString());
			this.el.appendChild(this[name]);
		}
	},
	append_view: function(view, name){
		name = name || view.name;
		
		if (this[name])
			console.warn("appending against existing property");
		
		if (this[name] === view)
			console.warn("already set");

		this[name] = view;

		if (view.parent)
			console.error("attempting to readopt?");

		view.parent = this;
	
		if (name !== view.name)
			view.addClass(name);

		this.el.appendChild(view.el);

		this.append_view_ && this.append_view_(view, name);
	},
	getOrMakeNode: function(any){
		if (is.simple(any)){
			return any.toString();
		} else if (is.pojo(any)){
			for (var i in any){
				this.getOrMakeNode(any[i]);
			}
		}
	},
	prepend: function(value){
		var arg;
		for (var i = 0; i < arguments.length; i++){
			arg = arguments[i];
			if (is.simple(arg)){
				this.el.prepend(arg.toString());
			} else if (is.pojo(arg)){
				for (var j in arg){
					if (arg[j].el){
						this[j] = arg[j];
						this[j].addClass(j);
						this.el.prepend(arg[j].el);
					} else {
						this[j] = document.createTextNode(arg[j].toString());
						this.el.prepend(this[j]);
					}
				}
			} else if (arg.el){
				this.el.prepend(arg.el);
			} else {
				this.el.prepend(arg);
			}
		}
	},
	click: function(cb){
		this.el.addEventListener("click", cb.bind(this));
		return this;
	},
	addClass: function(className){
		this.el.classList.add(className);
		return this;
	},
	removeClass: function(className){
		this.el.classList.remove(className);
		return this;
	},
	hasClass: function(className){
		return this.el.classList.contains(className);
	}
});