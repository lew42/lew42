var Base = require("base42/v1");
var is = require("util42").is;

var Flarg = Base.extend({
	constructor: function Flarg(){
		this.instantiate.apply(this, arguments);
	},
	isActive: true,
});

var StyledFlarg = Flarg.extend({
	constructor: function StyledFlarg(){
		this.instantiate.apply(this, arguments);
	},
	str: "",
	style: "",
	instantiate: function(str, style){
		this.str = str;
		this.style = style || "";
	}
});

var Flarg2 = Base.extend({
	constructor: function Flarg(){
		this.instantiate.apply(this, arguments);
	},
	instantiate: function(){
		var arg;
		// add any value, or a BLF w/ .flog
		for (var i = 0; i < arguments.length; i++){
			arg = arguments[i];
			// console.log(arg);
			if (is.fn(arg) && arg.flog)
				this.addFlog(arg.flog);
			else if (is.fn(arg) && arg.noop){
				return this;
			} else if (arg instanceof Flog){
				this.addFlog(arg);
			} else if (	is.arr(arg) && 
						arg.length === 2 && 
						is.str(arg[0]) &&
						is.str(arg[1]) &&
						arg[1].indexOf(":") !== -1){
				// shorthand for a styled string [str, style]
				// this prevents the flogging of a 2-length array with 2 string values, the second of which contains a ":".  But, you could always use the plain .log function if you need to, and it's rare this will be a problem...
				this.addStyled(arg[0], arg[1]);
			} else if (is.str(arg) && !this.sealed){
				this.addStyled(arg); // .f(str) is basically unstyled, but this prevents the flog from sealing
			
			} else
				this.addUnstyled(arg);
		}

		return this; // important
	},

});

/*

nestable flogs:
	* instead of .addFlog immediately unwrapping the object (boo)
	* the flog should just be added to flog.flogs[]
	* when a flog .builds() itself, only then does it need the sub flogs args

So, if a flog has flogs
These flogs can represent { str, style }, unstyled, or a group (flog)

Which means we need a way to... unwrap the flog at buildtime

.shouldLog boolean
	allows the flog to noop
	* build() produces a fnoop
	* when the parent
*/

var Flog = module.exports = Base.extend({
	constructor: function Flog(){
		this.instantiate.apply(this, arguments);
	},
	method: "log",
	stylesForAll: "",
	instantiate: function(){
		this.assign.apply(this, arguments);


		// if (is.pojo(this.args[0])){
		// 	this.assign(this.args[0]);
		// 	this.args = [].slice.call(this.args, 1);
		// }



		if (false){
			this.args = this.args || [];
			
			this.str = "";
			this.styled = []; // { str: "", style: "" }
			this.unstyled = []; // any value

			// for chaining once the flog.log gets swapped with flog.. both the flog.log.f() and flog.f() should work
			this.f = this.add;
			this.s = this.addStyled;
			this.all = this.appendStyleToAll;

			for (var i = 0; i < this.args.length; i++)
				this.add(this.args[i]);
		} else {
			this.args = this.args || [];
			this.build = this.build2;
			this.addStyled = this.addStyled2;
			this.flargs = [];

			this.f = this.add2;
			this.s = this.addStyled2;
			this.all = this.appendStyleToAll2;

			for (var i = 0; i < this.args.length; i++){
				this.add2(this.args[i]);
			}
		}
	},
	add2: function(){
		var arg;
		// add any value, or a BLF w/ .flog
		for (var i = 0; i < arguments.length; i++){
			arg = arguments[i];
			// console.log(arg);
			if (arg === "DO_NOT_LOG"){
				return this;
			} else if (is.fn(arg) && arg.flog)
				this.addFlog2(arg.flog);
			else if (is.fn(arg) && arg.noop){
				return this;
			} else if (arg instanceof Flog){
				this.addFlog2(arg);
			} else if (	is.arr(arg) && 
						arg.length === 2 && 
						is.str(arg[0]) &&
						is.str(arg[1]) &&
						arg[1].indexOf(":") !== -1){
				// shorthand for a styled string [str, style]
				// this prevents the flogging of a 2-length array with 2 string values, the second of which contains a ":".  But, you could always use the plain .log function if you need to, and it's rare this will be a problem...
				this.addStyled2(arg[0], arg[1]);
			} else if (is.str(arg) && !this.sealed){
				this.addStyled2(arg); // .f(str) is basically unstyled, but this prevents the flog from sealing
			
			} else
				this.addUnstyled2(arg);
		}

		return this; // important
	},
	add: function(){
		var arg;
		// add any value, or a BLF w/ .flog
		for (var i = 0; i < arguments.length; i++){
			arg = arguments[i];
			// console.log(arg);
			if (is.fn(arg) && arg.flog)
				this.addFlog(arg.flog);
			else if (is.fn(arg) && arg.noop){
				return this;
			} else if (arg instanceof Flog){
				this.addFlog(arg);
			} else if (	is.arr(arg) && 
						arg.length === 2 && 
						is.str(arg[0]) &&
						is.str(arg[1]) &&
						arg[1].indexOf(":") !== -1){
				// shorthand for a styled string [str, style]
				// this prevents the flogging of a 2-length array with 2 string values, the second of which contains a ":".  But, you could always use the plain .log function if you need to, and it's rare this will be a problem...
				this.addStyled(arg[0], arg[1]);
			} else if (is.str(arg) && !this.sealed){
				this.addStyled(arg); // .f(str) is basically unstyled, but this prevents the flog from sealing
			
			} else
				this.addUnstyled(arg);
		}

		return this; // important
	},
	addFlog2: function(flog){
		this.flargs.push(flog);
	},
	addFlog: function(flog){
		if (this.sealed && flog.styled.length){
			// console.warn("can't add styled arguments after unstyled arguments");
			this.unstyled = this.unstyled.concat(flog.styled.map(function(s){
				return s.str;
			}));
		} else if (flog.styled.length){
			this.styled = this.styled.concat(flog.styled);
		}

		if (flog.unstyled.length){
			this.unstyled = this.unstyled.concat(flog.unstyled);
			this.sealed = true;
		}
	},
	addUnstyled2: function(value){
		this.flargs.push({ unstyled: true, value: value });
	},
	addUnstyled: function(value){
		// there cannot be any styled args AFTER the unstyled...
		// must be tracked (stored) in the same 'args' array, or whatever
		this.unstyled.push(value);
		this.sealed = true;
	},
	addStyled_2: function(str, style){
		if (this.sealed){
			this.add(str);
			console.warn("You cannot add styled log arguments after an unstyled log argument as been added.");
		} else {
			style = style || "";
			// used by .log.s()
			this.str += "%c" + str;
			this.styled.push(style + ";" + this.stylesForAll + ";");
		}
		return this; // important
	},
	addStyled2: function(str, style){
		this.flargs.push({
			styled: true,
			str: str,
			style: style || ""
		});

		return this;
	},
	addStyled: function(str, style){
		if (this.sealed){
			this.addUnstyled(str);
			// console.warn("You cannot add styled log arguments after an unstyled log argument as been added.");
		} else {
			// used by .log.s()
			// this.str += "%c" + str;
			this.styled.push({
				str: str,
				style: style || ""
			});
		}
		return this; // important
	},
	api: {
		f: function(){
			return this.flog.add.apply(this.flog, arguments);
		},
		s: function(str, style){
			return this.flog.addStyled(str, style);
		},
		all: function(style){
			return this.flog.appendStyleToAll(style);
		},
		build: function(){
			return this.flog.build();
		}
	},
	api2: {
		f: function(){
			return this.flog.add2.apply(this.flog, arguments);
		},
		s: function(str, style){
			return this.flog.addStyled2(str, style);
		},
		all: function(style){
			return this.flog.appendStyleToAll2(style);
		},
		build: function(){
			return this.flog.build2();
		}
	},
	appendStyleToAll: function(style){
		for (var i = 0; i < this.styled.length; i++){
			this.styled[i].style = this.styled[i].style + ";" + style + ";";
		}
		return this;
	},
	styledFlargs: function(){
		return this.flargs.filter(flarg => flarg.styled);
	},
	flogFlargs: function(){
		return this.flargs.filter(flarg => flarg instanceof Flog);
	},
	appendStyleToAll2: function(style){
		this.styledFlargs().forEach(styledFlarg => {
			styledFlarg.style += ";" + style + ";";
		});
		this.flogFlargs().forEach(flogFlarg => {
			flogFlarg.all(style);
		});
		return this;
	},
	build2: function(){
		this.sealed = false;
		this.str = "";
		this.styles = [];
		this.logArgs = [];

		for (var i = 0; i < this.flargs.length; i++){
			this.buildFlarg(this.flargs[i]);
		}

		var logArgs = [this.str].concat(this.styles, this.logArgs);

		this.log = console[this.method].bind.apply(console[this.method], [console].concat(logArgs));
		this.log.flog = this;

		this.buildAPI2();

		return this.log;
	},
	buildFlarg: function(flarg){
		if (flarg.styled)
			this.buildStyledFlarg(flarg);
		else if (flarg.unstyled)
			this.buildUnstyledFlarg(flarg);
		else if (flarg instanceof Flog)
			this.buildFlogFlarg(flarg);
		else if (is.fn(flarg))
			this.buildFlarg(flarg.call(this.flargFnCtx));
		else
			console.error("whoops");
	},
	buildStyledFlarg: function(flarg){
		if (this.sealed){
			this.logArgs.push(flarg.str);
		} else {
			this.str += "%c" + flarg.str;
			this.styles.push(flarg.style);
		}
	},
	buildUnstyledFlarg: function(flarg){
		if (this.sealed){
			this.logArgs.push(flarg.value);
		} else {
			if (is.str(flarg.value)){
				this.str += "%c" + flarg.value;
				this.styles.push("");
			} else {
				this.logArgs.push(flarg.value);
				this.sealed = true;
			}
		}
	},
	buildFlogFlarg: function(flog){
		for (var i = 0; i < flog.flargs.length; i++){
			this.buildFlarg(flog.flargs[i]);
		}
	},
	build: function(){
		var logArgs;

		if (this.all)
			this.appendStyleToAll(this.all);

		var str = "";
		for (var i = 0; i < this.styled.length; i++){
			str += "%c" + this.styled[i].str;
		}

		logArgs = [str].concat(this.styled.map(function(s){
			return s.style;
		}), this.unstyled);
		// console.log("logArgs", logArgs);
		this.log = console[this.method].bind.apply(console[this.method], [console].concat(logArgs));
		this.log.flog = this;

		this.buildAPI();

		return this.log;
	},
	buildAPI: function(){
		for (var i in this.api){
			this.log[i] = this.api[i]; 
		}
	},
	buildAPI2: function(){
		for (var i in this.api2){
			this.log[i] = this.api2[i]; 
		}
	},
	buildArg: function(arg){
		var styles;
		if (is.str(arg)){
			this.str += "%c" + arg;
			this.styles.push(this.all);
		} else if (is.arr(arg)){
			this.str += "%c" + arg[0];
			this.styled.push(arg[1] + ";" + this.all);
		} else if (is.fn(arg) && arg.flog){
			this.str += arg.flog.str;
			styles = arg.flog.styles.slice(0).map(function(style){
				return style + ";" + this.all; 
			}.bind(this));
			this.styles = this.styles.concat(styles);
		}
	}
});

/*

Should each arg be its own object?
We could then add some additional functionality to each.


Instead of dumping the flog.args into the new flog, keep them as... flogs.

Basically, each flog has flargs

Each flarg is just the .str, .str + .style, or .unstyled value.
And each flarg can also be .active or .inactive, which basically allows you to switch one off without having to do any conditional removals...


log: {
	methods: {
		arg: {
			argName: true | false | {}
		}
	}
}

If false, we set arg.active = false.
Then when we .build() the flog, inactive flogs handle their own noop.



*/