var Base1 = require("../v1");
var is = require("util42/is");
var Mod = require("mod42/v1");


var DevBase = module.exports = Base1.extend({
	createConstructor: function(){
		var DevBase = function(){
			var instance = this.__config.apply(this, arguments) || this;
			instance.instantiate.apply(instance, arguments);
			return instance;
		};
		return DevBase;
	},
	__config: function(o){
		this.__config_log(o);
		return this.__config_proxy(o);
	},
	__config_log: function(o){
		if (is.pojo(o) && is.def(o.log)){
			this.log = this.log.logger.clone(o.log).log;
			delete o.log;
		}
	},
	__config_proxy: function(o){
		if (this.log.isActive){
			return this.log.logger.getProxy(this);
		} else {
			return this;
		}
	}
	// clone: function(){
	// 	// !! Cloning this way might be dangerous:  auto-inheriting new properties of the underlying object could have unpredictable results
	// 	// BUT, if you only clone prototype.instances, then it's almost certain you won't be modifying prototypes (without extending/cloning/protecting)
	// 	var clone = Object.create(this);
	// 	clone = clone.config.apply(clone, arguments) || clone;
	// 	clone.instantiate.apply(clone, arguments);
	// 	return clone;
	// }
}).assign({
	extend: function(o){
		var opts = {}, Ext;

		// we need to configure the prototype, like we do for instances
		// we don't want the o.log property getting assigned to the prototype...
		// extract the o.log value before calling the Base1.extend
		if (is.pojo(o) && is.def(o.log)){
			opts.log = o.log;
			delete o.log;
		}
		
		// Base1.extend will assign all the args...
		Ext = Base1.extend.apply(this, arguments);

		// now we can handle the .log config, mocking the original `o` with `opts`
		if (is.def(opts.log))
			Ext.prototype.__config_log(opts);

		return Ext;
	}
});


var NOOP = function(){};

var getLogBase = function(on){
	var methods = ["log", "group", "debug", "trace", "error", "warn", "info"];
	
	// activeLogBase
	var active = console.log.bind(console);
	
	// noopLogBase
	var noop = function(){};
	
	active.isActive = true;
	noop.isActive = false;

	methods.forEach(function(method){
		active[method] = console[method].bind(console);
		noop[method] = NOOP;
	});

	active.groupc = console.groupCollapsed.bind(console);
	noop.groupc = NOOP;

	active.end = console.groupEnd.bind(console);
	noop.end = NOOP;

	active.close = function(fn, ctx){
		if (fn) fn.call(ctx);
		this.end();
	};
	noop.close = function(fn, ctx){
		if (fn) fn.call(ctx);
	};

	active.noop = noop;
	active.active = active;
	noop.active = active;
	noop.noop = noop;

	// `on` is passed in as a fn arg
	return is.def(on) && !on ? noop : active;
};



// method could extend logger
// although, method will clone its parent logger, so it can extend the .log...?

// BUT, the problem with binding everything to the logger, is that when we clone it, it can't be bound to the clone - we need it bound to the method...

// Maybe I can export the necessary building blocks that build/bind the .log, and just import them into the method, so that it can build it itself, and then bind it to itself...

/*
Base({
	log: {
		methods: {...},
		method: {
			methodName: {
				...
			}
		}
	}
});

config options:
methodName: true || false || {
	log: true || false || fn --> .shouldLog,
		// affects proxying?
		// if parent.log is on, and this has been turned off, should still proxy to squelch?
	args: true || false || ["on", "!off"] || {
		argName: true || false || "style: to; append: here;" || {
			str: "alternative label" || fn,
			style: ["append"] || "override"
		}
	}
}




To have live configs that use the base .methods, clone it, and add in the new config...

We need to pass several layers of values to the .clone fn

methods.clone(existing.settings, incoming.settings)

And how do we then save them?

Ugh... we really need to like... merge the settings and THEN clone.

If we put an instance at the method.name, instead of a pojo/bool...?
The problem here is rebasing.  If you then changed the methods defaults, the method.name would override it.

We want 'live' inheritance.

If the method.name overrides something, then....???
If the method.name clones from the methods default instance, won't it automatically 'live' inherit?

If we make sure methods is always an own property (so that it doesn't get cloned, and out of sync with the method.name's...).  But what happens when we clone the logger?
There would be a new .methods default instance, and all the method.names would have to rebase or something...?

We basically need a custom .set-like iterator/merger that will take booleans and upgrade them to pojo with log: bool.

Then keep all the settings as pojos.  The methods could be an instance.. And gives us the reference to the Method class. 

Hmm - could we use a mod as the settings pojos?  And use them to configure their set behavior? (.set_ --> this.log)

The usage would then be to use the mod settings as constructs for the methods.clone()

We could pull that off by letting .set(mod) --> .set_ --> ...

Or, use a Settings mod that sets this.constructor = Object; (so it passes the pojo test).

*/

var Method = Mod.extend({
	constructor: function Method(){
		this.instantiate.apply(this, arguments);
	},
	set_: function(value){
		if (is.bool(value)){
			this.set_log(value);
		}
	},
	set_log: function(bool){
		if (bool) this.log = this.logger.log.active;
		else this.log = this.logger.log.noop;
	},
	instantiate: function(o){
		this.set.apply(this, arguments);
		this.instantiate_settings();
		this.initialize();
	},
	instantiate_settings: function(){
		if (this.logger && this.logger.method[this.name])
			this.set(this.logger.method[this.name]);
	},
	initialize: function(){

	},
	exec: function(fn, ctx, args){
		var last = ctx.log;
		ctx.log = this.log;
			// this allows Method to create a custom .log with custom functionality for use only in that particular method...  very handy

		// do it

		ctx.log = last;

	},
	// method doesn't do anything w/o proxy...
	// setting methodName: false could mean proxy && squelch...
	get_proxy: function(){

	}
});


var Flog = Base1.extend({
	method: "log",
	all: "",
	constructor: function Flog(){
		this.instantiate.apply(this, arguments);
	},
	instantiate: function(){
		this.assign.apply(this, arguments);

		if (is.pojo(this.args[0])){
			this.assign(this.args[0]);
			this.args = this.args.slice(1);
		}

		this.build();
	},
	build: function(){
		this.str = "";
		this.styles = [];
		
		for (var i = 0; i < this.args.length; i++)
			this.buildArg(this.args[i]);

		this.log = console[this.method].bind.apply(console[this.method], [console].concat([this.str], this.styles));
		this.log.flog = this;

		return this.log;
	},
	buildArg: function(arg){
		if (is.str(arg)){
			this.str += "%c" + arg;
			this.styles.push(this.all);
		} else if (is.arr(arg)){
			this.str += "%c" + arg[0];
			this.styles.push(arg[1] + this.all);
		} else if (is.fn(arg) && arg.flog){
			this.str += arg.flog.str;
			this.styles = this.styles.concat(arg.flog.styles);
			console.warn("todo: add in .all");
		}
	}
});

/*
Ugh - method config is tricky

methodName: {
	args: function(){
		returns log.f();
	}
	arg: {
		argName: true || false || fn(){
			returns log.f();
		}
	}
}

If a methodName is set as an obj, such as the one above, and then override it with:

methodName: false

Then we lose all that config.  We want to convert that to { log: false }...


Mod({
	log: {
		method: {
			name: true || false || {
				log: true || false || nothing
			}

			name doesn't exist
				create new Settings
				+ true/false --> this.log = true
				+ { } --> 

			name is bool?  no it couldn't be...
			name is Settings object
				+ bool --> override .log prop
				+ {} --> merges it down
		}
	}
});
*/



var FNOOP = function(){
	return NOOP;
}

var Logger = Mod.extend({
	constructor: function Logger(){
		this.instantiate.apply(this, arguments);
	},
	method: {},
	methods: new Method(),
	set_log: function(bool){
		this.log = getLogBase(bool);
		this.log.logger = this;
	},
	set_: function(value){
		if (is.bool(value))
			this.set_log(value);
	},
	// method has to be a pojo, so it can have ANY prop name
	set_method: function(pojo){
		if (!this.hasOwnProperty("method"))
			this.method = Object.create(this.method);

		for (var i in pojo){
			if (is.bool(pojo[i]))
				pojo[i] = { log: pojo[i] };
			if (this.method[i]){
				if (this.method.hasOwnProperty(i))
					this.set.call(this.method[i], pojo[i]);
				else 
					this.method[i] = this.set.call(Object.create(this.method[i]), pojo[i]);
			} else {
				this.method[i] = pojo[i];
			}
		}
	},
	// creates a .log which is exported immediately
	initialize: function(){
		this.initialize_std();
		// build out the api, regardless of whether log.isActive
		this.initialize_api();
	},
	initialize_std: function(){
		this.log.active.obj = this.obj;
		this.log.noop.obj = FNOOP;

		this.log.active.f = this.f;
		this.log.noop.f = FNOOP;
	},
	f: function(){
		return new Flog({
			args: arguments
		}).flog;
	},
	fm: function(method){
		return new Flog({
			args: [].slice.call(arguments, 1),
			method: method
		}).flog;
	},
	initialize_api: function(){
		for (var i in this.api){
			if (is.fn(this.api[i])){
				this.log.active[i] = this.api[i];
				this.log.noop[i] = NOOP;
			} else if (is.pojo(this.api[i])){
				if (this.api[i].active)
					this.log.active[i] = this.api[i].active;
				if (this.api[i].noop)
					this.log.noop[i] = this.api[i].noop;
			}
		}
	},
	excludes: ["log", "hasOwnProperty"],
	getProxy: function(mod){ // each method call, which creates a unique instance, can have its own reference to the created .proxy
			// in which case, it can't have a .proxy() getter.
			// so it's called .get_proxy()
			// maybe we name this .get_proxy() also, even though its not storing .proxy?
			// or call it getProxy(), which sort of makes that distinction
		if (typeof Proxy !== "undefined"){
			return new Proxy(mod, {
				get: this.getter.bind(this)
			});
		} else {
			console.warn("Proxy is undefined.");
			return mod;
		}
	},
	getter: function(ctx, prop){
		const value = ctx[prop];

		if (is.fn(value) && this.excludes.indexOf(prop) === -1){
			return this.methods.clone({
				logger: this,
				ctx: ctx,
				fn: value,
				name: prop
			}).get_proxy();
		} else {
			return value;
		}
	},
	// use this to construct this.log, and methods can use it to get a copy that they can customize
	build: function(){
		var log = console.log.bind(console);
		// add the standard fns 
		// and the custom api
		// also create the noop api for std and custom
		return log;
	},
	clone: function(){
		var clone = Object.create(this);
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
});

DevBase.prototype.log = new Logger(false).log;