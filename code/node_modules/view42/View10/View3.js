/*

Overview:
- .content becomes the default "render" function, and can be overridden
- .content is not a wibbly wobbly value type - it's always a fn
- A dual approach can be used for Views:

View({
	one: View(),
	two: View()
}) // these are auto-added to .values[], or .contents[], or whatever, and .render() --> .capture(.content) --> render each value

Alternatively

View({
	one: View(),
	two: View(),
	content: function(){
		// overrides the default behavior
		// can reuse it easily, by calling .renderValues() or .renderContents(), or whatever
		// or, can use own logic, by accessing views by handle
		// or, can just be a dumb capture fn, like usual (View(fn(){...}))
	}
});

The auto views will need to be recaptured, which means they need to be removed from the incorrect captor's .values/.contents.  Maybe use .values, and eventually try to unify View with Coll...?


### For now, the existing Views work, so I should probably just use those, rather than fudge this whole thing and spend a week trying to rebuild it.

I really need to work on the homepage.


*/


view = {
	render: function(){
		this.captive && this.getCaptured();
		this.captor && this.becomeCaptor();
		this.capture(this.content, false);
		this.captor && this.restoreCaptor();
	},
	content: function(){
		for (var i = 0; i < this.values.length; i++){
			this.capture(this.values[i]);
		}
	},
	renderValues: function(){
		// for each .values
		this.captureValue(value);
	},
	captureValue: function(){
		// just like .capture, but we don't add it to .values
		if (is.fn)
			this.catch()
	},
	// api - view.capture(fn || anything)
	capture: function(){
		// if this specifically means, 'add to values', then maybe this should just be .add
	},
	catch: function(){
		// no need to add captured items to .values, if the fn is already in 
	},
	add: function(view, viewable){
		this.values.push(viewable);
	},
	set: {
		view: function(){
			// --> auto add
		}
	}
};

/*

set({
	sub: view
})

add(any viewable?)
--> add to .values?
--> and, currently, is basically just "append"

capture()
Currently this is a specialized .append().  We could just use .append()...
No - because sometimes we want to .append() without adding to .values

That's a good reason to not unify the jQuery api and Coll api.  But, that gets a little confusing...
We just have to remember the difference between .append() and ...add(), and .capture(), and .catch(), and setContent, and addContent, and reset, and ...???


We need:
- catch(fn) --> execute the fn, and add the captured/returned items to .values (.viewables?)

- capture(fn) --> execute the fn, which may or may not originate from .render/.content?  Right now, this forwards to

- captureFn(fn) --> becomeCaptor, exec fn, restoreCaptor, capture(return value)



this.capture(this.content);  // looks pretty nifty
--> if fn, captureFn()
	--> captured views get .add() to captor
		--> view.$el gets appended



View(View("one"), View("two")); // anonymous, no addClass

View({
	one: View("one"), // the "one" is added to .viewables
	two: View("two")  // the prop name becomes sub view's name, and addClass
});

View({
	one: View(mod.prop("one")),
	two: view,
	mod: mod,
	init: function(){
		// this.mod, and this.parent should both be set at this point, if available
		
	},
	// override the content fn to manually use props
	content: function(){
		this.two.render();
		if(something) this.one.render();
	}
})

*/