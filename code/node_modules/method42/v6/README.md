# Method5

** Methods and Mfn are fundamentally different **

They can share a similar interface, but they should be different...

- Methods have an equivalent .fn that is decoupled from the method, called with normal ctx.
vs
- Mfns have a .main that is highly coupled to the method, called with mfn as ctx.

What was the objective of the combination?
- To avoid Method(Assign()) double wrapping
	- This exacerbates the call stack, debugging, complexity, etc
- To achieve a harmonious interface (.wrapper, .fn, .main, .exec, etc);
- To log Mfn 


And I wanted to give the Mfn's exported .wrapper its own .set instance.  Why?  So that instead of auto-cloning all the time, we can allow .set({ mfn: {..} }) to figure out how to clone itself.

This is handy for methods, so that we can lean on .set to make easy modifications:

Thing.debug({
	|| debug: true,
	...
	anExistingMethod: log.method({
		// no fn needed - just pass config
		expand: false
	})
});

If a method.wrapper has its own .set, and a full copy of it (with set.sub), then setting a pojo to it shouldn't be a problem:

Thing({
	existingMethod: {
		enabled: false
	}
});

This precludes invoking a fn with an object...

For example:

View({
	css: {
		paddingLeft: "10px",
		marginTop: 0
	}
});

This is currently possible.  I'd just have to set 

View({
	css: Method({
		set: {
			pojo: function(){
				// .. instead of doing the normal set algorithm, just cut to an invocation
				// this shouldn't be a problem
			}
		}
	})
});


Ok - so.. giving 'sfn' their own .set could be handy.  We can then define all sorts of behaviors to avoid having to monkey around with reconstructing stuff.

The last problem, is how to turn it on/off.

Base and Base.Debug?
- How do you wrap previously added methods?  Iterate through the prototype, and wrap them manually?

What's the end game?  So you set up all these method configurations...
If you turn off method wrapping, then 

Thing({
	existingMethod: {
		// config
	}
});

This suddenly stops working.  Without the wrapper.set, this will invoke the existingMethod function.  Maybe I just remove invocation for pojos...  Just wrap it in an array if you want to call with it...

View({
	css: [{
		// the array wrapper won't have any lingering side effects, it's immediately unwrapped and the view.css({}) method is called with the object.
	}]
});


So then we just ignore set.fnProp with pojo?  This case could be reserved for configuring...

And, you can work around it easily.  So yes, I think that's good.


But back to the # end game.  We have Base classes and Ext classes.  We have logging on/off, and debugging on/off.  Everything defaults to "auto", and nothing logs, until we turn it on.

But what about the wrapping.  This is where it gets tricky.  

Cases:

Starting with the Base, we can choose either Base.Debug or Base, in which case the standard 3-4 methods are already wrapped for us.

But, once we extend, and add a few, we can't easily unwrap, NOR can we easily wrap?

Actually, it probably wouldn't be that hard...

Now that I'm trying to make a MfnMethod, we'd need to be able to eject the Method functionality (basically, rewrap, and reassign).

The Mfn/Methods could have an unwrap method.

for (var i in obj){
	if (obj[i].unwrap)
		obj[i].unwrap(this, i);
}

And the really tricky case - if we unwrap, the method is returned to normal.  If we want to re-wrap - our config is starting from scratch.

So how do we carry the config along, and effectively ignore it, until its time?

1)  Thing({
	existingMethod: function(){}
})

When overriding methods that are already upgraded, we shouldn't need to rewrap - the existing fn wrapper will have .set, and that will take the new fn, and swap it out with the old fn.

What if you want to override it with a normal fn?

Thing({
	existingMethod: {
		fn: function(){},
		disable: true
	}
});;


# Climb the proto chain

Let's say Base adds some config

We'll have to use a Method() wrapper at some point?
If we auto-wrap all methods, where do we put the config?
Once its wrapped, you could send another {} through to configure it...

Thing({
	debug: true, // turns on wrapping
	newMethod: function(){} // auto wrapped
}, {
	newMethod: {
		inline: true
	}
});


Let's say 
Base1.method is wrapped
Base2.method gets unwrapped
Base3.method turns wrapping on again - but all the config is lost?

This is where the method could climb the prototype chain for that property name, and see if any methods exist.  If so, use that config.


# What's the default "state"?  Auto?
--> logging off, but everything wrapped?

# This is preoptimization... just get it working!!






I'm going to try to make a very simple Method base class for a Mfn.

Then Set will extend Mfn.  And then Mfn2 needs to add .set to the .wrapper.

Once the .wrapper gets .set, then the Method stuff can be upgraded.

Maybe Method6 extends Mfn2?

Base < Method1 < Mfn1 < Set 
Method1 < Mfn2 + .set < Method2

Mfn1 extends Method1
Mfn2 extends Method1
Method2 extends Mfn2

So, at its simplest, a Method is just a wrapped function.  Let's use .wrapper as the Method/Mfn's wrapped fn.


# log: false vs debug: false

A separate flag is in order to try and reverse any auto-method wrapping attempts.

This probably should be wired in somehow to the log.wrap or log.method() wrapper...

If you upgrade a few methods, how do you switch [them all, them individually] ?



# Don't confuse "method" with "fn"

You might refer to the underlying method as the "method".  Let's try to keep a distinction between the method object, and its underlying `.fn`.


# Use underscores to hint at function usage/type

init_sub(); // called from within init(), and probably only from within init().
	// probably only exists for organization/overriding

_init(); // called before init()
init_();  // called after init()

I suppose you could use $init or init$, but I like the underscore better...

You could use $method for external API methods?
Basically, you restrict the usage of an object to `new Constructor(constructs)`, which runs instantiate + initialize.

An alternative might be to use heavy use of $methods.  Like $instantiate, $initialize, and $init.  These are all... "private", only to be accessed via `this.$whatever`.

That creates a bunch of extra `$` characters.  But, it then allows you to make a clean and deliberate public API:

obj.$private;
obj.public();

Anything defined *without* the `$` could be meant as a public API method.

These wouldn't be strict rules - it would just be a general indication to map the flows of your object.  When you have a gazillion methods that call each other, it might be hard to track.

If you use these hints, then it might make more sense who's who.  But... time would tell whether its a waste of time, or useful.  The public/private thing is probably more work/complexity than necessary.