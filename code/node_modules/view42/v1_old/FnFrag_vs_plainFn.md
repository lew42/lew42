ooo
Let's treat .set.value(fn) --> throwaway fn
That could be the default for any module (very handy).  It's like an init...  But we can still have init.
## But, they are *throwaway* fns - they're not saved.. When you clone, they won't re-run.  So their effects need to be saved, so that when you clone, the effects are carried along..




view.append(fn) --> runs immediately with view as ctx

	fn(){
		this.append("anything");
		this.append(View("anything"));
		...

		--> basically just an init fn...
	}


But, with the constructor and .set, we call them in order, so we can use functions to append stuff (and manipulate any other aspect of the object, in order..)

View("str", function(){}, "another str", function(){}, view, "str", View(), ... )

BUT

# view.append(fn) vs view.append(View(fn)) vs view.append(View.Frag(fn))

view.append(fn) --> saves the fn as a build fn, only reruns upon cloning?
	--> can't have an update fn...

View(fn) --> saves fn as a build fn?  Or, just builds and throws it away?
	Let's assume it doesn't run until it has its .parent?

# FnFrag

// we don't want a 
View.Frag(function(){
	
});