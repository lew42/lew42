var Base = require("base42/v4");
var is = require("util42").is;

var Mfn = module.exports = Base.extend({
	name: "Mfn4",
	settable: true,
	eval: true,
	set: {
		assignTo: function(self, parent, name){
			self.wrap(parent, name);
		}
	},
	initialize: function(){
		this.makeWrapper();
	},
	makeNormalWrapper: function(){
		var method = this;

		// this fn signature is different for Mfn and simple method wrappers
		this.wrapper = function(){
			return method.exec.apply(method, [this].concat([].slice.call(arguments)));
		};
	},
	makeEvaledWrapper: function(){
		// this name can't collide with 'this.name', otherwise the eval'd code thinks `mfn` was the function itself, since this.name was "mfn" in my test
		var $elf = this;

		// swap this out for production, this is just for stack trace
		this.wrapper = eval("(function " + this.name + "(){\r\n"
			+ 	"\treturn $elf.exec.apply($elf, [this].concat([].slice.call(arguments)));\r\n" 
			+ "})");
	},
	makeWrapper: function(){
		if (this.eval){
			this.makeEvaledWrapper();
		} else {
			this.makeNormalWrapper();
		}

		this.makeWrapper_();
	},
	makeWrapper_: function(){
		this.wrapper.mfn = this;

		if (this.settable){
			this.wrapper.set = { 
				sub: this.mockSetSub 
			};
		}

		this.api(); // orp
	},
	api: function(){},
	mockSetSub: function(wrapper, newValue, parent, propName){
		// override
		if (newValue instanceof Mfn){
			console.info("overridding mfn");
			// even though this probably goes straight to newValue.set.assignTo, we'll give the parent a chance to instrument or whatever
			parent.set.assignProp(parent, propName, newValue);
		
		// protect?
		} else if (is.pojo(newValue)){
			if (parent.hasOwnProperty(propName)){ // maybe this is ok
				console.warn("Is this safe?  Are you sure the mfn is unique to this object?");
				wrapper.mfn.assign(newValue);
			} else { // protect.
				wrapper.mfn.clone(newValue).set.assignTo(parent, propName);
			}
		} else {
			console.error("what to do");
		}
	},
	// exec logic could be dumped directly into the wrapper, which reduces call stack... 
	// leave this alone, for now
	exec: function(ctx, arg1, arg2){ /*implement here*/ },
	wrap: function(parent, name){
		if (this.hasOwnProperty("name") && this.name !== name){
			console.error("Name mismatch.  Once mfn is directly assigned, you probably don't want to inadvertently share it?  If you assign the same mfn.wrapper to 2 different objects, and later .set against that mfn, it will modify it in place - and because its a shared reference, both instances will be modified.");
		}
		this.name = name;
		this.makeWrapper(name); // depends on name!
		parent[name] = this.wrapper;
	}
});