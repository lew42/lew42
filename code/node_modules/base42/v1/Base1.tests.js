var test = require("test42");
var View = require("view42/v8");
var util = require("util42");
var is = util.is;

var assert = test.assert;

var Base = require("./Base1");

var assertClassInstance = function(Class, instance){
	assert(instance instanceof Class);
	assert(instance.constructor === Class);
	assert(Object.getPrototypeOf(instance) === Class.prototype);
};

var assertBaseExt = function(Base, Ext){
	assert(Object.getPrototypeOf(Ext.prototype) === Base.prototype);
};


test("new", function(){
	assertClassInstance(Base, new Base());
});

test("extend", function(){
	var Base2 = Base.extend();
	var Base3 = Base2.extend();
	var Base4 = Base3.extend();
	assertBaseExt(Base, Base2);
	assertBaseExt(Base2, Base3);
	assertBaseExt(Base3, Base4);
});

test("console.log appearance", function(){
	console.log(new Base());
});

test("with assign, anything is possible!", function(){
	var Base2 = Base.extend({
		instantiate: function(){
			check = this;
		}
	}), check;

	base = new Base2();

	assert(check === base);
	console.log(base);
});

test("provide .constructor", function(){
	var Base2 = Base.extend({
		constructor: function Base2(arg1, arg2){
			Base.call(this);
				// if this pattern of extend + Base.call(this) is done repeatedly, the call stack will get deep and a little annoying to step through
			this.whatever();
			// advantages: 
				// define your own args
				// see the constructor (visibility)
				// give your constructor a name (good for logging/debugging)
				// skip the .instantiate abstraction, if you want
			// disadvantages:
				// must Base.call(this) in order to maintain functionality
				// must provide a .constructor when extending
					// or, could potentially reuse the Base's constructor, but that's a little iffy
		}
	});
});

test("pass in constructor", function(){
	/*
	This is nice, but it won't carry on..
	If you extend Base2, for example, it'll revert to using .createConstructor
	In that case, anything you've put inside the constructor won't work.
	You could call the parent constructor...

	Here, it would be:  Base.call(this);

	But, in the case of a maybe return constructor, you could

	return Base.call(this);

	But if you wanted to add anything to it, you'd have to save the return value, then do your thing, then return:

	var ret = Base.call(this);
	// do something
	return ret;

	A deep constructor call stack hurts debugability

	I think having a fixed constructor is probably the best...
	If you want to change it, you redefine the class from the ground up?

	*/
	var Base2 = Base.extend({
		createConstructor: function(args){
			var ClassName = function(){
				this.instantiate();
			};
			return ClassName;
		},
		constructor: function Base2(){
			this.assign.apply(this, arguments);
			this.instantiate.apply(this, arguments);
		},
		instantiate: function(){
			console.log("woo hoo!", arguments);
		}
	});

	var base = new Base2("weeee");
	console.log(base);
 
 	var Base3 = Base2.extend({
 		constructor: function Base3(){
 			Base2.call(this);
 			// if we go this route, 10 extends means 10-deep call stack...
 		}
 	})
});


/*
Don't Repeat Yourself
With one exception:  the constructor...
We can't easily "extend" the constructor, without having some nasty side effects.

In fact, calling Base.prototype.method.apply(this, arguments); is kind of a bad idea.
It works - and it can be reused throughout many extensions.  However,
* It obfuscates the real functionality:
	Base.prototype.method --> this.a(); this.b();
	vs 
	this.a(); this.b();

	Hopefully the 'remaining' code is simple enough that you can just repeat it without much issue.
* In the event that it's not simple to repeat the code, and if there's not many levels of re-calling a method, I suppose its ok...


*/
