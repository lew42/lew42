View(View()) // --> <div><div></div></div>
View("yea");
View(View("yea")) // added w/o handle
View({
	one: View(), // view.one && addClass("one")
			// have to recapture this
	two: View(function(){
		View("this");
		this.that = View("that");
		// this.parent not yet defined?
		// maybe .parent.then(render) ?
			// but how do we configure that?  View.x is better?

		// fn.toString, indexOf("this.parent") ?
		// 	if so, wait for .parent
		//  otherwise, it doesn't need to wait...
	})
});



/*
Fix .content[] and allow recapture

Optionally add captured items to .content array:
- Any function can be captured.  The question is whether to keep the function, or keep the captured contents.
- If you keep the captured contents, then you don't need the function...
- If you keep the function, you don't want to store what was captured, because you'll be running it again when you clone or rerender.

The default capture(fn(){}) could save the fn?  This would be a little more dynamic...

If you're inside the render function, it should use a captureAndRelease()?
That just runs the fn as a temporary means to capture the views, in order, with logic, etc.  But, instead of storing the fn, we actually add the views to the .content[] array.

Decision:  Should .content always be an array?

.set({ content }) could still work, even if it is...
And, it could make it much less confusing than having to type check the shit out of it every time...


*/

var view = {
	release: function(view){
		if (this.content === view)
			// uh oh - this erases a previous value?
			// no - if there were a previous value, it would have upgraded .content to an array?
			delete this.content;
	},
	set: {
		// could be "getSetAsSubToParent" - this is called by a parent when setting a child module
		// this gets called when the parent.sub property is undefined, or when parent.sub is getting overridden - in either case, its where the actual assignment takes place...
		sub: function(sub, ){
			// install, adoption (setup?)
		},
		// this is another transfer of control
		// there are really 3 players at the .set table:
			// 1) the mod that .set is called from
			// 2) the value passed to propName
			// 3) the existing value, if any
		// here, the mod transfers to its existing sub
		override: function(sub, parent, name, value){
			if (value instanceof sub.constructor){
				// override it
				return value;
			} else {

			}
		},
		stdProp: function(mod, prop, value){
			if (value.set.mfn.sub){
				mod[prop] = value.set.mfn.sub(value, mod, prop);
				// probably just returns itself, but who knows...
			} else {
				mod[prop] = value;
			}
		},
		prop: function(mod, prop, value){
			if (mod[prop].set.mfn.override){
				this.stdProp(mod, prop, mod[prop].set.mfn.override(mod[prop], mod, prop, value));
			}
		},
		fromParent: function(){

		},
		parental: function(mod, parent, name){
			if (is.def(parent[name])){
				this.override(mod, parent, name);
			} else {

			}
		}
	}
};

/*


MyView(function(){
	View(View("one"), View("two"))
});

If MyView.content = "something", I guess this content fn would upgrade .content to an array...

The only time you might have a loss of data:

MyView.content = "something";

Then myView = MyView.x(); // it doesn't render
myView.capture(function(){
	View(View("one"), View("two")); // one and two will get captured and..?
});

I think in any capture situation, the incoming content is always appended...

Then, a problem might be that you upgrade .content to an array, then remove the incorrectly added view, which has converted .content to an array, and not back to its original value...

I suppose release could do that?


Alternative to dynamic .content value?
- Always use array?

I think the main problem there, is the .set({ content: "str", fn, etc })





*/