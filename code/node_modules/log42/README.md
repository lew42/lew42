# .log

var log = this.log; // quick access
	// this.log will be switched between the noop and the active logger

var log = this.log.on(); // returns the enabled logger
var log = this.log.off(); // returns the noop logger
	// doesn't change this.log reference, so this doesn't affect any state

If you were to do

this.log = this.log.off() // perfectly fine/legal, but you can't restore the previous state without doing a little logic...

So you could do:

this.log.off(this, function(){
	// re-assigns this.log --> noop (or enabled, in the case of .on())
	this // <-- preserved, based on passing this along
});

this.log.off(this) --> just turns it off, equivalent of
this.log = this.log.off();

this.log.restore(this) <-- must track an array of log states for this to work.


# log state

Imagine logging is turned off.  In our code, we might have 2 situations:

var log = this.log.on(); // this is the best!! doesn't change the state of this.log

1. this.log should be left off (silent, clean logs should be the baseline);
2. If you want to log a specific function, you turn it on via var log = this.log.on();

Probably faster/better to just use a direct reference:

var log = this.log.on;  <--->  var log = this.log; (auto)  <---> var log = this.log.off;

