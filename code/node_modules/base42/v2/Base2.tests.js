var test = require("test42");
var View = require("view42/v8");
var util = require("util42");
var is = util.is;

var assert = test.assert;

var Base = require("./Base2");

var assertClassInstance = function(Class, instance){
	assert(instance instanceof Class);
	assert(instance.constructor === Class);
	assert(Object.getPrototypeOf(instance) === Class.prototype);
};

var assertBaseExt = function(Base, Ext){
	assert(Object.getPrototypeOf(Ext.prototype) === Base.prototype);
};


test("new", function(){
	assertClassInstance(Base, new Base());
});

test("extend", function(){
	var Base2 = Base.extend();
	var Base3 = Base2.extend();
	var Base4 = Base3.extend();
	assertBaseExt(Base, Base2);
	assertBaseExt(Base2, Base3);
	assertBaseExt(Base3, Base4);
});

test("console.log appearance", function(){
	console.log(new Base());
});

test("with assign, anything is possible!", function(){
	var Base2 = Base.extend({
		instantiate: function(){
			check = this;
		}
	}), check;

	base = new Base2();

	assert(check === base);
	console.log(base);
});

test("hmm", function(){
	// debugger;
	var base = new Base({
		log: true
	});

	base.log("hi");
});

// test("log, logger, etc", function(){

// 	var b = new Base({
// 		log: {
// 			// by itself, this is just assigned to the logger
// 			myCustomStyledLogMethod: function(ctx, prop){
// 				return this.f(this.mod(ctx), this.value(prop, ctx[prop]) );
// 				// for example...
// 			},
// 			api: ["myCustomStyledLogMethod"]
// 		}
// 	});// BAD

// 	//GOOD
// 	var b = new Base({
// 		log: {
// 			proxy: false, // prevents method proxying...

// 			// in a way, I could see "methods" being the default config for ALL methodS, and method being the per-method name config...
// 				// i kind of like that better, but it's a little confusing...
// 			methods: false, // don't log any methods --> doesn't proxy?
// 				// what if you just want simple logging without proxying?
				
// 			method: {
// 				methodName: {
// 					log: false,
// 					suppress: true, // tries to silence internal logs, which is helpful if you're trying to inline a summary
// 						// suppress should default to true if log is false
// 					close: function(){
// 						// use the close function to summarize the method
// 						// "inline" it.. (won't group anything)
// 					}
// 				}
// 			},
// 			api: {
// 				myCustomStyledLogMethod: function(ctx, prop){
// 					return this.f(this.mod(ctx), this.value(prop, ctx[prop]) );
// 					// for example...
// 				}
// 			}
// 		}
// 	});
// });






/*
To avoid having to copy the .log onto each instance when modified (not a huge deal)...
We could have the .logger property also to store config stuff.

Currently the proxies check the current status of mod.log.isActive, and also use 'live' configuration from the ._log property.

It's not particularly intuitive to use this._log.whatever to configure.
You could, currently, use .set_log({}) to do it.

Or, this.logger could be a read only, shared property, that's cloned?
If we clone, and then the underlying changes, we have problems...

The only safe way would be to iterate and manually copy the properties...
If we have lifecycle methods: load, data, save...
These could be used to clone - you're just extracting the data, and creating a new one with the same properties...

.log
.logger

Shared + read only + protect upon changing?
This is dangerous, because you can't modify the log settings in your code without manually protecting.

If we just automatically cloned the .log for every instance, we're a little closer to the view-based logger...

* If !this.log.isActive, just leave it - it's off, won't be used
* If this.log.isActive, and we're proxying, then clone the .log property?


# log.f: returns a "Formatted, Composable, Console-Bound Log Function"
log.f("str", log.styled(..), {}, [], mod);
 --> must convert them all to strings, so it tries its best to format them appropriately

log.f() returns a console-bound log fn ready to be called in-place.

log.styled()
	return log.f(...);

then
log.styled(args)(); // logs in place

BUT, what method does log.f use?

log.fg --> group
log.fgc --> groupCollapsed
log.fi --> info
log.fw
log.fe ??
log.fm("methodName", args);
 --> uses console[methodName]

log.fm("group", log.f(...)); // can compose, so you can then dump in any other styled log fn...


log.f(["actual", "values"]) --> tries to format it to {str,style} ?
log.f([fccblf, "actual", ...]) --> can iterate over each item
	but, we probably should apply them, because how do we know if we're supposed to log the array, or make the array dissolve

	You could have an auto-apply, so you wouldn't have to do argument juggling:
	log.fa([]) // applies the array, instead of displaying the "[...]" brackets
	log.fma("methodName", []); --> so you don't have to do
	log.fm.apply(null, ["methodName"].concat([])); // not hard...




Base({
	log: true || false || {
		log: true || false,
		Method: {},
		methods: {
			methodName: true || false || fn(){} || {
				open: function(){
					this.group || this.groupCollapsed.a
				},
				args: true || false || fn || ['argNameToShow', '!argNameToHide'] {
					argName: true || false || fn || {}
				}
			},
			methodName: function(){
				// default:
				return log.fm("group", logArgs)
			}
		},
		api: {
			// get added to .log
			custom: function(){ // could bind this to the mod, if its all hasOwn anyway..
				return this.log.f
			}
		},
		config: fn || {
			// props and methods that get added to the .log, just as api
			// but these aren't bound to the mod, but left as natural methods
			config: function(){
				this is the .log?
				// I suppose this is unnecessary, considering you could just do:
				this.log.whatever
				// inside the api
			}
		}
	}
});

The question is, will we need to modify the log config mid-fn?  Or is it just once at instantiation?
	If we do change the logger settings, like this.log.config({}), this can't easily protect itself?
	I suppose it could...
	But, if some log sub methods were bound to the mod, it would be much easier to work with...

	Instead of this.log.custom(this, arg1, arg2);
	You could do this.log.custom(arg1, arg2); 

	Which isn't a big deal..

	But, this.parent.log.id(); or this.parent.log.label(); without haivng to pass this.parent back to it..

	RELATIVE
	> Share .log, until its modified
	> Maybe move the live config to a separate property, .logger
	> 

	BASE (no .log fn available) vs BASE.DEV (either noop .log, or active .log)
	With the Base.Dev, I might consider leaving it in Dev mode even in production (no need to comment everything out).  If it can have similar performance.
	> If you modify the .log api:  .log.custom() for example...
	> You can't just have 1 shared .log, you need to provide a noop api.

And, unifying Logged and Logger, Method, Args, etc...


*/


/*

Logger
	represents a logged module
	creates its own configurable .log
	exports that .log to the mod
	attaches itself to the .log

mod.log.logger instanceof Logger
logger.log === mod.log

Mod({
	log: {} --> mod.log = mod.log.logger.clone({}, {parent: mod})
})

When we config a method, or arg, or whatever, we can cherry pick any methods of the logger.


What goes on the .log as an api, and what stays in the logger?
I suppose the .log.custom fns can access this.logger to have access to everything...

Logger
	instantiate
		auto clone .method

Mod({
	log: {
		method: {} // prototype instance - gets auto-cloned?  or read-only and clone when modified?
			represents the default method, and takes the place of the Method class
	}
});

If .log is unique per instance (even in the inactive Dev mode, we need to mock/noop the API), then we don't need a .logger instance...

We don't absolutely need to bind to the mod, though.

So we could have the same: everything is on the .log && .log.logger, and it's shared (read-only) until modified, at which point it clones itself.

** But, to protect the prototype when extending, we need some special logic in .extend**
Mod.extend({
	log: ... // --> needs to clone itself onto the prototype - not modify the underlying .log
		// no .config will run for prototype?
		//  ** just override extend, and call __config at the end
});

# Unifying the api/config

Mod({
	log: {
		
	}
})






The Logger will handle the proxying and the .log config
* always config the .log, so we can provide the correct noop api
* if log.isActive, proxy the thing

*/

