var Base = require("base42/v1");
var is = require("util42/is");

var Mod = module.exports = Base.extend({
	createConstructor: function(){
		return function Mod(){
			this.instantiate.apply(this, arguments);
		}
	},
	instantiate: function(){
		this.set.apply(this, arguments);
		this.initialize.apply(this, arguments);
	},
	initialize: function(){},
	set: function(){
		var arg;
		for (var i = 0; i < arguments.length; i++){
			arg = arguments[i];
			if (is.pojo(arg)){
				for (var j in arg){
					if (this["set_" + j]){
						this["set_" + j](arg[j]);
					} else if (is.simple(this[j])){
						this[j] = arg[j];
					} else if (this[j] && this[j].set) {
						if (this.hasOwnProperty(j))
							this[j].set(arg[j]);
						else
							this[j] = this[j].clone(arg[j]);
					} else if (j === "assign") {
						this.assign(arg[j]);
					} else if (is.pojo(this[j])){
						if (this.hasOwnProperty(j))
							this.set.call(this[j], arg[j]);
						else {
							this[j] = Mod.prototype.set.call(Object.create(this[j]), arg[j]);
						}
					} else {
						// basically just arrays and fns...
						console.warn("what are you", arg[j]);
						this[j] = arg[j];
					}
				}
			} else if (this.set_){
				this.set_(arg);
			} else {
				console.warn("not sure what to do with", arg);
			}
		}

		return this; // important
	},
	/*
	* Caveats to cloning:
	*  - properties can show through (live inheritance)
	*  - reinstantiating an object might be unpredictable - it depends on what kind of state your object has, and what happens in instantiate.  Also, if any external side effects.
	*/
	clone: function(){
		var clone = Object.create(this);
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
});




/*


MAYBE MOD IS THE DEV BASE...
I don't really see a major advantage to removing all your log statements.  Eventually it could be automated if performance was suffering.  But I don't think it's that big of a deal.  Instead of switching classes (which means maintaining 2 versions of classes?).
- You'd only need 2 bases:  you pick which one to extend from.

With Base and Base.Dev, we have 2 different constructors.
*/
// var Mod = module.exports = Base.extend({
// 	name: "Mod1",
// 	autoInitialize: true,
// 	instantiate: function(){
// 		this.assign.apply(this, arguments);
// 		this.autoInitialize && this.initialize.apply(this, arguments);
// 	},
// 	// orp
// 	initialize: function(){},
// 	assignTo: function(){
// 		console.warn("Probably revert assign to a very simple, no set_*, no assignTo nonsense.  And separate set.sub into both the 'override' usage, and the 'assignTo' usage.  set.to?  I think that makes sense.  set.up is kind cool too.");
// 	}
// }).assign({
// 	sub: function(){
// 		var args = [].slice.call(arguments);
// 		return this.apply(null, [{ adopt: true }].concat(args));
// 	},
// 	x: function(){
// 		var args = [].slice.call(arguments);
// 		return this.apply(null, [{ autoInitialize: false }].concat(args));
// 	}
// });

/*
Mod --> View

Add .set to this Mod.  But try to keep it simple.  And logged.
*/