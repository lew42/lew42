var Mfn = require("mfn42/v4");
var is = require("util42").is;

/*
* Unless I add .set to the Mfn/Set, I can only have 1 level of Mfns..
* I think that's OK for now, just realize that set({ set: <any> }) will invoke the mocked wrapper.set.sub fn, which then clones the wrapper.mfn (and effectively assigns the incoming value, so it should always be an abjict, ectually.)
*/

var Set2 = module.exports = Mfn.extend({
	name: "Set2",
	api: function(){
		this.wrapper.sub = this.sub;
		this.wrapper.assignProp = this.assignProp;
	},
	exec: function(mod){
		for (var i = 1; i < arguments.length; i++){
			this.arg(mod, arguments[i]); // keep mod as first arg
		}
		return mod; // important
			// for chaining
				// var result = something(); // vs
				// var result = something().set(); // can be equivalent, if set() returns the starting value... 
			// and if we ever go back to using this return value as the way to override...
				// which isn't a great idea - because when we consider Mod(...) vs set({ mod: ... }), the overriding wouldn't mean anything during construction.  And we'd have to figure out how to handle those cases differently.
			// too bad i'll end up deleting this comment to clean up this file.  This info would be great to have tagged here for later...
	},
	arg: function(mod, arg){
		if (is.pojo(arg))
			this.obj(mod, arg);
		else
			this.other(mod, arg);
	},
	other: function(mod, arg){
		this.value.call(mod, arg);
	},
	obj: function(mod, obj){
		for (var i in obj){
			this.prop(mod, i, obj[i]);
		}
		return mod; // used in .objProp()
	},
	prop: function(mod, prop, value){
		// this should work for pojos...so no funny business

		var currentValue = mod[prop],
			hasOwn = mod.hasOwnProperty(prop);
				// this order is important, because we touch the value before checking hasOwn, it triggers auto cloning

		if (is.fn(mod["set_" + prop])) {
			mod["set_" + prop](value);
			
		} else if (is.simple(currentValue)){
			this.assignProp(mod, prop, value);

		// recursively set
			// don't do a fn check, sometimes we mock .set() with an object
		} else if (currentValue.set){
			this.propWithSet(currentValue, value, mod, prop);

		// Mfn is one use case for having .clone w/o .set
		// .set({ someMfn: ... }) ALWAYS clones, which is desirable to protect prototype chain??
		// it doesn't need to clone if it has own...?
			// if we plan on reusing the same reference on multiple objects, which i've sometimes done (like, prototype.set = set, and Class.set = set..), then its possible that it would haveOwn but that would be a shared reference...
			// Ahh - mfn w/o .set will hit this...
			// Adding .set w/ .set.sub is probably the best way
		} else if (currentValue.clone && (!hasOwn || currentValue.mfn)){
			console.error("this shouldn't happen anymore");
			this.assignProp(mod, prop, currentValue.clone(value));

		} else if (is.fn(currentValue)) {
			this.fnProp(mod, prop, value);

		} else if (is.obj(currentValue)){
			this.objProp(mod, prop, value);

		} else if (is.arr(currentValue)){
			this.arrProp(mod, prop, value);

		} else {
			console.info("what are you?");
			this.assignProp(mod, prop, value);
		}
	},
	propWithSet: function(currentValue, value, mod, prop){
		if (currentValue.set.sub){
			currentValue.set.sub(currentValue, value, mod, prop);
		} else if (currentValue.set.mfn){
			console.warn("promote all mfn 'api' methods to the wrapper, which will make 'compiling' the mfn easier, and makes it clear which methods are meant to be called independently.");
			currentValue.set.mfn.sub(currentValue, value, mod, prop);
		}
		else
			currentValue.set(value); // doesn't allow override, unless I go back to re-assigning the return from this... which isn't terrible, especially if you might want to revert to a normal fn...
	},
	arrProp: function(mod, prop, value){
		if (!mod.hasOwnProperty(prop)){
			console.warn("always wear protection");
		}

		// maybe [] + [] ==> assign?
		// [] + [[]] ==> push
		// [] + [[ [] ]] ==> push an array
		// i suppose you can always { assign: { arr: [] } } to override...

		var current = mod[prop];
		if (is.arr(value)){
			current.push.apply(current, value);
		} else if (is.pojo(value)){
			// i think this should allow { push: ..., unshift: ..., etc }
			// unshift: [] to call (apply) without args?
			this.obj(current, value);
		} else {
			current.push(value);
		}
	},
	assignProp: function(mod, prop, value){
		// again, set can be mocked as an obj, so don't check it as a fn
		if (value && value.set && value.set.assignTo){
			// this.log(this.log.label(value)+ ".set.assignTo()");
			value.set.assignTo(value, mod, prop);
		} else {
			// this.log(this.log.label(mod)+ "." + prop + " =", value);
			mod[prop] = value;
		}
	},
	// this is defined/called on the sub's .set, not the parent
	// leaving this undef until its needed is a little faster
	// assignTo: function(sub, parent, name){
	// 	parent[name] = sub; // ORP
	// },
	// this is useful for resorting back to assign within a set({})
	fnProp: function(mod, prop, value){
		if (is.fn(value)){
			this.assignProp(mod, prop, value);
		} else {
			if (is.arr(value))
				mod[prop].apply(mod, value);
			else
				mod[prop].call(mod, value);
		}
	},
	// for obj props without .set... (usually a pojo, but not necessarily)
	objProp: function(mod, prop, value){
		if (is.obj(value)){
			if (mod.hasOwnProperty(prop))
				this.obj(mod[prop], value)
			else
				this.assignProp(mod, prop, this.obj(Object.create(mod[prop]), value));
		} else {
			console.warn("whoops");
		}
	},
	value: function(value){
		// ctx here will be the mod
		// a slight deviation from the norm, but I think it makes sense
		console.warn("not sure how to set this");
	},
	// consider extending Set, and overriding this method for Class.set, in order to prevent extra logic every time for non classes
	override: function(sub, value, parent, name){
		if (is.Class(sub) && is.Class(value)){
			parent.set.mfn.assignProp(parent, name, value);
			return true;
		} else if (value instanceof sub.constructor){
			parent.set.mfn.assignProp(parent, name, value);
			return true;
		} else {
			return false;
		}
	},
	// can be overridden for Classes, and other situations
	protect: function(sub, value, parent, name){
		if (is.Class(sub)){
		
			if (parent.hasOwnProperty(name))
				sub.prototype.set(value);
			else
				parent.set.mfn.assignProp(parent, name, sub.extend(value));

			return true;

		} else if (!parent.hasOwnProperty(name) && sub.clone){
		
			if (sub.parent !== parent.proto) 
				console.warn("Consider only auto cloning direct children", parent.name, name);
		
			parent.set.mfn.assignProp(parent, name, sub.clone(value));
			
			return true;
		
		}

		return false;
	},
	// parent[name] === sub, incoming value
	sub: function(sub, value, parent, name){
		if (this.override(sub, value, parent, name))
			return;

		else if (this.protect(sub, value, parent, name))
			return;

		else
			this.arg(sub, value);
	},
	mockSetSub: function(wrapper, newValue, parent, propName){
		if (is.fn(newValue)){
			if (newValue.mfn)
				console.error("override with the mfn object itself, not the mfn.wrapper.");
			else {
				// plain old fn
					
			}
		}
		// override
		if (newValue instanceof Mfn){
			console.info("overridding mfn");
			// even though this probably goes straight to newValue.set.assignTo, we'll give the parent a chance to instrument or whatever
			parent.set.assignProp(parent, propName, newValue);
		
		// protect?
		} else if (is.pojo(newValue)){
			if (parent.hasOwnProperty(propName)){ // maybe this is ok
				console.warn("Is this safe?  Are you sure the mfn is unique to this object?");
				wrapper.mfn.assign(newValue);
			} else { // protect.
				wrapper.mfn.clone(newValue).set.assignTo(parent, propName);
			}
		}
	}
});

// In the Mfn.makeWrapper_:
// this.wrapper.set = MfnWrapperSet().wrapper
// which is unlikely to ever be called directly (mod.mfnWrapper.set(...))
// but is likely to be called via the mod:
// mod.set({ mfnWrapper: <any> });
// and in that case, 
var MfnWrapperSet = Set2.extend({
	// sub is the module that .assignTo was called on, via sub.set.assignTo
	// in this case, it would be the mfnWrapperSet instance
	// and this would only be called if we use 'set' to assign this, which won't happen
	// assignTo: function(sub, parent, name){}

	// sub: function(mod?, value, parent, name){}

	// in this case, the mod is the wrapper
	override: function(wrapperFn, value, parent, name){
		if (!(wrapperFn.mfn)
	}


	// we need the mfn.wrapper.set to potentially override/protect
	// for .set<wrapper>.set, which will be an extension of MfnWrapperSet, specifically SetWrapperSet, we'll do that little... jostling

});

// let's add .set to the Set2.prototype
// this is a little different...
var MfnSet = Set2.extend({
	/*
	Mod({
		set: function(value){
			//...
		}
	})

	This will only take effect if we use
		- SetX().set(function(){})
		- mod.set({
			set: function(){}
		})
		- Mod({ set: fn })

	BUT, it should be routed through set.sub, then check override, protect, 

	*/

	// sub is the mfn instance
	// this is the mfnSet instance
	// confused?  yea, me too
	assignTo: function(sub, parent, name){
		sub.wrap(parent, name);
	},

	// sub should be the current setMfn instance
	// value is the incoming value, could be anything
	// parent is the host of the setMfn's .wrapper, I think
	// name should always be "set", unless you had alternative .set algorithms
	override: function(sub, value, parent, name){
		if (!(sub.mfn instanceof Mfn))
			console.error("this should only be invoked for Mfns!");

		// we can assume parent.set.mfn.assignProp exists, because the only way we get to set.sub --> set.override is via a parent with set.mfn
			// yet, this is a very loose dep, and would be easy to break

		if (is.fn(value)){
			if (value.mfn){
				console.error("This probably shouldn't happen - we should just pass the mfn instance, not the .wrapper...");
				// console.info("overriding mfn with mfn");
				// 										// the mfn should have .set.assignTo?
				// if (!value.mfn.set.assignTo)
				// 	console.error("mfn should have assignTo for the .wrapper handoff");
				parent.set.mfn.assignProp(parent, name, value);
				return true;
			} else {
				// we're going to handle this case momentarily
				return false;
			}
		} else if (value instanceof Mfn){
			// { existingMfn: new Mfn() } could only mean override
			parent.set.mfn.assignProp(parent, name, value);
			return true;
		}

		return false;
	},
	// sub is the current wrapper
	protect: function(sub, value, parent, name){
		if (!(sub.mfn instanceof Mfn))
			console.error("this should only be invoked for Mfns!");
		
		if (parent.hasOwnProperty(name)){
			console.warn("this should be safe, as long as you didn't share a copy of this mfn with anyone...");
			sub.prototype.
		}
		if (is.Class(sub)){
		
			if (parent.hasOwnProperty(name))
				sub.prototype.set(value);
			else
				parent.set.mfn.assignProp(parent, name, sub.extend(value));

			return true;

		} else if (!parent.hasOwnProperty(name) && sub.clone){
		
			if (sub.parent !== parent.proto) 
				console.warn("Consider only auto cloning direct children", parent.name, name);
		
			parent.set.mfn.assignProp(parent, name, sub.clone(value));
			
			return true;
		
		}

		return false;
	},
	other: function(setMfn, arg){
		if (is.fn(arg)){
			setMfn.value = arg;
		} else {
			this.value.call(setMfn, arg);
		}
	}
});

// Set2.set = Set3().wrapper; // do we need this?
Mfn.prototype.set = MfnSet().wrapper;


/* MONKEY PATCH 
I want all Mfns, including this one, to have its own .set, without having to make a second version of set that adds itself...
*/
Mfn.prototype.settable = true;
Mfn.prototype.makeWrapper_ = function(){
	this.wrapper.mfn = this;

	if (this.settable){
		// how do we ensure we get to the right place?
		// .set will be the .wrapper, which has the set.sub "API" method.  When we use parent.set({ mfn: <any> }) --> propWithSet --> set.sub(sub, value, parent, name) gets called with sub as the .wrapper 
		this.wrapper.set = MfnSet().wrapper;
	}
};


// What we really need is a MfnWrapperSet, that looks at everything properly