var Mod1 = require("mod42/Mod1");
var is = require("util42").is;
var shared = require("../shared");

var History = require("history").createBrowserHistory;

var Route6 = Mod1.extend({
	name: "Route6",
	init: function(){
		this.cbs = [];
		this.routes = [];
	},
	set: {
		other: function(route, value){
			if (is.str(value)){
				route.set_path(value);
			} else {
				console.warn("not sure what to do here");
			}
		}
	},
	set_parent: function(parent, name){
		if (parent instanceof Route6){
			if (this.hasOwnProperty("parent"))
				console.warn("override route.parent?");

			parent.routes.push(this);

			this.parent = parent;
			this.router = parent.router;
			this.makeFullPath();
		}

		if (name && !this.hasOwnProperty("name")){
			this.name = name;
		}
	},
	makeFullPath: function(){
		if (this.part){	
			if (this.parent){
				this.parts = this.parent.parts.slice(0)
			} else {
				this.parts = [];
			}

			this.parts.push(this.part);

			this.path = "/" + this.parts.join("/") + "/";
			return this.path;
		}
	},
	set_path: function(path){
		if (path.indexOf("/") > -1){
			console.warn("bridging needed");
		} else {
			this.part = path;
			this.name = this.part;
			this.makeFullPath();
		}
	},
	each: function(fn){
		var ret;
		for (var i = 0; i < this.routes.length; i++){
			ret = fn.call(this, this.routes[i], i);
			if (ret) // return truthy breaks the loop, falsey continues
				return ret;
		}
	},
	match: function(parts){
		if (parts[0] === this.part){
			return this.matchChildren(parts.slice(1));
		} else {
			return false;
		}
	},
	matchChildren: function(parts){
		var childMatch;
		if (parts.length){
			childMatch = this.each(function(route){
				// console.log("child:", route);
				// truthy breaks loop, falsey continues search
				return route.match(parts);
			});
		}

		return childMatch || {
			route: this,
			remainder: parts
		};
	},
	bridge: function(parts){
		var next = this;
		for (var i = 0; i < parts.length; i++){
			next = next.add(parts[i]);
		}
		return next;
	},
	add: function(route){
		// get the parts
		var path = is.str(route) ? route : route.path;
		var parts = shared.parts(path);

		// find the appropriate parent
		// could be this, an existing child, or it might not exist yet
		var parent;

		// search for an existing child
		var match = this.matchChildren(parts);

		if (match){
			// exact match was found 
			if (!match.remainder.length){
				console.warn("attempting to re-add an existing route");
				return match.route;
			
			// a partial match
			} else {
				// even if only 1 remainder, parent becomes the match.route (bridge loops through an empty array, and returns self)
				parent = match.route.bridge(match.remainder.slice(0, -1));
			}
		} else {
			// again, even if parts.length is 1, this should still work
			parent = this.bridge(parts.slice(0, -1));
		}

		// set a potential long/path to just the last path part
		path = parts[parts.length - 1];

		// fix the arguments to convert long/path to the single path part
		if (is.str(route)){
			route = path;
		} else {
			route.path = path;
		}

		// create the new route, using the correct parent
		var args = [].slice.call(arguments, 0);
		
		args.unshift({
			parent: parent
		});

		route = Route6.apply(null, args);

		return route;
	},
	push: function(){
		if (window.location.pathname === this.path){
			// debugger;
			console.warn("path matches, no need to push");
		} else {
			this.router.listen = false;
			this.router.history.push(this.path);
			this.router.listen = true;
		}
	},
	activate: function(){
		this.push();
		this.exec();
	},
	exec: function(){
		var route = this;
		this.cbs.forEach(function(cb){
			cb.call(this);
		});
	},
	then: function(cb){
		this.cbs.push(cb);
		return this;
	},
	logger: function(){
		console.group(this.part);
		this.each(function(route){
			route.logger();
		});
		console.groupEnd();
	}
});

var Router6 = module.exports = Route6.extend({
	name: "Router6",
	listen: true,
	// needs to come before path
	set_path: function(path){
		this.path = path;
		this.parts = shared.parts(this.path);
		this.part = this.parts[this.parts.length - 1];
	},
	path: "/",
	init: function(){
		this.router = this;
		this.cbs = [];
		this.routes = [];

		this.history = History();
		this.history.listen(this.listener.bind(this));
	},
	listener: function(location, action){
		// toggled by routes, to skip when the action originates from ourselves
		if (this.listen){
			this.matchAndActivate();
		}
	},
	getCurrentURLPathParts: function(){
		// an attempt to make the router work when dropped on any given relative page
		return shared.parts(window.location.pathname.replace(this.path, ""));
	},
	matchAndActivate: function(){
		var match = this.match(this.getCurrentURLPathParts());
		if (match){
			match.route.remainder = match.remainder;
			match.route.activate();
		}
		return this;
	},
	match: function(parts){
		return this.matchChildren(parts);
	}
});