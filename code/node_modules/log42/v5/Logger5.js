var getLogBase = require("./getLogBase");
var Base = require("base42/v1");
var Base2 = require("base42/v2");
var is = require("util42/is");
var Flog = require("./Flog5");
var Method = require("method42/v9");
var set = require("set42/setfn1");

var FNOOP = function(){
	return function(){};
};

var currentMethod = {
	currentMethod: undefined,
	previousMethods: [],
	set: function(method){
		// console.log("previousMethod", this.currentMethod.context && this.currentMethod.context.id,this.currentMethod.methodName);
		method.parentMethod = this.currentMethod;
		this.previousMethods.push(this.currentMethod);
		this.currentMethod = method;
	},
	restore: function(){
		this.currentMethod = this.previousMethods.pop();
	}
};

var Logger = module.exports = Base2.extend({
	createConstructor: function(){
		return function Logger(){
			this.instantiate.apply(this, arguments);
		}
	},
	currentMethod: currentMethod,
	method: {},
	methods: new Method({
		isMethodsDefault: true
	}),
	set: set,
	FNOOP: FNOOP,
	Flog: Flog,
	previewLength: 9,
	instantiate: function(){
		this.set.apply(this, arguments);

		// Method.set relies on looking up defaults from method.logger.methods.whatever, which means methods should have the proper .logger reference immediately (before .instantiate())

		// we may or may not have extended/cloned .methods via the .set.apply(args) above
		if (!this.hasOwnProperty("methods"))
			this.methods = this.methods.clone();

		// all method instances clone from this.methods, and are unique to this (their .logger)
		// by adding a reference to this instance to this.methods, we inherit this reference in all method instances
		this.methods.logger = this;


		if (!this.log)
			this.set_log(false);
		else if (!this.hasOwnProperty("log"))
			this.set_log(this.log.isActive); // make sure we have our own log base



		this.initialize();
	},
	// creates a .log which is exported immediately
	initialize: function(){
		// build out the api, regardless of whether log.isActive
		this.initialize_api();
	},
	api: {
		safe: function(){
			// this could be an 'only execute if log is on' method, that safely NOOPs
			// good for performance (one NOOP)
			// good for complexity (don't need to keep the APIs in sync)
		},
		f: function(){
			return new this.logger.Flog({
				args: arguments,
				logger: this.logger,
			}).build();
		},
		fm: function(method){
			return new this.logger.Flog({
				args: [].slice.call(arguments, 1),
				method: method,
				logger: this.logger
			}).build();
		},
		s: function(str, style){
			return new this.logger.Flog({

			}).addStyled(str, style).build();
		},
		// value: function(value, name){
		// 	if (is.def(name)){
		// 		return this.f([name, "color: purple"], ":", value);
		// 	} else {
		// 		return this.f(value);
		// 	}
		// },
		obj: function(obj){
			var items = this.logger.previewLength;
			if (obj.constructor && obj.constructor.extend){
				return this.mod(obj);
			} else {
				var preview = this.f();
				var i = 0;
				if (items){
					for (var prop in obj){
						i++;
						if (i > 1)
							preview.f(", ");
						preview.f(this.var(obj[prop], prop));
					}
					// if (i < arr.length){
					// 	preview.f(" +" + arr.length);
					// }
				}
				return this.f(["{", "font-weight: bold !important; padding-right: 2px;"], preview, ["}", "font-weight: bold !important; padding-left: 2px;"]).all("border-bottom: 1px solid rgba(0,0,0,0.1); background: rgba(0,0,0,0.075);");
				// return this.s(obj.constructor.name != "Object" ? + " {" + Object.keys(obj).length + "}").all("background: #eee").build();
			}
		},
		mod: function(mod){
			// return this.s(mod.name + " ").s(mod.constructor.name, "color: #888").s(" {" + Object.keys(mod).length + "}").all("background: #eee").build();
			return this.f(mod.name, ["{" + mod.constructor.name + "#" + mod.id + "}", "font-style: italic; color: rgba(0,0,0,0.6)"]).all("background: rgba(0,0,0,0.075); border-bottom: 1px solid rgba(0,0,0,0.1); font-weight: normal;");
		},
		str: function(str){
			return this.s('"' + str + '"', "color: red;");
		},
		num: function(num){
			return this.s(num, "color: blue;");
		},
		bool: function(bool){
			return this.s(bool ? "true":"false", "color: purple;");
		},
		Class: function(cls){
			return this.s(cls.name + "<" + cls.id + ">", "font-weight: bold;");
		},
		fn: function(fn){
			return this.s( fn.name ? fn.name + "()" : "fn()", "color: #005200;");
		},
		var: function(value, name){
			if (name){
				return this._name(name).f(this.value(value))
					.all("background: rgba(0,0,0,0.075); border-bottom: 1px solid rgba(0,0,0,0.1);")
					.build();
			} else {
				return this.value(value);
			}
		},
		_name: function(name){
			return this.f([name + ": ", "color: purple; font-weight: normal;"]);
		},
		value: function(value, name){
			if (is.str(value))
				return this.str(value);
			else if (is.bool(value))
				return this.bool(value);
			else if (is.num(value))
				return this.num(value);
			else if (is.Class(value))
				return this.Class(value);
			else if (is.fn(value))
				return this.fn(value);
			else if (is.mod(value))
				return this.mod(value);
			else if (is.obj(value))
				return this.obj(value);
			else if (is.arr(value))
				return this.arr(value);
			else if (is.def(value))
				return this.f(value.toString());
			else
				return this.f(["undefined", "color: gray"]);
		},
		// sep: function(){
		// 	this.add(", ", "font-weight: normal;");
		// },
/*
Where do I put the obj and arr summarizing logic?
* It's basically just a max-length?

Can this be configured for each method arg?
this.log.arr(arr, 'strName', 3)

*/
		arr: function(arr, items){
			var preview = this.f();
			items = is.def(items) ? items : this.logger.previewLength;
			if (items){
				for (var i = 0; i < items; i++){
					if (i > arr.length - 1)
						break;
					if (i > 0)
						preview.f(", ");
					preview.f(this.value(arr[i]));
				}
				if (i < arr.length){
					preview.f(" +" + arr.length);
				}
			} else {
				preview.f(arr.length);
			}
			return this.f("[", preview, "]");
		},
		// values: function(values, names){
		// 	if (names && names.length){
		// 		for (var i = 0; i < names.length; i++){
		// 			this.var(values[i], names[i]);
		// 			if (i < names.length - 1)
		// 				this.sep();
		// 		}

		// 		if (i < values.length){
		// 			this.sep();
		// 			this.values(values.slice(i));
		// 		}
		// 	} else if (values && values.length){
		// 		for (var i = 0; i < values.length; i++){
		// 			this.var(values[i]);
		// 			if (i < values.length - 1)
		// 				this.sep();
		// 		}
		// 	}
		// },
		// obj: function(obj){
		// 	var bg = "background: #eee; border-bottom: 1px solid #ddd;";
		// 	var length = 0;
		// 	for (var i in obj) length++;
		// 	var keys = Object.keys(obj);
		// 	this.add(obj.constructor.name + " {", bg + "padding-left: 5px;");
		// 	for (var i = 0; i < keys.length; i++){
		// 		this._name(keys[i]);
		// 		this.appendStyle(bg);
		// 		this.value(obj[keys[i]]);
		// 		this.appendStyle(bg);
		// 		if (i < keys.length - 1){
		// 			this.add(", ", "font-weight: normal;" + bg);
		// 		}
		// 	}
		// 	this.add("}", bg + "padding-right: 5px");
		// },
		on: {
			both: function(bool, mod, fn){
				var last;

				if (!is.bool(bool)){
					fn = mod;
					mod = bool;
					bool = true;
				}

				if (bool){
					last = mod.log;
					mod.log = mod.log.active;
					fn.call(mod);
					mod.log = last;
				} else {
					fn.call(mod);
				}
			}
		},
		off: {
			both: function(bool, mod, fn){
				var last;

				if (!is.bool(bool)){
					fn = mod;
					mod = bool;
					bool = true;
				}

				if (bool){
					last = mod.log;
					mod.log = mod.log.noop;
					fn.call(mod);
					mod.log = last;
				} else {
					fn.call(mod);
				}
			}
		}
	},
	set_log: function(bool){
		this.log = getLogBase(bool);
		this.log.active.logger = this;
		this.log.noop.logger = this;
	},
	_set_value: function(value){
		if (is.bool(value))
			this.set_log(value);
		else
		console.info("implement .set_ fn --> .shouldLog, so you can conditionally turn it on.");

		/*
		Mod.extend({
			log: function(){
				// .shouldLog shortcut
			} || {
				shouldLog: function(){
					// when is this called?  Upon instantiation?
				}
			}
		});
		*/
	},
	// method has to be a pojo, so it can have ANY prop name
	set_method: function(pojo){
		if (!this.hasOwnProperty("method"))
			this.method = Object.create(this.method);

		for (var i in pojo){
			if (is.bool(pojo[i])){
				pojo[i] = { log: pojo[i] };
			}
			else if (is.str(pojo[i]))
				pojo[i] = { mode: pojo[i] };

			if (this.method[i]){
				if (this.method.hasOwnProperty(i))
					this.set.call(this.method[i], pojo[i]);
				else 
					this.method[i] = this.set.call(Object.create(this.method[i]), pojo[i]);
			} else {
				this.method[i] = pojo[i];
			}
		}
	},
	initialize_api: function(){
		for (var i in this.api){
			if (is.fn(this.api[i])){
				this.log.active[i] = this.api[i];
				this.log.noop[i] = FNOOP;
			} else if (is.pojo(this.api[i])){
				if (this.api[i].both){
					this.log.active[i] = this.log.noop[i] = this.api[i].both;
				} else if (this.api[i].active && this.api[i].noop){
					this.log.active[i] = this.api[i].active;
					this.log.noop[i] = this.api[i].noop;
				} else {
					console.error("wrong");
				}
			}
		}
	},
	excludes: ["log", "hasOwnProperty"],
	getProxy: function(mod){ // each method call, which creates a unique instance, can have its own reference to the created .proxy
			// in which case, it can't have a .proxy() getter.
			// so it's called .get_proxy()
			// maybe we name this .get_proxy() also, even though its not storing .proxy?
			// or call it getProxy(), which sort of makes that distinction
		var proxy;
		this.mod = mod;
		if (typeof Proxy !== "undefined"){
			this.views = this.views||[];
			if (this.app){
				
			var view = new ModView({mod: mod});
			this.views.push(view);

			this.app.adminPanel.contents.browse.append(view.el);
			}

			proxy = new Proxy(mod, {
				get: this.getter.bind(this),
				set: this.setter.bind(this)
			});

			this.proxy = proxy;
			// proxy[Symbol.for("isProxy")] = true;
			// proxy[Symbol.for("proxyTarget")] = mod;
			return proxy;
		} else {
			console.warn("Proxy is undefined.");
			return mod;
		}
	},
	update: function(){
		for (var i = 0; i < this.views.length; i++){
			this.views[i].update();
		}
	},
	setter: function(ctx, prop, value, rec){
		if (ctx !== this.mod)
			throw new Error("this shouldn't happen");
		if (rec !== this.proxy)
			throw new Error("Don't use Object.create() with proxied mods.  Use the .clone() method.");

		ctx[prop] = value;

		this.update();
		return true;
	},
	getter: function(ctx, prop, rec){
		var value = ctx[prop];

		// ctx seems to always be the target (non-proxy) and
		// rec seems to always be the proxy
		// console.group("logger.getter", prop);
		// ctx === this.proxy && console.count("ctx === logger.proxy");
		// ctx === this.mod && console.count("ctx === logger.mod");
		// rec === this.proxy && console.count("rec === logger.proxy");
		// rec === this.mod && console.count("rec === logger.mod");
		// console.groupEnd();

		if (ctx !== this.mod)
			throw new Error("this shouldn't happen");
		if (rec !== this.proxy)
			throw new Error("Don't use Object.create() with proxied mods.  Use the .clone() method.");
			// this only happens when we Object.create(proxy), which doesn't work properly

		if (prop === "_$_$_target")
			return this.mod;
		if (prop === "_$_$_proxy")
			return this.proxy;

		// .clone can't be called on the proxy (Object.create(proxy) is broken)
		// this ensures that we're cloning the underlying object
		if (is.fn(value) && prop === "clone")
			value = value.bind(ctx);

		if (is.fn(value) && prop[0] !== "_" && this.excludes.indexOf(prop) === -1){
			// console.log("method proxy:", prop);
			return this.methods.clone({
				context: this.proxy,
				fn: value,
				methodName: prop
			}).getProxy();
		} else {
			return value;
		}
	},
	// use this to construct this.log, and methods can use it to get a copy that they can customize
	build: function(){
		var log = console.log.bind(console);
		// add the standard fns 
		// and the custom api
		// also create the noop api for std and custom
		return log;
	},
	clone: function(){
		var clone = Object.create(this);
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
});