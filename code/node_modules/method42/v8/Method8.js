var Base2 = require("base42/v2");
var is = require("util42/is");
var View = require("view42/v1");

var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
var getParamNames = function(func) {
  func = func || function(){};
  var fnStr = func.toString().replace(STRIP_COMMENTS, '');
  var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
  return result || [];
};

var noop = function(){};
noop.noop = true;

var fnoop = function(){
	return noop;
};

fnoop.noop = true;


var container, lastContainers = [];


var MethodView = View.extend({
	name: "MethodView",
	render: function(){
		var methodView = this;
		var method = this.method;
		var mod = method.context;
		var methodName = method.methodName;
		var method = method.fn;

		this.append({
			label: View(mod.name + "-" + mod.constructor.name + "." + methodName + "(...)"),
			contents: View()
		});

		this.addClass("method8");

		this.label.el.addEventListener("click", function(){
			// console.log("clicked");
			this.contents.toggle();
		}.bind(this));
	}
});


var Method = module.exports = Base2.extend({
	constructor: function Method(){
		this.instantiate.apply(this, arguments);
	},
	logMethod: "group",
	fnoop: fnoop,
	set_: function(value){
		if (is.bool(value)){
			this.set_log(value);
		}
	},
	set_group: function(value){
		if (is.bool(value)){
			// this is cloned from logger.methods default instance, so we should be able to reliably default back?
			// ugh - but what if methods.group --> noop, and then we want to turn it back on for this method[name]?
			// ok, we could check if methods.group == .fnoop...
			/*

			methods: { group: false --> fnoop }
			method[name]: { group: true --> use the default Methods.prototype.group }

			methods: { group: fn } (it's assumed the override will open a group...)
			method[name]: { group is already 'true', false sets it to fnoop.. }

			*/ 

			// group: true
			if (value){

				if (this.group === this.fnoop){
					// methods: { group: false --> fnoop }
					// +
					// method[name]: { group: true --> use the default Methods.prototype.group }
					if (this.logger.methods.group === this.fnoop){
						// resort back to the default class definition
						this.group = Method.prototype.group;
					} else {
						console.info("hmm");
						// falls back to the default method, rather than the class definition
						// not really sure about this use case
						this.group = this.logger.methods.group;
					}

					if (this.close === this.fnoop){
						if (this.logger.methods.close === this.fnoop)
							this.close = Method.prototype.close;
						else
							this.close = this.logger.methods.close;
					} else {
						console.error("whoops - .group and .close should stay in sync");
					}
				} else {
					// if group isn't currently fnooping, then setting to true should just leave it alone
					console.info("whoops");
				}

			// group: false
			} else {
				// fnoop early and often >D
				this.group = this.fnoop;
				this.close = this.fnoop;
			}
		} else if (is.fn(value)){
			this.group = value;
			this.set_close(true); // will turn itself on, if fnoop, and do nothing if already 'on'..
		}
	},
	set_close: function(value){
		if (is.bool(value)){
			if (value){
				this.reset("close");
			} else {
				this.close = this.fnoop;
			}
		} else if (is.fn(value)){
			this.close = value;
		} else {
			console.warn("huh?");
		}
	},
	set_expand: function(value){
		if (is.bool(value)){
			if (value) this.logMethod = "group";
			else this.logMethod = "groupCollapsed";
		} else {
			console.info("whoops, implement expand: fn --> shouldExpand()?");
		}
	},
	/*
	 * Sets .return => .inline, or this new fn
	 */
	set_inline: function(value){
		if (is.bool(value)){
			if (value){
				this.set_group(false);
				this.return = this.inline;
				if (!this.hasOWnProperty("logMethod"))
					this.logMethod = "log";
					
			} else {
				console.error("don't use inline: false?")
				this.set_group(true);
				this.set_return(true);
			}
		} else if (is.fn(value)){
			this.set_group(false);
			this.return = value;
		}
	},
	inline: function(){
		this.log.f(this.method(), "=>", this.returnValue);
	},
	set_return: function(value){
		if (is.bool(value)){
			if (value){
				// can't really 'reset' if methods.inline
					// that would require also .set_group(false)...
				this.reset("return");
			} else {
				this.return = this.fnoop;
			}
		} else if (value === "inline"){
			this.set_inline(true);
		} else if (is.fn(value)){
			this.return = value;
		}
	},
	set_args: function(value){
		if (is.bool(value)){
			if (value){
				this.reset("args");
			} else {
				this.args = this.fnoop;
			}
		} else if (is.fn(value)){
			this.args = value;
		}
	},
	set_ctx: function(value){
		if (is.bool(value)){
			// ctx: true
			if (value){
				this.reset("ctx");
			} else {
				this.ctx = this.fnoop;
			}
		} else if (is.fn(value)){
			this.ctx = value;
		}
	},
	reset: function(prop){
		if (this[prop] === this.fnoop){
			if (this.logger.methods[prop] === this.fnoop)
				this[prop] = Method.prototype[prop];
			else
				this[prop] = this.logger.methods[prop];
		} else {
			console.info("i think we want to just leave it alone here");
		}
	},
	set_log: function(value){
		// console.info("Method.set_log", value);
		if (is.bool(value)){
			if (value) this.log = this.logger.log.active;
			else this.log = this.logger.log.noop;

			this.shouldLog = function(){
				return this.log.isActive;
			};
		} else if (is.fn(value)){
			this.shouldLog = value;
		}
	},
	instantiate: function(o){
		this.set.apply(this, arguments);
		this.instantiate_settings();
		this.instantiate_log();
		this.initialize();
	},
	initialize: function(){
		this.argNames = getParamNames(this.fn);
	},
	instantiate_settings: function(){
		if (this.logger && this.logger.method[this.methodName]){
			// console.log("method settings for " + this.methodName, this.logger.method[this.methodName]);
			this.set(this.logger.method[this.methodName]);
		}

	},
	instantiate_log: function(){
		// so, methods will have the .logger reference, eventually, but in the .method instances, its not hasOwn
		// maybe there's a better way to setup the default .log?
			// maybe we don't set it up until exec time, and set it to the context's .log
		if (!this.hasOwnProperty("log") && this.logger) 
			this.set_log(true);
	},
	exec: function(fn, ctx, args){
		this.before.apply(this, arguments);

		// debug here
		this.returnValue = fn.apply(ctx, args);

		this.after();
		return this.returnValue;
	},
	before: function(fn, context, args){
		if (fn !== this.fn) console.error("fn mismatch");

		// if (context._$_$_isTarget)
		// 	debugger;
		if (context !== this.logger.proxy)
			console.warn("hmm");

		// if (!this.log.isActive)
		// 	console.error("implement squelching");
		// !! if !this.log.isActive, squelch
			// 1) don't log anything - the log methods on this object have .flog chaining, and so they can't run if !log.isActive
			// 2) set the ctx.log = ctx.log.noop;
			// 3) restore the ctx.log in .after();


		this.context = context;
		this.arguments = args;


		if (this.return !== "inline"){
			if (this.expand === false)
				this.logMethod = "groupCollapsed";
			else 
				this.logMethod = "group";
			
			// hmm, this conditional check might not be necessary with the .fnoop pattern..
			if (this.shouldLog()){
				this.group();
				if (this.group !== this.fnoop)
					this.opened = true;
			}
		}
	},
	group: function(){
		this.log.fm(this.logMethod, this.ctx(), this.method())();

		if (this.logger.app){
			
		var view = new MethodView({ method: this });

		if (!container)
			this.logger.app.adminPanel.contents.log.append(view.el);
		else
			container.appendChild(view.el);

		lastContainers.push(container);
		container = view.contents.el;
		}
	},
	ctx: function(){
		return this.log.f(
			// ["i", "font-weight: bold"],
			// " ", 
			[" " + this.context.name, "font-weight: normal"],
			["{"+this.context.constructor.name+"} ", "font-style: italic; color: #666"]
		).all("background: #eee; padding: 2px 0px;");
	},
	method: function(){
		return this.log.f(".", this.name(), "(", this.args(), ");").all("font-weight: normal");
	},
	args: function(){
		var flog = this.log.f();
		// debugger;
		for (var i = 0; i < this.arguments.length; i++){
			// if (this.arg[])
			// if (this.argNames[i])

				flog.f(this.arg(this.arguments[i], this.argNames[i]));
			
			if (i < this.arguments.length - 1)
				flog.f(",");
		}
		return flog.build();

		// if this.argNames[i] && this.arg[this.argNames[i]]
			// then use that ()
		// else, use the default .arg(value [, name])
	},
	arg: function(value, name){
		return this.log.var(value, name);
	},
	name: function(){
		return this.methodName;
	},
	inline: function(){
		return this.method().s("=>")
	},
	after: function(){
		if (this.opened){
			this.log.end();

			container = lastContainers.pop();
		}
	},
	// method doesn't do anything w/o proxy...
	// setting methodName: false could mean proxy && squelch...
	getProxy: function(){
		if (!this.fn)
			console.error("must provide fn to proxy");

		/* Check ctx.log.logger.method.name  */

		if (!this.context.log.isActive && !this.log.isActive){
			// console.warn("huh?", this.ctx.log.isActive, this.log.isActive);
			// when log: { method: { name: false }}, then method.set_log(false)...
			// we can't squelch, then...
			return this.fn;
		} else if (this.context.log.isActive && !this.log.isActive){
			return this.fn;
			this.squelch = true;
		} else if (!this.context.log.isActive && this.log.isActive){
			console.warn("implement this");
			this.amplify = true;
		}

		this.proxy = new Proxy(this.fn, {
			apply: this.exec.bind(this)
		});

		return this.proxy;
	}
});