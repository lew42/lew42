var is = require("./is");
var utils = module.exports = {
	is: is,
	hashCode: function(str){
		var hash = 0, char, one, two, three, four;
		if (str.length == 0) return hash;
		for (i = 0; i < str.length; i++) {
			char = str.charCodeAt(i);
			one = hash << 5;
			two = one - hash;
			three = two + char;
			hash = ((hash<<5)-hash)+char;
			hash = hash & hash;
		}
		return hash;
	},
	binarytoString: function(str) {
		return str.split(/\s/).map(function (val){
			return String.fromCharCode(parseInt(val, 2));
		}).join("");
	},
	numToChar: function(num){
		// any number, float, etc --> take the last 2 digits as a number 00-99
		num = parseInt( (num + "").replace(".", "").substr(-2) );

		// convert to a number 1-62
		var code = Math.floor(num * 62 / 100) || 1;

		if (code < 1 || code > 62){
			console.error("whoops");
		}

		// 1-26
		if (code <= 26){
			return String.fromCharCode(code + 64); // --> 65-90, A-Z
		
		// 27-36 ==> 48-57
		} else if (code >= 27 && code <= 36){
			return String.fromCharCode(code + 21);
		
		// 37-62 ==> 97-122
		} else if (code >= 37 && code <= 62){
			return String.fromCharCode(code + 60)
		}
	},
	stringToCrazyNumber: function(str){
		if (str.length > 2000){
			console.warn("too big");
		}
		var code = str.charCodeAt(0),
			result = str.length * str.length + str.length;

		result += Math.sqrt(code * code + code);

		for (var i = 1; i < str.length; i++){
			code = str.charCodeAt(i);
			result += Math.sqrt(code * code + code); 
		}

		return parseInt(("" + result).replace(".", "").substr(0, 16));
	},
	hash: function(str){
		var code = utils.stringToCrazyNumber(str) + "";
		return utils.numToChar(code[0] + "" + code[15]) +
			   utils.numToChar(code[1] + "" + code[14]) +
			   utils.numToChar(code[2] + "" + code[13]) +
			   utils.numToChar(code[3] + "" + code[12]) +
			   utils.numToChar(code[4] + "" + code[11]);
	},
	sanitizeString: function(str){
		// remove anything but A-Z, a-z, 0-9, and maybe the dash: 45
		var result = "", char, code;
		for (var i = 0; i < str.length; i++){
			char = str[i];
			code = char.charCodeAt();
			if (code === 45 || code === 32){ // the dash: -
				if (result[result.length-1] !== "-")
					result += "-"; // convert spaces to dashes, also
			} else if (code >= 48 && code <= 57){ // 0-9
				result += char;
			} else if (code >= 65 && code <= 90){ // A-Z
				result += char.toLowerCase();
			} else if (code >= 97 && code <= 122){ // a-z
				result += char;
			}
		}
		return result;
	}
};

var sMST = require("logger/src/sourcemapped-stacktrace");

utils.getBacktrace = function(){
	// console.group('backtrace');
	var stack =
		((new Error).stack + '\n');

		// console.log('getBacktrace');
		// console.log(stack);
		sMST.mapStackTrace(stack, function(newStack){
			// console.log(newStack.join("\n"));
			stack = newStack.join("\n").replace(new RegExp("webpack:///", "g"), "webpack:///./");
			// console.log(stack);
		});

		stack = stack.replace(/^\s+(at eval )?at\s+/gm, '');
		// console.log(stack);

		stack = stack.replace(/^([^\(]+?)([\n$])/gm, '{anonymous}() ($1)$2');
		// console.log(stack);

		stack =	stack.replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}() ($1)');
		// console.log(stack);

		stack = stack.replace(/^(.+) \((.+)\)$/gm, '$1```$2');
		// console.log(stack);

		stack = stack.split('\n');
		// console.log(stack);

		stack = stack.slice(1, -1);
		// console.log(stack);

	var backtrace = [];

	for (var i in stack){
		stack[i] = stack[i].split('```');
		var bt = {
			func: stack[i][0],
			fullPathAndLine: stack[i][1],

		};
// 
		// console.log(bt);
		var lineAndPos = stack[i][1].match(/:\d+:\d+$/);
		if (lineAndPos && lineAndPos[0])
			lineAndPos = lineAndPos[0].split(":");
		var url = stack[i][1].replace(/:\d+:\d+$/, "");
		// console.log(url, lineAndPos);

		var pathBreakdown = stack[i][1].split(':');
		// console.log(pathBreakdown);
		bt.file = url.replace(/^.*[\\\/]/, '');
		bt.line = lineAndPos && lineAndPos[1];
		bt.linePos = lineAndPos && lineAndPos[2];
		// console.log(bt.file, bt.line, bt.linePos);
		backtrace.push(bt);
	}
// console.log(backtrace);
// console.groupEnd();
	return backtrace; //.slice(3);
};

var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
exports.getParamNames = function(func) {
  var fnStr = func.toString().replace(STRIP_COMMENTS, '');
  var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
  if(result === null)
     result = [];
  return result;
}