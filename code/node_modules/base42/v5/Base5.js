var is = require("util42/is");
var Base4 = require("../v4/");
var createMorphicConstructor = require("./createMorphicConstructor");
var Logger = require("log42/v2");
var logger = Logger();


var _Base = Base4.extend({
	name: "_Base5"
}).assign({
	createConstructor: createMorphicConstructor
});

var Method = _Base.extend({
	name: "Method93",
	suppress: function(){
		// still wrap, so we can turn mod.log off and then restore it
	},
	proxy: function(){
		if (!this.fn)
			console.error("must provide fn to proxy");

		if (!this.mod.log.on)
			return this.fn;

		if (is.def(this.settings)){
				// console.info("this.settings", this.settings)
			if (!this.settings){ // == false
				return this.fn; // noop or suppress?
			} else if (is.def(this.settings.log)) {
				if (!this.settings.log){ // == false
					return this.fn; // suppress?
				}
			}
		}
		const method = this;
		this._proxy = new Proxy(this.fn, {
			apply: this.exec.bind(this)
		})
		return this._proxy;
	},
	exec(target, it, args){
		this.before.apply(this, arguments);
		const ret = target.apply(it, args);
		this.after(target, it, args, ret);
		return ret;
	},
	before(target, it, args){
		// if !this.mod.log.on, should we suppress all?
		// if !this.settings.log, we should suppress this

		this.open(target, it, args);
	},
	open: function(target, it, args){
		// open the console.group
		var prop = this.prop;
		var logArgs = args.slice(0);
		logArgs = logArgs.map((arg) => {
			// console.log(arg);
			return is.fn(arg) ? "<fn>" : arg;
		});
		logArgs = this.prefix(target, it, prop).concat(logArgs).concat([")"]);
		if (this.settings && this.settings.expand){
			console.group.apply(console, logArgs);
		} else {
			console.groupCollapsed.apply(console, logArgs);
		}
	},
	after(target, it, args, ret){
		if (!this.settings || this.settings.ret !== false)
			console.log("return", ret);
		console.groupEnd();
	},
	prefix: function(target, it, prop){
		if (this.settings && this.settings.prefix)
			return this.prefixed(target, it, prop);
		else
			return [prop + "("];
	},
	prefixed: function(target, it, prop){
		return ["%c" + it.name + "{" + it.constructor.name + "-" + it.id + "}%c." + prop + "(", "font-weight: normal", "font-weight: bold"];
	}
});

/*
In order for .set({ log: { config } }) --> ._log..
We need to do this on the Mod that has .set, not the base.

The immediate problem I'm seeing, is that Mfn are only Base modules.

Can we modify the config... manually?
Can we use an external/standalone .set?

set(base, { log: {...} })
// ===
base.set({ log: {...} })
*/

var extend = function(base, ext){
	var arg, prop;
	for (var i = 1; i < arguments.length; i++){
		arg = arguments[i];
		for (var j in arg){
			prop = arg[j];
			if (is.obj(prop) && is.obj(base[i])){
				extend(Object.create(base[i]), prop);
			} else {
				base[i] = prop;
			}
		}
	}
	return base;
};
var Logged = _Base.extend({
	name: "Logged",
	Method: Method,
	excludes: ["log", "hasOwnProperty"],
	proxy: function(){
		var logged = this;
		var mod = this.mod;
		return new Proxy(mod, {
			get: this.getter.bind(this)
		})
	},
	getter: function(target, prop){
		var ret;
		// console.group(target, prop);
		if (target !== this.mod)
			console.error("target/mod mismatch");

		const value = target[prop];

		if (is.fn(value) && this.excludes.indexOf(prop) === -1){
			ret = new this.Method({
				mod: this.mod,
				fn: value,
				prop: prop,
				settings: target._log[prop]
			});
			ret = ret.proxy();
			// console.log('ret', ret);
			// console.groupEnd();
			return ret;
		} else {
			// console.log('value', value);
			// console.groupEnd();
			return value;
		}
	}
});

var Base = module.exports = _Base.extend({
	name: "Base5",
	log: logger.noop,
	set_log: logger.setter,
	Logged: Logged,
	_log: {
		set_log: false,
		log: false,
		initialize: {
			expand: true,
			ret: false
		},
		instantiate: {
			prefix: true,
			expand: true,
			ret: false
		}
	}, // holds the log config data
	config: function(o){
		this.constructor.track(this);
		this.config_name(o);
		this.config_log(o);
		return this.config_proxy();
	},
	config_proxy: function(){
		if (this.log.on){
			return new this.Logged({
				mod: this
			}).proxy();
		} else {
			return this;
		}
	},
	config_name: function(o){
		// o could be a fn that has a .name, or other module with .name
		// we only want pojo
		if (is.pojo(o) && is.def(o.name)){
			this.name = o.name;
			delete o.name;
		}
	},
	config_log: function(o){
		var logSettings;
		if (is.pojo(o) && is.def(o.log)){
			logSettings = o.log;
			delete o.log;
			this.set_log(logSettings);
		}
	},
	instantiate: function(){
		this.assign.apply(this, arguments);
		this.initialize && this.initialize.apply(this, arguments);
	},
	clone: function(){
		var clone = Object.create(this);
		clone = clone.config.apply(clone, arguments) || clone;

		// maybe restrict 'morphing' to proxy only
		// morphing to an instantiated object will then cause this to reinstantiate (eew)
		clone.instantiate && clone.instantiate.apply(clone, arguments);
		return clone;
	}
})


/*

function(mod){
		var logged = this;
		this.mod = mod;

		// cached proxies
		this.methods = {};

		var proxy = new Proxy(mod, {
			get(target, prop){
				const value = target[prop];
				if (is.fn(value)){
					// if (logged.methods[prop]){

					// 	if (logged.methods[prop].constructor !== target._log.Method){
					// 		console.warn("rebase");
					// 	}
					// 	if (target._log && is.def(target._log.methods[prop])){
					// 		if (target._log.methods[prop] === logged.methods[prop].settings){
					// 			// no settings have changed, use cached method
					// 			return logged.methods[prop];
					// 		} else {
					// 			return new logged.Method({
					// 				fn: value,
					// 				settings: target._log.methods[prop]
					// 			});			
					// 		}
					// 	}
					// }
					return new Proxy(value, {
						apply: function(target, it, args){
							var logArgs = args.slice(0);
							logArgs = logArgs.map((arg) => {
								return is.fn(arg) ? "<fn>" : arg;
							});
							console.groupCollapsed.apply(console, [prop +"("].concat(logArgs).concat([")"]));
							var ret = target.apply(it, args);
							console.log("return", ret);
							console.groupEnd();
							return ret;
						}
					})
				} else {
					// console.log(prop, value);
					return value;
				}
			}
		});
		return proxy;
	}

	*/