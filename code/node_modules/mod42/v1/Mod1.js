var Base = require("base42/v1");
var is = require("util42/is");

var set = require("set42/setfn1");

var Mod = module.exports = Base.extend({
	// createConstructor: function(){
	// 	return function Mod(){
	// 		this.instantiate.apply(this, arguments);
	// 	}
	// },
	// createConstructor: function(){
	// 	return function Mod(){
	// 		if (!(this instanceof Mod))
	// 			return new (Mod.bind.apply(Mod, [null].concat([].slice.call(arguments))));
	// 		var instance = this.__config.apply(this, arguments) || this;
	// 		instance.instantiate.apply(instance, arguments);
	// 		return instance;
	// 	};
	// },
	name: "Mod",
	createConstructor: function(o){
		var name = (o && o.name) || this.name + "Ext";
		o && delete o.name;
		eval("var " + name + ";");
		var constructor = eval("(" + name + " = function " + name + "(){\r\n\
		if (!(this instanceof " + name + "))\r\n\
			return new (" + name + ".bind.apply(" + name + ", [null].concat([].slice.call(arguments)) ));\r\n\
		var instance = this.__config.apply(this, arguments) || this;\r\n\
		instance.instantiate.apply(instance, arguments);\r\n\
		return instance;\r\n\
	});");
		return constructor;
	},
	__config: function(o){
		this.__config_log(o);
		return this.__config_proxy(o);
	},
	__config_log: function(o){
		if (is.pojo(o) && is.def(o.log)){
			this.log = this.log.logger.clone(o.log).log;
			delete o.log;
		}
	},
	__config_proxy: function(o){
		if (this.log.isActive){
			return this.log.logger.getProxy(this);
		} else {
			return this;
		}
	},
	instantiate: function(){
		this.set.apply(this, arguments);
		this.initialize.apply(this, arguments);
	},
	initialize: function(){},
	set: set,
	set_log: function(){
		this.log = this.log.logger.clone.apply(this.log.logger, arguments).log;
	},
	/*
	* Caveats to cloning:
	*  - properties can show through (live inheritance)
	*  - reinstantiating an object might be unpredictable - it depends on what kind of state your object has, and what happens in instantiate.  Also, if any external side effects.
	*/
	clone: function(){
		var clone = Object.create(this);
		clone = clone.__config.apply(clone, arguments) || clone;
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
}).assign({
	extend: function(o){
		var opts = {};

		// we need to configure the prototype, like we do for instances
		// we don't want the o.log property getting assigned to the prototype...
		// extract the o.log value before calling the Base1.extend
		if (is.pojo(o) && is.def(o.log)){
			opts.log = o.log;
			delete o.log;
		}
		
		// Base1.extend will assign all the args...
		// Ext = Base.extend.apply(this, arguments);
		var Ext = this.getConstructor(o);

		// Setup inheritance
		Ext.prototype = Object.create(this.prototype);
		Ext.prototype.constructor = Ext;
		Ext.prototype.name = Ext.name[0].toLowerCase() + Ext.name.substring(1);

		// Set all arguments to the new prototype
		Ext.prototype.set.apply(Ext.prototype, arguments);

		// now we can handle the .log config, mocking the original `o` with `opts`
		if (is.def(opts.log))
			Ext.prototype.__config_log(opts);

		return Ext;
	}
});


var Method = Base2.extend({
	constructor: function Method(){
		this.instantiate.apply(this, arguments);
	},
	set: set,
	set_: function(value){
		if (is.bool(value)){
			this.set_log(value);
		}
	},
	set_log: function(bool){
		// console.info("Method.set_log", bool);
		if (bool) this.log = this.logger.log.active;
		else this.log = this.logger.log.noop;
	},
	instantiate: function(o){
		this.set.apply(this, arguments);
		this.instantiate_settings();
		this.instantiate_log();
	},
	initialize: function(){
		this.argNames = getParamNames(this.fn);
	},
	instantiate_settings: function(){
		if (this.logger && this.logger.method[this.name])
			this.set(this.logger.method[this.name]);

	},
	instantiate_log: function(){
		// in case nobody has configured it, it'll be undefined as of this point
		// the default .methods instance is an edge case - it doesn't have a .logger - it doesn't need a .log (it'll never be used by itself)
		if (!this.hasOwnProperty("log") && this.logger) 
			this.set_log(true);
	},
	exec: function(fn, ctx, args){
		this.before.apply(this, arguments);

		// debug here
		this.returnValue = fn.apply(ctx, args);

		this.after();
		return this.returnValue;
	},
	before: function(fn, ctx, args){
		if (fn !== this.fn) console.error("fn mismatch");
		// if (ctx !== this.ctx) console.error("ctx mismatch");

		// console.log(ctx, this.ctx);

		this.ctx = ctx;
		this.arguments = args;


		if (this.return !== "inline"){
			if (this.expand === false)
				this.logMethod = "groupCollapsed";
			else 
				this.logMethod = "group";
			
			this.open();
			this.opened = true;
		}
	},
	open: function(){
		this.log.fm(this.logMethod, 
			this.log.obj(this.ctx),
			"." + this.name + "(",
			this.logArguments()
		)();
	},
	after: function(){
		if (this.opened)
			this.log.end();
	},
	logArguments: function(){
		var flogs = [];
		for (var i = 0; i < this.arguments.length; i++){
			flogs.push(this.log)
		}
		return this.log.f()
	},
	// method doesn't do anything w/o proxy...
	// setting methodName: false could mean proxy && squelch...
	getProxy: function(){
		if (!this.fn)
			console.error("must provide fn to proxy");

		if (!this.ctx.log.isActive || !this.log.isActive){
			// console.warn("huh?", this.ctx.log.isActive, this.log.isActive);
			// when log: { method: { name: false }}, then method.set_log(false)...
			// we can't squelch, then...
			return this.fn;
		}

		this.proxy = new Proxy(this.fn, {
			apply: this.exec.bind(this)
		});

		return this.proxy;
	}
});



var Flog = Base.extend({
	method: "log",
	stylesForAll: "",
	constructor: function Flog(){
		this.instantiate.apply(this, arguments);
	},
	instantiate: function(){
		this.assign.apply(this, arguments);

		if (is.pojo(this.args[0])){
			this.assign(this.args[0]);
			this.args = [].slice.call(this.args, 1);
		}

		this.build();
	},
	add: function(){
		var arg;
		// add any value, or a BLF w/ .flog
		for (var i = 0; i < arguments.length; i++){
			arg = arguments[i];
			if (is.fn(arg) && arg.flog)
				this.addFlog(arg.flog);
			else
				this.addUnstyled(arg);
		}

		return this; // important
	},
	addUnstyled: function(){
		// there cannot be any styled args AFTER the unstyled...
		// must be tracked (stored) in the same 'args' array, or whatever
	},
	addStyled: function(str, style){
		if (this.sealed){
			console.error("You cannot add styled log arguments after an unstyled log argument as been added.")
		}
		// used by .log.s()
		this.str += "%c" + str;
		this.styled.push(style + ";" + this.stylesForAll + ";");
		return this; // important
	},
	api: {
		add: function(){
			return this.flog.add.apply(this.flog, arguments);
		},
		s: function(str, style){
			return this.flog.addStyled(str, style);
		},
		all: function(style){
			return this.flog.appendStyleToAll(style);
		}
	},
	appendStyleToAll: function(style){
		for (var i = 0; i < this.styles.length; i++){
			this.styles[i] = this.styles[i] + ";" + style + ";";
		}
	},
	build: function(){
		this.str = "";
		this.styles = [];
		
		for (var i = 0; i < this.args.length; i++)
			this.buildArg(this.args[i]);

		this.log = console[this.method].bind.apply(console[this.method], [console].concat([this.str], this.styles));
		this.log.flog = this;

		this.buildAPI();

		return this.log;
	},
	buildAPI: function(){
		for (var i in this.api){
			this.log[i] = this.api[i]; 
		}
	},
	buildArg: function(arg){
		var styles;
		if (is.str(arg)){
			this.str += "%c" + arg;
			this.styles.push(this.all);
		} else if (is.arr(arg)){
			this.str += "%c" + arg[0];
			this.styles.push(arg[1] + ";" + this.all);
		} else if (is.fn(arg) && arg.flog){
			this.str += arg.flog.str;
			styles = arg.flog.styles.slice(0).map(function(style){
				return style + ";" + this.all; 
			}.bind(this));
			this.styles = this.styles.concat(styles);
		}
	}
});



var FNOOP = function(){
	return NOOP;
}

var Logger = Base2.extend({
	createConstructor: function(){
		return function Logger(){
			this.instantiate.apply(this, arguments);
		}
	},
	set: set,
	FNOOP: FNOOP,
	Flog: Flog,
	instantiate: function(){
		this.set.apply(this, arguments);
		this.initialize();
	},
	api: {
		f: function(){
			return new this.logger.Flog({
				args: arguments
			}).log;
		},
		fm: function(method){
			return new this.logger.Flog({
				args: [].slice.call(arguments, 1),
				method: method
			}).log;
		},
		s: function(str, style){
			return new this.logger.Flog().addStyled(str, style).build();
		},
		on: {
			both: function(bool, mod, fn){
				var last;

				if (!is.bool(bool)){
					fn = mod;
					mod = bool;
					bool = true;
				}

				if (bool){
					last = mod.log;
					mod.log = mod.log.active;
					fn.call(mod);
					mod.log = last;
				} else {
					fn.call(mod);
				}
			}
		},
		off: {
			both: function(bool, mod, fn){
				var last;

				if (!is.bool(bool)){
					fn = mod;
					mod = bool;
					bool = true;
				}

				if (bool){
					last = mod.log;
					mod.log = mod.log.noop;
					fn.call(mod);
					mod.log = last;
				} else {
					fn.call(mod);
				}
			}
		}
	},
	method: {},
	methods: new Method(),
	set_log: function(bool){
		this.log = getLogBase(bool);
		this.log.active.logger = this;
		this.log.noop.logger = this;
	},
	set_: function(value){
		if (is.bool(value))
			this.set_log(value);
	},
	// method has to be a pojo, so it can have ANY prop name
	set_method: function(pojo){
		if (!this.hasOwnProperty("method"))
			this.method = Object.create(this.method);

		for (var i in pojo){
			if (is.bool(pojo[i]))
				pojo[i] = { log: pojo[i] };
			else if (is.str(pojo[i]))
				pojo[i] = { mode: pojo[i] };

			if (this.method[i]){
				if (this.method.hasOwnProperty(i))
					this.set.call(this.method[i], pojo[i]);
				else 
					this.method[i] = this.set.call(Object.create(this.method[i]), pojo[i]);
			} else {
				this.method[i] = pojo[i];
			}
		}
	},
	// creates a .log which is exported immediately
	initialize: function(){
		this.initialize_std();
		// build out the api, regardless of whether log.isActive
		this.initialize_api();
	},
	initialize_std: function(){
		this.log.active.obj = this.obj;
		this.log.noop.obj = FNOOP;

		this.log.active.f = this.f;
		this.log.noop.f = FNOOP;		

		this.log.active.fm = this.fm;
		this.log.noop.fm = FNOOP;

		// if you're going to use the Flog directly, you need to make sure to also FNOOP the noop logger...
			// that's why this probably should stay on the .logger, where you have to access it via this.logger.Flog
		// this.log.Flog = this.Flog;
	},
	str: function(str){
		this.add('"' + str + '"', "color: red;");
	},
	num: function(num){
		this.add(num, "color: blue;");
	},
	bool: function(bool){
		this.add(bool ? "true":"false", "color: purple;");
	},
	Class: function(cls){
		this.add(cls.name + "<" + cls.id + ">", "font-weight: bold;");
	},
	fn: function(fn){
		this.add( fn.name ? fn.name + "()" : "anon()", "color: #ff3700;");
	},
	var: function(value, name){
		if (name)
			this._name(name);
		this.value(value);
	},
	_name: function(name){
		this.add(name + ": ", "color: purple; font-weight: normal;");
	},
	value: function(value){
		if (is.str(value))
			this.str(value);
		else if (is.bool(value))
			this.bool(value);
		else if (is.num(value))
			this.num(value);
		else if (is.Class(value))
			this.Class(value);
		else if (is.fn(value))
			this.fn(value);
		else if (is.mod(value))
			this.mod(value);
		else if (is.obj(value))
			this.obj(value);
		else if (is.arr(value))
			this.arr(value);
		else
			this.str(value.toString());
	},
	sep: function(){
		this.add(", ", "font-weight: normal;");
	},
	values: function(values, names){
		if (names && names.length){
			for (var i = 0; i < names.length; i++){
				this.var(values[i], names[i]);
				if (i < names.length - 1)
					this.sep();
			}

			if (i < values.length){
				this.sep();
				this.values(values.slice(i));
			}
		} else if (values && values.length){
			for (var i = 0; i < values.length; i++){
				this.var(values[i]);
				if (i < values.length - 1)
					this.sep();
			}
		}
	},
	call: function(fn){},
	obj: function(obj){
		var bg = "background: #eee; border-bottom: 1px solid #ddd;";
		var length = 0;
		for (var i in obj) length++;
		var keys = Object.keys(obj);
		this.add(obj.constructor.name + " {", bg + "padding-left: 5px;");
		for (var i = 0; i < keys.length; i++){
			this._name(keys[i]);
			this.appendStyle(bg);
			this.value(obj[keys[i]]);
			this.appendStyle(bg);
			if (i < keys.length - 1){
				this.add(", ", "font-weight: normal;" + bg);
			}
		}
		this.add("}", bg + "padding-right: 5px");

	},
	arr: function(arr){
		return this.f(["["+ arr.length + "]", "color: blue;"]);
	},
	obj: function(obj){
		return this.f([obj.name, "font-weight: bold;"], [obj.constructor.name, "font-weight: normal; color: #888; font-style: italic;"], ["{...}"]);
	},
	initialize_api: function(){
		for (var i in this.api){
			if (is.fn(this.api[i])){
				this.log.active[i] = this.api[i];
				this.log.noop[i] = FNOOP;
			} else if (is.pojo(this.api[i])){
				if (this.api[i].both){
					this.log.active[i] = this.log.noop[i] = this.api[i].both;
				} else if (this.api[i].active && this.api[i].noop){
					this.log.active[i] = this.api[i].active;
					this.log.noop[i] = this.api[i].noop;
				} else {
					console.error("wrong");
				}
			}
		}
	},
	excludes: ["log", "hasOwnProperty"],
	getProxy: function(mod){ // each method call, which creates a unique instance, can have its own reference to the created .proxy
			// in which case, it can't have a .proxy() getter.
			// so it's called .get_proxy()
			// maybe we name this .get_proxy() also, even though its not storing .proxy?
			// or call it getProxy(), which sort of makes that distinction
		if (typeof Proxy !== "undefined"){
			return new Proxy(mod, {
				get: this.getter.bind(this)
			});
		} else {
			console.warn("Proxy is undefined.");
			return mod;
		}
	},
	getter: function(ctx, prop){
		const value = ctx[prop];

		if (is.fn(value) && this.excludes.indexOf(prop) === -1){
			// console.log("method proxy:", prop);
			return this.methods.clone({
				logger: this,
				ctx: ctx,
				fn: value,
				name: prop
			}).getProxy();
		} else {
			return value;
		}
	},
	// use this to construct this.log, and methods can use it to get a copy that they can customize
	build: function(){
		var log = console.log.bind(console);
		// add the standard fns 
		// and the custom api
		// also create the noop api for std and custom
		return log;
	},
	clone: function(){
		var clone = Object.create(this);
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
});

Mod.prototype.log = new Logger(false).log;