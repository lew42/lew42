var Mod = require("mod42/v2");
var is = require("util42").is;
var Method2 = require("../v2");
var track = require("track42");

var define = require("mixin42/define");
var cloner = require("mixin42/cloner");

var Logger = require("log42/v1")

/*
TODO:  abstract this auto-cloner functionality
TODO:  abstract this Sfn functionality between Mfn, Logger, and Method
*/
var Method = module.exports = Method2.extend({ name: "Method3" }, 
	/* mixins */ define, cloner, 
{
	log: Logger(),
	getter: function(ctx){
		var clone = this.protect(ctx);
		return clone ? clone.wrapper : this.wrapper;
	},
	assignedTo: function(parent, name){
		this.mod = parent;
		this.name = name;
		this.init_define(this.mod, this.name);
	},
	exec: function(ctx, args){
		var ret;

		if (ctx !== this.mod){
			console.warn("Oops?  I suppose this could happen when a method from another object is applied to 'this'.  For example, when you do MyBase.prototype.whatever.apply(this, arguments).");
		}

		// if (ctx.log){
		// 	/**/
		// 	console.error("TODO: Give method its own .log.  Link the method.log to the ctx/parent .log, so that all method.logs also get added to parent.log?")
		// 	ctx.log("method.exec", '[ name:', this.name, '][ ctx:', ctx, '][ args:', args, ']');
		// } else {
			this.log.group(this.name + "()", function(){
				ret = this.fn.apply(ctx, args);
			}.bind(this));
		// }


		// if (ctx.log){
		// 	ctx.log("method.exec", "[ ret:", ret, ']');
		// }

		return ret;
	}
});