# Use View.Frag as an indicator to 'group', or keep independent..

view.append(viewColl) --> keep it independent

view.append(fn) --> captures, and uses a CaptureFrag, that dissolves itself.. 
view.append(View.Frag(fn)) --> specifies that we specifically want to group these.  So the resulting frag gets appended, rather than unwrapped...
- and, we can add an update fn..
- as a Frag, the init fn is treated as a 'build' fn only - it shouldn't automatically rerun on update, because... taht would be silly (throwing away the old dom every update?)




view.append(viewColl);
--> view.content was undefined
	view.content = viewColl; // IF WE JUST ADOPT THE INCOMING COLL

It basically ruins the entity that was the viewColl.  For example, if viewColl represented a specific set of N items, then:

view.append("another") --> view.content.append("another")

.. would "mutate" the original viewColl, if anyone still had a reference to it.




# Sooo..

If we want unique, sustainable, *independent* coll that we can pass around as "live" documentFragments, we need to double wrap the coll...

view.append(independentViewColl)
--> view.content = ViewColl().append(independentViewColl);

That's a little redundant, but in this case, the indepdendentViewColl is treated as a single entity.  We can, for example, .remove() it, with 1 action.

And, ultimately it's the same outcome...  The nested view colls get flattened anyway, so there's no extra elements...


How that is handled with the nodes?  I don't know.  Because documentFragments don't work that way.  I'll have to basically track all the nodes independently, to essentially 'mock' what the default behavior should have been.