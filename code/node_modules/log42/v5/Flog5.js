var Base = require("base42/v1");
var is = require("util42").is;

var Flog = module.exports = Base.extend({
	constructor: function Flog(){
		this.instantiate.apply(this, arguments);
	},
	method: "log",
	stylesForAll: "",
	instantiate: function(){
		this.assign.apply(this, arguments);


		this.args = this.args || [];
		this.build = this.build;
		this.addStyled = this.addStyled;
		this.flargs = [];

		this.f = this.add;
		this.s = this.addStyled;
		this.all = this.appendStyleToAll;

		for (var i = 0; i < this.args.length; i++){
			this.add(this.args[i]);
		}
	},
	add: function(){
		var arg;
		// add any value, or a BLF w/ .flog
		for (var i = 0; i < arguments.length; i++){
			arg = arguments[i];
			// console.log(arg);
			if (arg === "DO_NOT_LOG"){
				return this;
			} else if (is.fn(arg) && arg.flog)
				this.addFlog(arg.flog);
			else if (is.fn(arg) && arg.noop){
				return this;
			} else if (arg instanceof Flog){
				this.addFlog(arg);
			} else if (	is.arr(arg) && 
						arg.length === 2 && 
						is.str(arg[0]) &&
						is.str(arg[1]) &&
						arg[1].indexOf(":") !== -1){
				// shorthand for a styled string [str, style]
				// this prevents the flogging of a 2-length array with 2 string values, the second of which contains a ":".  But, you could always use the plain .log function if you need to, and it's rare this will be a problem...
				this.addStyled(arg[0], arg[1]);
			} else if (is.str(arg) && !this.sealed){
				this.addStyled(arg); // .f(str) is basically unstyled, but this prevents the flog from sealing
			
			} else
				this.addUnstyled(arg);
		}

		return this; // important
	},
	addFlog: function(flog){
		this.flargs.push(flog);
	},
	addUnstyled: function(value){
		this.flargs.push({ unstyled: true, value: value });
	},
	addStyled: function(str, style){
		this.flargs.push({
			styled: true,
			str: str,
			style: style || ""
		});

		return this;
	},
	api: {
		f: function(){
			return this.flog.add.apply(this.flog, arguments);
		},
		s: function(str, style){
			return this.flog.addStyled(str, style);
		},
		all: function(style){
			return this.flog.appendStyleToAll(style);
		},
		build: function(){
			return this.flog.build();
		}
	},
	styledFlargs: function(){
		return this.flargs.filter(flarg => flarg.styled);
	},
	flogFlargs: function(){
		return this.flargs.filter(flarg => flarg instanceof Flog);
	},
	appendStyleToAll: function(style){
		this.styledFlargs().forEach(styledFlarg => {
			styledFlarg.style += ";" + style + ";";
		});
		this.flogFlargs().forEach(flogFlarg => {
			flogFlarg.all(style);
		});
		return this;
	},
	build: function(){
		this.sealed = false;
		this.str = "";
		this.styles = [];
		this.logArgs = [];

		for (var i = 0; i < this.flargs.length; i++){
			this.buildFlarg(this.flargs[i]);
		}

		var logArgs = [this.str].concat(this.styles, this.logArgs);

		this.log = console[this.method].bind.apply(console[this.method], [console].concat(logArgs));
		this.log.flog = this;

		this.buildAPI();

		return this.log;
	},
	buildFlarg: function(flarg){
		if (flarg.styled)
			this.buildStyledFlarg(flarg);
		else if (flarg.unstyled)
			this.buildUnstyledFlarg(flarg);
		else if (flarg instanceof Flog)
			this.buildFlogFlarg(flarg);
		else if (is.fn(flarg))
			this.buildFlarg(flarg.call(this.flargFnCtx));
		else
			console.error("whoops");
	},
	buildStyledFlarg: function(flarg){
		if (this.sealed){
			this.logArgs.push(flarg.str);
		} else {
			this.str += "%c" + flarg.str;
			this.styles.push(flarg.style);
		}
	},
	buildUnstyledFlarg: function(flarg){
		if (this.sealed){
			this.logArgs.push(flarg.value);
		} else {
			if (is.str(flarg.value)){
				this.str += "%c" + flarg.value;
				this.styles.push("");
			} else {
				this.logArgs.push(flarg.value);
				this.sealed = true;
			}
		}
	},
	buildFlogFlarg: function(flog){
		for (var i = 0; i < flog.flargs.length; i++){
			this.buildFlarg(flog.flargs[i]);
		}
	},
	buildAPI: function(){
		for (var i in this.api){
			this.log[i] = this.api[i]; 
		}
	}
});