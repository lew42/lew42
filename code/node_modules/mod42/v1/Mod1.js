var Base = require("base42/v1");
var is = require("util42/is");

var set = function(){
	var arg;
	for (var i = 0; i < arguments.length; i++){
		arg = arguments[i];

		// pojo arg
		if (is.pojo(arg)){

			// iterate over arg props
			for (var j in arg){

				// set_*
				if (this["set_" + j]){
					this["set_" + j](arg[j]);

				// assign
				} else if (is.simple(this[j])){
					this[j] = arg[j];

				// recursive protect/set
				} else if (this[j] && this[j].set) {
					if (this.hasOwnProperty(j))
						this[j].set(arg[j]);
					else
						this[j] = this[j].clone(arg[j]);

				// "assign" prop will just call assign
				} else if (j === "assign") {
					this.assign(arg[j]);

				// existing prop is a pojo - "extend" it
				} else if (is.pojo(this[j])){
					if (this.hasOwnProperty(j))
						this.set.call(this[j], arg[j]);
					else {
						this[j] = Mod.prototype.set.call(Object.create(this[j]), arg[j]);
					}

				// everything else, assign
				} else {
					// basically just arrays and fns...
					// console.warn("what are you", arg[j]);
					this[j] = arg[j];
				}
			}

		// non-pojo arg
		} else if (this.set_){
			this.set_(arg);

		// oops
		} else {
			console.warn("not sure what to do with", arg);
		}
	}

	return this; // important
};

var Mod = module.exports = Base.extend({
	// createConstructor: function(){
	// 	return function Mod(){
	// 		this.instantiate.apply(this, arguments);
	// 	}
	// },
	// createConstructor: function(){
	// 	return function Mod(){
	// 		if (!(this instanceof Mod))
	// 			return new (Mod.bind.apply(Mod, [null].concat([].slice.call(arguments))));
	// 		var instance = this.__config.apply(this, arguments) || this;
	// 		instance.instantiate.apply(instance, arguments);
	// 		return instance;
	// 	};
	// },
	name: "Mod",
	createConstructor: function(o){
		var name = (o && o.name) || this.name + "Ext";
		eval("var " + name + ";");
		var constructor = eval("(" + name + " = function " + name + "(){\r\n\
		if (!(this instanceof " + name + "))\r\n\
			return new (" + name + ".bind.apply(" + name + ", [null].concat([].slice.call(arguments)) ));\r\n\
		var instance = this.__config.apply(this, arguments) || this;\r\n\
		instance.instantiate.apply(instance, arguments);\r\n\
		return instance;\r\n\
	});");
		return constructor;
	},
	__config: function(o){
		this.__config_log(o);
		return this.__config_proxy(o);
	},
	__config_log: function(o){
		if (is.pojo(o) && is.def(o.log)){
			this.log = this.log.logger.clone(o.log).log;
			delete o.log;
		}
	},
	__config_proxy: function(o){
		if (this.log.isActive){
			return this.log.logger.getProxy(this);
		} else {
			return this;
		}
	},
	instantiate: function(){
		this.set.apply(this, arguments);
		this.initialize.apply(this, arguments);
	},
	initialize: function(){},
	set: set,
	/*
	* Caveats to cloning:
	*  - properties can show through (live inheritance)
	*  - reinstantiating an object might be unpredictable - it depends on what kind of state your object has, and what happens in instantiate.  Also, if any external side effects.
	*/
	clone: function(){
		var clone = Object.create(this);
		clone = clone.__config.apply(clone, arguments) || clone;
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
}).assign({
	extend: function(o){
		var opts = {}, Ext;

		// we need to configure the prototype, like we do for instances
		// we don't want the o.log property getting assigned to the prototype...
		// extract the o.log value before calling the Base1.extend
		if (is.pojo(o) && is.def(o.log)){
			opts.log = o.log;
			delete o.log;
		}
		
		// Base1.extend will assign all the args...
		Ext = Base.extend.apply(this, arguments);

		// now we can handle the .log config, mocking the original `o` with `opts`
		if (is.def(opts.log))
			Ext.prototype.__config_log(opts);

		return Ext;
	}
});



var NOOP = function(){};

var getLogBase = function(on){
	// activeLogBase
	var active = console.log.bind(console);
	
	// noopLogBase
	var noop = function(){};
	
	active.isActive = true;
	noop.isActive = false;

	["log", "group", "debug", "trace", "error", "warn", "info"].forEach(function(method){
		active[method] = console[method].bind(console);
		noop[method] = NOOP;
	});

	active.groupc = console.groupCollapsed.bind(console);
	noop.groupc = NOOP;

	active.end = console.groupEnd.bind(console);
	noop.end = NOOP;

	active.close = function(fn, ctx){
		if (fn) fn.call(ctx);
		this.end();
	};
	noop.close = function(fn, ctx){
		if (fn) fn.call(ctx);
	};

	active.noop = noop;
	active.active = active;
	noop.active = active;
	noop.noop = noop;

	// `on` is passed in as a fn arg
	return is.def(on) && !on ? noop : active;
};

var Base2 = Base.extend({
	set: set,
	instantiate: function(){
		this.set.apply(this, arguments);
		this.initialize && this.initialize();
	},
	clone: function(){
		var clone = Object.create(this);
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
});

var Method = Base2.extend({
	constructor: function Method(){
		this.instantiate.apply(this, arguments);
	},
	set: set,
	set_: function(value){
		if (is.bool(value)){
			this.set_log(value);
		}
	},
	set_log: function(bool){
		if (bool) this.log = this.logger.log.active;
		else this.log = this.logger.log.noop;
	},
	instantiate: function(o){
		this.set.apply(this, arguments);
		this.instantiate_settings();
		this.instantiate_log();
	},
	instantiate_settings: function(){
		if (this.logger && this.logger.method[this.name])
			this.set(this.logger.method[this.name]);
	},
	instantiate_log: function(){
		// in case nobody has configured it, it'll be undefined as of this point
		if (!this.hasOwnProperty("log") && this.logger) // the default .methods instance is an edge case - it doesn't need a .log (it'll never be used by itself)
			this.set_log(true);
	},
	exec: function(fn, ctx, args){
		var ret;
		console.group(this.name + "(", args, ")");
		ret = fn.apply(ctx, args);
		console.groupEnd();
		return ret;
	},
	// method doesn't do anything w/o proxy...
	// setting methodName: false could mean proxy && squelch...
	getProxy: function(){
		if (!this.fn)
			console.error("must provide fn to proxy");

		if (!this.ctx.log.isActive || !this.log.isActive){
			console.warn("huh?");
			return this.fn;
		}

		this.proxy = new Proxy(this.fn, {
			apply: this.exec.bind(this)
		});

		return this.proxy;
	}
});


var Flog = Base.extend({
	method: "log",
	all: "",
	constructor: function Flog(){
		this.instantiate.apply(this, arguments);
	},
	instantiate: function(){
		this.assign.apply(this, arguments);

		if (is.pojo(this.args[0])){
			this.assign(this.args[0]);
			this.args = [].slice.call(this.args, 1);
		}

		this.build();
	},
	build: function(){
		this.str = "";
		this.styles = [];
		
		for (var i = 0; i < this.args.length; i++)
			this.buildArg(this.args[i]);

		this.log = console[this.method].bind.apply(console[this.method], [console].concat([this.str], this.styles));
		this.log.flog = this;

		return this.log;
	},
	buildArg: function(arg){
		var styles;
		if (is.str(arg)){
			this.str += "%c" + arg;
			this.styles.push(this.all);
		} else if (is.arr(arg)){
			this.str += "%c" + arg[0];
			this.styles.push(arg[1] + ";" + this.all);
		} else if (is.fn(arg) && arg.flog){
			this.str += arg.flog.str;
			styles = arg.flog.styles.slice(0).map(function(style){
				return style + ";" + this.all; 
			}.bind(this));
			this.styles = this.styles.concat(styles);
		}
	}
});



var FNOOP = function(){
	return NOOP;
}

var Logger = Base2.extend({
	createConstructor: function(){
		return function Logger(){
			this.instantiate.apply(this, arguments);
		}
	},
	set: set,
	instantiate: function(){
		this.set.apply(this, arguments);
		this.initialize();
	},
	api: {},
	method: {},
	methods: new Method(),
	set_log: function(bool){
		this.log = getLogBase(bool);
		this.log.logger = this;
	},
	set_: function(value){
		if (is.bool(value))
			this.set_log(value);
	},
	// method has to be a pojo, so it can have ANY prop name
	set_method: function(pojo){
		if (!this.hasOwnProperty("method"))
			this.method = Object.create(this.method);

		for (var i in pojo){
			if (is.bool(pojo[i]))
				pojo[i] = { log: pojo[i] };
			if (this.method[i]){
				if (this.method.hasOwnProperty(i))
					this.set.call(this.method[i], pojo[i]);
				else 
					this.method[i] = this.set.call(Object.create(this.method[i]), pojo[i]);
			} else {
				this.method[i] = pojo[i];
			}
		}
	},
	// creates a .log which is exported immediately
	initialize: function(){
		this.initialize_std();
		// build out the api, regardless of whether log.isActive
		this.initialize_api();
	},
	initialize_std: function(){
		this.log.active.obj = this.obj;
		this.log.noop.obj = FNOOP;

		this.log.active.f = this.f;
		this.log.noop.f = FNOOP;
	},
	f: function(){
		return new Flog({
			args: arguments
		}).log;
	},
	fm: function(method){
		return new Flog({
			args: [].slice.call(arguments, 1),
			method: method
		}).log;
	},
	initialize_api: function(){
		for (var i in this.api){
			if (is.fn(this.api[i])){
				this.log.active[i] = this.api[i];
				this.log.noop[i] = FNOOP;
			} else if (is.pojo(this.api[i])){
				if (this.api[i].active)
					this.log.active[i] = this.api[i].active;
				if (this.api[i].noop)
					this.log.noop[i] = this.api[i].noop;
			}
		}
	},
	excludes: ["log", "hasOwnProperty"],
	getProxy: function(mod){ // each method call, which creates a unique instance, can have its own reference to the created .proxy
			// in which case, it can't have a .proxy() getter.
			// so it's called .get_proxy()
			// maybe we name this .get_proxy() also, even though its not storing .proxy?
			// or call it getProxy(), which sort of makes that distinction
		if (typeof Proxy !== "undefined"){
			return new Proxy(mod, {
				get: this.getter.bind(this)
			});
		} else {
			console.warn("Proxy is undefined.");
			return mod;
		}
	},
	getter: function(ctx, prop){
		const value = ctx[prop];

		if (is.fn(value) && this.excludes.indexOf(prop) === -1){
			return this.methods.clone({
				logger: this,
				ctx: ctx,
				fn: value,
				name: prop
			}).getProxy();
		} else {
			return value;
		}
	},
	// use this to construct this.log, and methods can use it to get a copy that they can customize
	build: function(){
		var log = console.log.bind(console);
		// add the standard fns 
		// and the custom api
		// also create the noop api for std and custom
		return log;
	},
	clone: function(){
		var clone = Object.create(this);
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
});

Mod.prototype.log = new Logger(false).log;