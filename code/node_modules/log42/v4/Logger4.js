var getLogBase = require("./getLogBase");
var Base = require("base42/v1");
var Base2 = require("base42/v2");
var is = require("util42/is");

require("./Logger4.styles.less");

var Method = require("method42/v8");

var set = require("set42/setfn1");

var View = require("view42/v1");

var ModView = View.extend({
	render: function(){
		var modView = this;
		var mod = this.mod;
		this.append({
			label: View(this.mod.name + "-" + this.mod.constructor.name),
			contents: View()
		});

		this.addClass("logger4");

		this.label.el.addEventListener("click", function(){
			// console.log("clicked");
			this.contents.toggle();
		}.bind(this));

		// this.contents.hide();
	},
	// !!! update won't add new props... either diff it or just mem leak
	update: function(){
		var key;
		var last = this.last;
		this.last = {};

		var own = Object.keys(this.mod);

		for (var i = 0; i < own.length; i++){

		}

		for (var propName in this.mod){
			if (is.fn(this.mod[propName]))
				continue;
			key = "prop_"+propName;
			if (this[key]){
				if (this.mod[propName] !== last[propName])
					this[key].update();
			} else {
				this.make(propName);
			}

			this.last[propName] = this.mod[propName];
		}
	},
	make: function(propName){
		var mod = this.mod;
		var key = "prop_" + propName;

		this[key] = View({
			render: function(){
				this.append({
					propName: View(propName),
					propType: View(),
					propValue: View()
				})
			},
			update: function(){
				var propValue = mod[propName];
				var propValueDisplay = "";

				this.propType.el.textContent = typeof propValue;
				
				if (is.fn(propValue)){
					propValueDisplay = propValue.name + "()";
				} else if (is.str(propValue)){
					propValueDisplay = '"'+propValue+'"';
				} else if (is.arr(propValue)){
					propValueDisplay = "["+(propValue.length ? propValue.length : "") +"]";
					this.propType.el.textContent = "array";
				} else {
					propValueDisplay = propValue.toString();
				}

				if (is.arr(propValue)){
					this.addClass("array");
				} else {
					this.addClass(typeof propValue);
				}

				// console.log(propName, propValue, "" === propValue.toString(), propValueDisplay);

				this.propValue.el.textContent = propValueDisplay;

				this.el.className = "";
				this.addClass("prop");
			}
		});

		if (this.mod.hasOwnProperty(propName)){
			this.contents.prepend(this[key]);
		} else {
			this.contents.append(this[key]);
		}
	}
});


// for each flog arg?
var Flarg = Base.extend({});
var Flogument = Base.extend({});

var Flog = Base.extend({
	method: "log",
	stylesForAll: "",
	constructor: function Flog(){
		this.instantiate.apply(this, arguments);
	},
	instantiate: function(){
		this.assign.apply(this, arguments);

		this.args = this.args || [];

		// if (is.pojo(this.args[0])){
		// 	this.assign(this.args[0]);
		// 	this.args = [].slice.call(this.args, 1);
		// }



		this.str = "";
		this.styled = []; // { str: "", style: "" }
		this.unstyled = []; // any value

		// for chaining once the flog.log gets swapped with flog.. both the flog.log.f() and flog.f() should work
		this.f = this.add;
		this.s = this.addStyled;
		this.all = this.appendStyleToAll;

		for (var i = 0; i < this.args.length; i++)
			this.add(this.args[i]);
	},
	add: function(){
		var arg;
		// add any value, or a BLF w/ .flog
		for (var i = 0; i < arguments.length; i++){
			arg = arguments[i];
			// console.log(arg);
			if (is.fn(arg) && arg.flog)
				this.addFlog(arg.flog);
			else if (is.fn(arg) && arg.noop){
				return this;
			} else if (arg instanceof Flog){
				this.addFlog(arg);
			} else if (	is.arr(arg) && 
						arg.length === 2 && 
						is.str(arg[0]) &&
						is.str(arg[1]) &&
						arg[1].indexOf(":") !== -1){
				// shorthand for a styled string [str, style]
				// this prevents the flogging of a 2-length array with 2 string values, the second of which contains a ":".  But, you could always use the plain .log function if you need to, and it's rare this will be a problem...
				this.addStyled(arg[0], arg[1]);
			} else if (is.str(arg) && !this.sealed){
				this.addStyled(arg); // .f(str) is basically unstyled, but this prevents the flog from sealing
			
			} else
				this.addUnstyled(arg);
		}

		return this; // important
	},
	addFlog: function(flog){
		if (this.sealed && flog.styled.length){
			// console.warn("can't add styled arguments after unstyled arguments");
			this.unstyled = this.unstyled.concat(flog.styled.map(function(s){
				return s.str;
			}));
		} else if (flog.styled.length){
			this.styled = this.styled.concat(flog.styled);
		}

		if (flog.unstyled.length){
			this.unstyled = this.unstyled.concat(flog.unstyled);
			this.sealed = true;
		}
	},
	addUnstyled: function(value){
		// there cannot be any styled args AFTER the unstyled...
		// must be tracked (stored) in the same 'args' array, or whatever
		this.unstyled.push(value);
		this.sealed = true;
	},
	addStyled2: function(str, style){
		if (this.sealed){
			this.add(str);
			console.warn("You cannot add styled log arguments after an unstyled log argument as been added.");
		} else {
			style = style || "";
			// used by .log.s()
			this.str += "%c" + str;
			this.styled.push(style + ";" + this.stylesForAll + ";");
		}
		return this; // important
	},
	addStyled: function(str, style){
		if (this.sealed){
			this.addUnstyled(str);
			// console.warn("You cannot add styled log arguments after an unstyled log argument as been added.");
		} else {
			// used by .log.s()
			// this.str += "%c" + str;
			this.styled.push({
				str: str,
				style: style || ""
			});
		}
		return this; // important
	},
	api: {
		f: function(){
			return this.flog.add.apply(this.flog, arguments);
		},
		s: function(str, style){
			return this.flog.addStyled(str, style);
		},
		all: function(style){
			return this.flog.appendStyleToAll(style);
		},
		build: function(){
			return this.flog.build();
		}
	},
	appendStyleToAll: function(style){
		for (var i = 0; i < this.styled.length; i++){
			this.styled[i].style = this.styled[i].style + ";" + style + ";";
		}
		return this;
	},
	build: function(){
		var logArgs;

		if (this.all)
			this.appendStyleToAll(this.all);

		var str = "";
		for (var i = 0; i < this.styled.length; i++){
			str += "%c" + this.styled[i].str;
		}

		logArgs = [str].concat(this.styled.map(function(s){
			return s.style;
		}), this.unstyled);
		// console.log("logArgs", logArgs);
		this.log = console[this.method].bind.apply(console[this.method], [console].concat(logArgs));
		this.log.flog = this;

		this.buildAPI();

		return this.log;
	},
	buildAPI: function(){
		for (var i in this.api){
			this.log[i] = this.api[i]; 
		}
	},
	buildArg: function(arg){
		var styles;
		if (is.str(arg)){
			this.str += "%c" + arg;
			this.styles.push(this.all);
		} else if (is.arr(arg)){
			this.str += "%c" + arg[0];
			this.styled.push(arg[1] + ";" + this.all);
		} else if (is.fn(arg) && arg.flog){
			this.str += arg.flog.str;
			styles = arg.flog.styles.slice(0).map(function(style){
				return style + ";" + this.all; 
			}.bind(this));
			this.styles = this.styles.concat(styles);
		}
	}
});



var FNOOP = function(){
	return function(){};
}

var Logger = module.exports = Base2.extend({
	createConstructor: function(){
		return function Logger(){
			this.instantiate.apply(this, arguments);
		}
	},
	method: {},
	methods: new Method({
		isMethodsDefault: true
	}),
	set: set,
	FNOOP: FNOOP,
	Flog: Flog,
	instantiate: function(){
		this.set.apply(this, arguments);

		// Method.set relies on looking up defaults from method.logger.methods.whatever, which means methods should have the proper .logger reference immediately (before .instantiate())

		// we may or may not have extended/cloned .methods via the .set.apply(args) above
		if (!this.hasOwnProperty("methods"))
			this.methods = this.methods.clone();

		// all method instances clone from this.methods, and are unique to this (their .logger)
		// by adding a reference to this instance to this.methods, we inherit this reference in all method instances
		this.methods.logger = this;


		if (!this.log)
			this.set_log(false);
		else if (!this.hasOwnProperty("log"))
			this.set_log(this.log.isActive); // make sure we have our own log base



		this.initialize();
	},
	// creates a .log which is exported immediately
	initialize: function(){
		// build out the api, regardless of whether log.isActive
		this.initialize_api();
	},
	api: {
		safe: function(){
			// this could be an 'only execute if log is on' method, that safely NOOPs
			// good for performance (one NOOP)
			// good for complexity (don't need to keep the APIs in sync)
		},
		f: function(){
			return new this.logger.Flog({
				args: arguments,
				logger: this.logger,
			}).build();
		},
		fm: function(method){
			return new this.logger.Flog({
				args: [].slice.call(arguments, 1),
				method: method,
				logger: this.logger
			}).build();
		},
		s: function(str, style){
			return new this.logger.Flog({

			}).addStyled(str, style).build();
		},
		value: function(value, name){
			if (is.def(name)){
				return this.f([name, "color: purple"], ":", value);
			} else {
				return this.f(value);
			}
		},
		obj: function(obj){
			if (obj.name){
				return this.mod(obj);
			} else {
				return this.s(obj.constructor.name + " {" + Object.keys(obj).length + "}").all("background: #eee").build();
			}
		},
		mod: function(mod){
			return this.s(mod.name + " ").s(mod.constructor.name, "color: #888").s(" {" + Object.keys(mod).length + "}").all("background: #eee").build();
		},
		str: function(str){
			return this.s('"' + str + '"', "color: red;");
		},
		num: function(num){
			return this.s(num, "color: blue;");
		},
		bool: function(bool){
			return this.s(bool ? "true":"false", "color: purple;");
		},
		Class: function(cls){
			return this.s(cls.name + "<" + cls.id + ">", "font-weight: bold;");
		},
		fn: function(fn){
			return this.s( fn.name ? fn.name + "()" : "anon()", "color: #ff3700;");
		},
		var: function(value, name){
			if (name){
				return this._name(name).f(this.value(value));
			} else {
				return this.value(value);
			}
		},
		_name: function(name){
			return this.s(name + ": ", "color: purple; font-weight: normal;");
		},
		value: function(value, name){
			if (is.str(value))
				return this.str(value);
			else if (is.bool(value))
				return this.bool(value);
			else if (is.num(value))
				return this.num(value);
			else if (is.Class(value))
				return this.Class(value);
			else if (is.fn(value))
				return this.fn(value);
			else if (is.mod(value))
				return this.mod(value);
			else if (is.obj(value))
				return this.obj(value);
			else if (is.arr(value))
				return this.arr(value);
			else if (is.def(value))
				return this.f(value.toString());
			else
				return this.f(["undefined", "color: purple"]);
		},
		// sep: function(){
		// 	this.add(", ", "font-weight: normal;");
		// },
		arr: function(arr){
			return this.f(["["+ arr.length + "]", "color: blue;"]);
		},
		// values: function(values, names){
		// 	if (names && names.length){
		// 		for (var i = 0; i < names.length; i++){
		// 			this.var(values[i], names[i]);
		// 			if (i < names.length - 1)
		// 				this.sep();
		// 		}

		// 		if (i < values.length){
		// 			this.sep();
		// 			this.values(values.slice(i));
		// 		}
		// 	} else if (values && values.length){
		// 		for (var i = 0; i < values.length; i++){
		// 			this.var(values[i]);
		// 			if (i < values.length - 1)
		// 				this.sep();
		// 		}
		// 	}
		// },
		// obj: function(obj){
		// 	var bg = "background: #eee; border-bottom: 1px solid #ddd;";
		// 	var length = 0;
		// 	for (var i in obj) length++;
		// 	var keys = Object.keys(obj);
		// 	this.add(obj.constructor.name + " {", bg + "padding-left: 5px;");
		// 	for (var i = 0; i < keys.length; i++){
		// 		this._name(keys[i]);
		// 		this.appendStyle(bg);
		// 		this.value(obj[keys[i]]);
		// 		this.appendStyle(bg);
		// 		if (i < keys.length - 1){
		// 			this.add(", ", "font-weight: normal;" + bg);
		// 		}
		// 	}
		// 	this.add("}", bg + "padding-right: 5px");
		// },
		on: {
			both: function(bool, mod, fn){
				var last;

				if (!is.bool(bool)){
					fn = mod;
					mod = bool;
					bool = true;
				}

				if (bool){
					last = mod.log;
					mod.log = mod.log.active;
					fn.call(mod);
					mod.log = last;
				} else {
					fn.call(mod);
				}
			}
		},
		off: {
			both: function(bool, mod, fn){
				var last;

				if (!is.bool(bool)){
					fn = mod;
					mod = bool;
					bool = true;
				}

				if (bool){
					last = mod.log;
					mod.log = mod.log.noop;
					fn.call(mod);
					mod.log = last;
				} else {
					fn.call(mod);
				}
			}
		}
	},
	set_log: function(bool){
		this.log = getLogBase(bool);
		this.log.active.logger = this;
		this.log.noop.logger = this;
	},
	set_: function(value){
		if (is.bool(value))
			this.set_log(value);
		else
		console.info("implement .set_ fn --> .shouldLog, so you can conditionally turn it on.");

		/*
		Mod.extend({
			log: function(){
				// .shouldLog shortcut
			} || {
				shouldLog: function(){
					// when is this called?  Upon instantiation?
				}
			}
		});
		*/
	},
	// method has to be a pojo, so it can have ANY prop name
	set_method: function(pojo){
		if (!this.hasOwnProperty("method"))
			this.method = Object.create(this.method);

		for (var i in pojo){
			if (is.bool(pojo[i])){
				pojo[i] = { log: pojo[i] };
			}
			else if (is.str(pojo[i]))
				pojo[i] = { mode: pojo[i] };

			if (this.method[i]){
				if (this.method.hasOwnProperty(i))
					this.set.call(this.method[i], pojo[i]);
				else 
					this.method[i] = this.set.call(Object.create(this.method[i]), pojo[i]);
			} else {
				this.method[i] = pojo[i];
			}
		}
	},
	initialize_api: function(){
		for (var i in this.api){
			if (is.fn(this.api[i])){
				this.log.active[i] = this.api[i];
				this.log.noop[i] = FNOOP;
			} else if (is.pojo(this.api[i])){
				if (this.api[i].both){
					this.log.active[i] = this.log.noop[i] = this.api[i].both;
				} else if (this.api[i].active && this.api[i].noop){
					this.log.active[i] = this.api[i].active;
					this.log.noop[i] = this.api[i].noop;
				} else {
					console.error("wrong");
				}
			}
		}
	},
	excludes: ["log", "hasOwnProperty"],
	getProxy: function(mod){ // each method call, which creates a unique instance, can have its own reference to the created .proxy
			// in which case, it can't have a .proxy() getter.
			// so it's called .get_proxy()
			// maybe we name this .get_proxy() also, even though its not storing .proxy?
			// or call it getProxy(), which sort of makes that distinction
		var proxy;
		this.mod = mod;
		if (typeof Proxy !== "undefined"){
			this.views = this.views||[];
			if (this.app){
				
			var view = new ModView({mod: mod});
			this.views.push(view);

			this.app.adminPanel.contents.browse.append(view.el);
			}

			proxy = new Proxy(mod, {
				get: this.getter.bind(this),
				set: this.setter.bind(this)
			});

			this.proxy = proxy;
			// proxy[Symbol.for("isProxy")] = true;
			// proxy[Symbol.for("proxyTarget")] = mod;
			return proxy;
		} else {
			console.warn("Proxy is undefined.");
			return mod;
		}
	},
	update: function(){
		for (var i = 0; i < this.views.length; i++){
			this.views[i].update();
		}
	},
	setter: function(ctx, prop, value, rec){
		if (ctx !== this.mod)
			throw new Error("this shouldn't happen");
		if (rec !== this.proxy)
			throw new Error("Don't use Object.create() with proxied mods.  Use the .clone() method.");

		ctx[prop] = value;

		this.update();
		return true;
	},
	getter: function(ctx, prop, rec){
		var value = ctx[prop];

		// ctx seems to always be the target (non-proxy) and
		// rec seems to always be the proxy
		// console.group("logger.getter", prop);
		// ctx === this.proxy && console.count("ctx === logger.proxy");
		// ctx === this.mod && console.count("ctx === logger.mod");
		// rec === this.proxy && console.count("rec === logger.proxy");
		// rec === this.mod && console.count("rec === logger.mod");
		// console.groupEnd();

		if (ctx !== this.mod)
			throw new Error("this shouldn't happen");
		if (rec !== this.proxy)
			throw new Error("Don't use Object.create() with proxied mods.  Use the .clone() method.");
			// this only happens when we Object.create(proxy), which doesn't work properly

		if (prop === "_$_$_target")
			return this.mod;
		if (prop === "_$_$_proxy")
			return this.proxy;

		if (is.fn(value) && prop === "clone")
			value = value.bind(ctx);

		if (is.fn(value) && this.excludes.indexOf(prop) === -1){
			// console.log("method proxy:", prop);
			return this.methods.clone({
				context: this.proxy,
				fn: value,
				methodName: prop
			}).getProxy();
		} else {
			return value;
		}
	},
	// use this to construct this.log, and methods can use it to get a copy that they can customize
	build: function(){
		var log = console.log.bind(console);
		// add the standard fns 
		// and the custom api
		// also create the noop api for std and custom
		return log;
	},
	clone: function(){
		var clone = Object.create(this);
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
});