var Mod4 = require("../v4");
var is = require("util42").is;
var Method = require("method42/v3");
var Logger = require("log42/v1");

var Assign = require("assign42");


// just use set_label to exclude it from wrapping?
var exclude = ["label"];

var disable = true;

var Mod3 = module.exports = Mod4.extend({
	name: "Mod3",
	assign: Assign({
		assignment: function(mod, name, value){
			if (is.fn(mod["set_"+name]))
				mod["set_"+name](value);
			else {
				if (is.fn(value) && !is.Class(value) && exclude.indexOf(name) === -1 && (mod.log && mod.log.enabled !== false)){
					value = Method(value); 
				} else {
					mod[name] = value;
				}
			}
			
			if (value && is.fn(value.assignedTo)) value.assignedTo(mod, name);
		}
	}).fn,
	log: Logger(),
}).assign({
	isExtensionOf: function(Base){
		var base = this.base;
		while (base){
			if (base === Base)
				return true;
			base = base.base;
		}
		return false;
	},
	labelize: function(mod){
		var proto = mod.constructor.prototype === mod ? "&lt;proto&gt;" : "";

		return proto + mod.name + "{" + mod.constructor.name + "-" + mod.id + "}";
	},
	Method: Method
});

// var Set2 = require("set42/v2");
// Method(Mod3.prototype.set).assigned

var m = Method(Mod3.prototype.instantiate);
m.assignedTo(Mod3.prototype, "instantiate");

Method(Mod3.prototype.initialize).assignedTo(Mod3.prototype, "initialize");
Method(Mod3.prototype.init).assignedTo(Mod3.prototype, "init");

// m.assignedTo = function(parent, name){
// 	console.log("instantiateMethod.assignedTo");
// 	this.mod = parent;
// 	this.name = name;
// 	this.init_define(parent, name);
// };

// m.exec = function(ctx, args){
// 	console.log("instantiate()");
// 	return this.fn.apply(ctx, args);
// }

// Method(Mod3.extend).assignedTo(Mod3, "extend");

// console.log(Mod3.prototype.log);