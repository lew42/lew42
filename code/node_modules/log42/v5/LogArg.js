var Base2 = require("base42/v2");

var Arg = module.exports = Base2.extend({
	max: 100, // max str length for output
	str: "", // the output
	style: "", // css styles
	constructor: function LogArg(){
		this.instantiate.apply(this, arguments);
	},
	instantiate: function(){
		this.assign.apply(this, arguments);
	},
	add: function(){

	}
});

/*

The Method currently uses this fnoop config system, which is kind of clever, but pretty confusing.  Instead, I think each element of the method log (ctx, name, args, etc) could be its own preconfigured flog (doesn't need to build the .log fn until go time).

The default is configured in advance.  So, instead of having composable functions, we have composable objects that do what those functions would normally do.

Instead of composing: 

this.log.f(this.ctx(), this.name(), this.args())

We would have

this.flog.build()(), which would be precomposed?
or
this.compose(this.ctx, this.name, this.args);
where each of the above are .flogs, and can be configured via .set();

The question is, what is that compose function, and how does it compose?
This is basically the flog.add, but... ?

Should it be the same API as the log.f()?



So maybe the only real question here, is whether the log.f() fn should auto-build?
I think that's fine...?




Logger
Method
Arg

Logger creates the .log
Logger
	api
		value(value, name)
			--> ?
			switches based on value
			the formatting for the values should probably be.. based on a "theme"
			you could create rules based on the value name, or checking its type...
		custom(value, config, whatever)
			// build an Arg


Flog
This might be a decent approach.  A composable object that .builds() a console bound log function.  The Flog can make the logger base?  No - that's completely different.  The formatted log function doesn't need the full console[api].

Mod({
	log: {
		arg: {
			name: { // config for this arg name, across all methods }
		}
	}
})


ValueLogger
	Handles the logic for the log.value api
	Overrideable switching based on type?
*/