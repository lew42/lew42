// var Base = require("base42/v1");
var Mod = require("mod42/v1");

var set = function(){
	var arg;
	for (var i = 0; i < arguments.length; i++){
		arg = arguments[i];

		// pojo arg
		if (is.pojo(arg)){

			// iterate over arg props
			for (var j in arg){

				// set_*
				if (this["set_" + j]){
					this["set_" + j](arg[j]);

				// assign
				} else if (is.simple(this[j])){
					this[j] = arg[j];

				// recursive protect/set
				} else if (this[j] && this[j].set) {
					// readopt?
					// only auto-clone non-references (aka, direct children)
					// if you set against a reference, it should probably throw an error... you shouldn't ever modify references with .set... 
					if (this.hasOwnProperty(j))
						this[j].set(arg[j]);
					else if (this[j].clone)
						this[j] = this[j].clone(arg[j]);
					else
						throw "no .clone() method";

				// "assign" prop will just call assign
				} else if (j === "assign") {
					this.assign(arg[j]);

				// existing prop is a pojo - "extend" it
				} else if (is.pojo(this[j])){
					if (this.hasOwnProperty(j))
						this.set.call(this[j], arg[j]);
					else {
						this[j] = Mod.prototype.set.call(Object.create(this[j]), arg[j]);
					}

				// everything else, assign
				} else {
					// basically just arrays and fns...
					// console.warn("what are you", arg[j]);
					this[j] = arg[j];
				}
			}

		// non-pojo arg
		} else if (this.set_){
			this.set_(arg);

		// oops
		} else {
			console.warn("not sure what to do with", arg);
		}
	}

	return this; // important
};

var Mfn = module.exports = Mod.extend({
	name: "Mfn",
	log: false, // this should be the default, but just making sure
	__config_proxy: function(){
		return this; // don't proxy upon construction/cloning?
	},
	set_: function(value){
		if (is.str(value))
			this.name = value;
	},
	clone: function(){
		return Mod.prototype.clone.apply(this, arguments).wrapper;
	},
	initialize: function(){
		this.initialize_wrapper();
	},
	initialize_wrapper: function(){
		var mfn = this;

		// wrapper is assigned to a mod
		this.wrapper = function(){
			// `this` is the mod that the wrapper is assigned to
			// the method config for the wrapper should turn `this.log` on/off, and so we can just follow that
			// console.info("proxying...?", this, this.log.isActive);
			var proxy, args, ret;

			if (mfn.hasOwnProperty("log")){
				if (mfn.log.isActive){
					proxy = mfn.log.logger.getProxy(mfn);
					return proxy.exec.apply(proxy, [this].concat([].slice.call(args)));
				} else {
					// mfn.hasOwn log && !mfn.log.isActive
					return mfn.exec.apply(mfn, [this].concat([].slice.call(arguments)));
				}
			} else if (this.log.isActive){
				// !mfn.hasOwn log && mod.log.isActive
				proxy = mfn.log.logger.getProxy(mfn);
				args = arguments;

				// log defaults to noop, so turn it on
				// temporarily turns logger on, then restores it
				mfn.log.on(mfn, function(){
					// inside .exec, `this` != `mfn`, because `proxy` != `mfn`... this *hopefully* won't be an issue
					ret = proxy.exec.apply(proxy, [this].concat([].slice.call(args)));
				}.bind(this));

				// delayed return allows us to restore the mfn's .log state
				return ret;
			} else {
				// !mfn.hasOwn log && !mod.log.isActive
				return mfn.exec.apply(mfn, [this].concat([].slice.call(arguments)));

			}
		};

		this.initialize_wrapper_();
	},
	initialize_wrapper_: function(){
		this.wrapper.mfn = this;
		// !! should only be called if mod.hasOwn
		this.wrapper.set = function(){
			this.mfn.set.apply(this.mfn, arguments);
		};

		this.wrapper.clone = function(){
			return this.mfn.clone.apply(this.mfn, arguments);
		}
	},
	exec: function(ctx, arg1, arg2){
		console.info("Override me!");
	}
});