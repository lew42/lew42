view.append("str") --> view.appendView(View.Text("str")) --> view.content = txtView;
	=== View("str") --> view.append("str") --> view.content = View.Text("str")

view.append(fn) --> view.appendView(View(fn))
view.append({}) --> iterate
view.append(anotherView) --> view.appendView(anotherView);
view.append(one, two, three) --> iterate and append each


view.append(fn) --> throwaway?
view.append(View(fn)) --> encapsulate as its own el (div)
view.append(View.Frag(fn)) --> encapsulate as its own frag


The tricky part is using the fns as update fns AND.. 'build' fns.
If it's a 'throwaway' fn, it can't be used as update.
If it creates (.appends()) anything, it shouldn't be an update fn.

But, if it:
- adds/removes classes/attr w/ or w/o logic
- resets a TextNode 



view.set.value(fn)
--> run the fn, and see what happens
	--> if something was .appended within it, then we throw it away
	--> if nothing was appended/prepended/inserted, then we keep it as an update fn

View(function(){
	if (this.parent.someSwitch)
		this.addClass("someSwitch");
	else
		this.removeClass("someSwitch");

});

and you could manage deps:

View(['someSwitch', function(someSwitch){
	someSwitch ? this.addClass("someSwitch") : this.removeClass("someSwitch");
}], ['anotherValue', function(anotherValue){
	this.content.set(anotherValue);
}]);

We just need a way to dispatch events.. The dep name could be an event name...
We'd need to detect this ['deps', fn] pattern...

View("name", ["dep", "dep", function(){}] )

View({
	named: ["dep", "dep", function(){}]
})