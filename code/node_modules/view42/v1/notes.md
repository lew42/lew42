# View


Unique vs Decoupled Views:
There are advantages to having decoupled views:  mainly, we can create as many as we want.  But, there are advantages to coupled views.

1) Easy to implement

mod.render() --> new this.View()

2) Even if we have 1 unique view for an object (especially for dev views)

this.view.sub.text(this.someProp); // direct view updates
// This isn't the most flexible, but its probably the fastest
// no events, diffing, etc...
// In this pattern, we can have only 1 view per object... 
// Or, we could have

this.view1.sub.text(this.someProp);
this.view2.sub.text(this.someProp);

// Or, we could track all the views on each obj...

app.activePage.hide();
this.views.forEach(function(view){
	view.sub.text(this.someProp);
}.bind(this));
app.activePage.show();


- initialize()
	- autoGetCaptured();

- build()
	- becomeCaptor() --> global Captor chain
	- buildSelf()
	- restoreCaptor()
	- addCaptives() // global Captor can handle recapture/release logic, and only append 
	- buildChildren()

- buildChildren()
	- loop through captured children, and .build() them



## Alternate View Recipes

Helper functions are better than doubling down on the Classes...  But, maybe a secondary class could help.

One useful situation is the className + propName situation.

View("classNameAndPropName", ...);

and maybe with deps?

View("subViewName", ["parent"], function(){});


## Another potential approach:
Instead of passing a Prop object, we could create Ref objects... 
When adding a value to a view, we could indicate to use a relative reference:

View({
	sub: View(Ref("mod.something"))
});

The parent.sub would need its own .mod reference.

But then, we can update without much work?
Maybe we track property changes?  If previous mod.something !== mod.something...?


## Maybe I should juse use React?
I'm not sure how they do these things, but without Property objects, it makes it kinda hard...


With set_value(), we could trigger this.update.exec() --> 

With the Ref, can we setup direct updates in the background?  We still need to know when to update, but sub: View(Ref("mod.something")) could easily have an update function of its own:

parent.sub.update() --> render()? --> its default rerender would loop through all children, and render() them?

Only Refs need to be updated, and only if they change...

Ideally we skip all this, and link mod.set_something() ---> parent.sub's only child node.

How can set_something() notify, without its own event?  A dynamic event system...

set_something()
	--> this.emit("something", newValue);

and in sub: View(mod.prop("something"))

Hmm - that's like an inverted event.

sub = View();

mod.on("something", function(newValue){
	sub.set(newValue);
}); 

// VS

sub: View(mod.prop("something"))
--> returns a function that runs

basically...

var fn = function(newValue){
	return newValue;
};

mod.on("something", fn);


Hmm, it has to be an object?  Once a function is created, we can't modify it, and have no idea when its called.  Sure, we can call it, but that doesn't help anything.  We need the function to call something on the view.

What if mod.prop("something") returns sort of an event stream that can be listened to.

Then in the View, stream.then(function(){});

Maybe mod.on("anything") returns the dynamic event stream...

Event streams should be dynamic, so you can add cbs to an identifier without having to actually initialize a stream at that property.  AND, events/streams can double down on the namespace.  For example, we can't have this.myMethod as a fn AND this.myMethod as a "Q"... Now, the method could BE a Q, or be wrapped, and have a Q, or something.

But, I like this idea of dynamic streams.  No need to preinitialize... We can add listeners to something that may or may not ever happen....

And we can just use:

sub: View(mod.on("something")) --> returns the stream, and in this case, the stream passes (as its first argument to the CBs) the viewable value that becomes this View's only child.

How about, .when?  Doesn't make any more/less sense for binding to a property... 
But makes more sense, especially when composing streams:

mod.when("one").and("two").then(...)
--> the question would be, do you batch these?  like.. do you reset, so that you need a new change in both of them to trigger the response?

mod.when("one").or("two").then(cb) would be the less strict, run the cb whenever either of them changes

BUT, if we had live values, then you could setup an identifier to emit/resolve with the value, but only under certain conditions...

For example:

view.when("clicked")

Hmm... maybe we have .on and .when... 

What are the async things?
- Events:  instantaneous blips - like a gunshot
- Spans:  events with a duration (a start and stop).  Must end?
- Modes:  state - basically values that can change, but their value persists/exists between changes
- Streams:  chunks of data that are related, but 'stream' incrementally
- Promises:  events that have 2 outcomes, only resolve once, and will fire immediately (? or nextTick?) even after the resolution event has passed

When we 'compose', its impossible to compose 2 events, without some help.  You would more likely add conditions to events.  Also, if events have multiple outcomes, and/or multiple modes...

Also, related events:  like a request and a response.  The whole process defines the initial request and the response, if/when/how it happens.

These situations are like trees + timelines.  From any point, you can branch to a different outcome, for any amount of time.   



## Advantage of full re-rendering:
We don't need to bind to specific properties.  For example, if we need <span>{{mod.something}}</span>, and its deep within a view fn, then we need to somehow pass a reference to the Property object (which I don't have working all that well);

If we just access the property directly, sort of like React, then its not so bad...

View({
	one: View(mod.something)
});

And here's where the vdom diffing comes in.  Either you have 2 functions - one for building, and one for updating, in which the structure is very similar, yet you have to do things in different ways...

For example, the above snippet creates a view tree structure.  But we can't just rerender it to update...?

We'd really just want:

parent.one.text(mod.something);

In an update function, that reruns when either mod.something changes, or maybe just run it indiscriminantly when any mod.changes happen...

That's where the props come in.  If you pass:

View({
	one: View(mod.prop("something"))
});

Now we can setup the mod.prop("something").changed.then(parent.one.text);


## Could the view constructs diff themselves?

Basically, the first example above:

View({
	one: View(mod.something)
});

Could be re-run, while only affecting the changed parts?  This would be pretty tricky, when you might have a bunch of moving parts.  And, essentially, this is probably what React does.  Whether it builds the entire thing indiscriminantly, and then compares the two, or does it incrementally...

## Could I make a simpler .prop() system?

Rather than have a meta object for each property, I use a dynamic event system (.on(), .emit() ?), and .prop("propName", fn(){}) is shorthand for .on("propName.changed"), or something?


## Could async capturing be a problem?

Normally speaking, if we create a View("yo") inside a View's 'build' fn...  We expect it to be added immediately?  I don't see what kind of disadvantage could come?

As long as you *don't depend on the view tree while creating it...*

The view tree isn't built synchronously, so you can't check parent.children.length or something.

But, you should be in charge of creating each View's tree... And could handle this differently?

The sync: true flag could skip asynchronousCapture, so that the global Captor is instructed to add the views immediately as they come in?

The problem there, is that you'd have to use alternate strategies to prevent immediate execution of function-based views.

## It seems like a lot of work, just for sub views...

Are there any other advantages to this build batching?  Run the parent to completion, THEN build the children?  **One nice advantage, is that you can access siblings before they're actually created**:

Trying to think how that would work.  Basically, the entire parent function completes.. The only way in which one sibling can talk to another, is via the parent...

View(function(){
	this.one = View(function(){
		this.parent.icon; // icon should be available
			// if it doesn't have a build process, it could be fully available, with .el, for adding events

	});

	this.icon = View.Icon("beer");
});



View(function(){
	View("propName", ["deps", "here?"], { // deps are implied for... init?  If not (probably not), they should be declared as deps for a specific method
		myMethod: Method(["parent", "dep2", "parent.update", "parent.click"], function(){
			// defaults to parent.then
			// could also specify other events using a "."
			// depending on a property could be a promise-like event that runs only once when its set?
			// or, maybe it defaults to the change event, which encompasses the initial set
		}),
		one: View(function(){
			this.parent.two // will be available, but not yet built
		}),
		two: View(function(){
			this.parent.one // will be available, and should be built
		})
	})

	this.something = View("something");
});