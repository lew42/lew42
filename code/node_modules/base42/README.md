Maybe Base1 is all we need?
Put the rest in Mod/Module

# A nice thing about composition vs inheritance:

It's basically a question of, "where do you want your methods"?

Do you want mod.doIt()?  Or mod.sub.doIt()?


And - here's the thing.  Even though it seems like mod.doIt() might be much more convenient in a lot of cases, you can always "map"/alias functions with a simple:

mod.doIt = function(){
	this.sub.doIt();
};


# So composition is always better than inheritance?

Well, no.  With each mod, you're making an API.  The API might be as simple as:

new Mod(); // sometimes you need nothing more

But sometimes you'll have lots of configuration.

new Method({
	log: true,
	expand: false,
	args: false,
	ret: "inside",
	inline: true
}); // .. for example


The structure of your code is like its interface.  Hence I refer to it as an "API".  The API, or data structures you make (basically, just the names of those configuration options) all do something.

What does expand: false do?  There are a bunch of methods, what do they do?  Learning how a module works can be tough.  

It's important to remember that even the author of a module might not be able to explain it to himself/herself a few days later.

The point is, API design is very important.  Choosing names that are simple and make sense is tricky.

myMethodThatOpensFindsThenClosesSomething()

This isn't actually a terrible name.  But when things get more abstract:

I'm looking at a method I wrote named `arg_label_obj()`.  It's not great.

Anyway!  The point is (getting back to composition vs inheritance), that API is important, and remembering what these switches do is as well.

AND, even though you can patch functions through from parent to child, it's harder to patch properties through.  EVEN if you have set_* methods, which I do, it means having to do this:

set_expand(value){
	this.expandManager.expand = value;
	// or
	this.expandManager.set_expand(value); // if you're relying on the setter
}