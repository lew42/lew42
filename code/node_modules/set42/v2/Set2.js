var Mfn = require("mfn42/v4");
var is = require("util42").is;

var Set2 = module.exports = Mfn.extend({
	name: "Set2",
	api: function(){
		this.wrapper.sub = this.sub;
		this.wrapper.assignProp = this.assignProp;
	},
	exec: function(mod){
		for (var i = 1; i < arguments.length; i++)
			this.arg(mod, arguments[i]); // keep mod as first arg
		
		return mod; // important
	},
	arg: function(mod, arg){
		if (is.pojo(arg))
			this.obj(mod, arg);
		else
			this.value.call(mod, arg);
	},
	obj: function(mod, obj){
		for (var i in obj){
			this.prop(mod, i, obj[i]);
		}
		return mod; // used in .objProp()
	},
	prop: function(mod, prop, value){
		var currentValue = mod[prop],
			hasOwn = mod.hasOwnProperty(prop);
				// this order is important, because we touch the value before checking hasOwn, it triggers auto cloning

		if (is.fn(mod["set_" + prop])) {
			mod["set_" + prop](value);
			
		} else if (is.simple(currentValue)){
			this.assignProp(mod, prop, value);

		} else if (currentValue.set){
			currentValue.set.sub(currentValue, value, mod, prop);

		} else if (is.fn(currentValue)) {
			this.fnProp(mod, prop, value);

		} else if (is.obj(currentValue)){
			console.error("Not yet implemented");

		} else if (is.arr(currentValue)){
			console.error("Not yet implemented");

		} else {
			console.info("what are you?");
			this.assignProp(mod, prop, value);
		}
	},
	// use .assignTo, if present (default is undefined, only define it if ou want to)
	assignProp: function(mod, prop, value){
		if (value && value.set && value.set.assignTo){
			value.set.assignTo(value, mod, prop);
		} else {
			mod[prop] = value;
		}
	},
	fnProp: function(mod, prop, value){
		if (is.fn(value)) // override
			this.assignProp(mod, prop, value);
		else if (is.arr(value)) // apply array of args
			mod[prop].apply(mod, value);
		else // call with non array arg
			mod[prop].call(mod, value);
	},
	value: function(value){
		// !ctx here is the mod, not the mfn
		console.warn("not sure how to set this");
	},
	// consider extending Set, and overriding this method for Class.set, in order to prevent extra logic every time for non classes
	override: function(sub, value, parent, name){
		if (is.Class(sub) && is.Class(value)){
			parent.set.mfn.assignProp(parent, name, value);
			return true;
		} else if (value instanceof sub.constructor){
			parent.set.mfn.assignProp(parent, name, value);
			return true;
		} else {
			return false;
		}
	},
	// can be overridden for Classes, and other situations
	protect2: function(sub, value, parent, name){
		if (is.Class(sub)){
		
			if (parent.hasOwnProperty(name))
				sub.prototype.set(value);
			else
				parent.set.mfn.assignProp(parent, name, sub.extend(value));

			return true;

		} else if (!parent.hasOwnProperty(name) && sub.clone){
		
			if (sub.parent !== parent.proto) 
				console.warn("Consider only auto cloning direct children", parent.name, name);
		
			parent.set.mfn.assignProp(parent, name, sub.clone(value));
			
			return true;
		
		}

		return false;
	},
	protect: function(mod, value, parent, name){
		if (!parent.hasOwnProperty(name))
			console.warn("You could override this method, and instruct .set to .clone.  You shouldn't modify the prototype.")

		// by default, we don't protect, but warn you that you should
		return false;
	},
	// parent[name] === sub, incoming value
	sub: function(sub, value, parent, name){
		if (this.override(sub, value, parent, name))
			return;

		else if (this.protect(sub, value, parent, name))
			return;

		else
			this.arg(sub, value);
	},
	mockSetSub: function(wrapper, newValue, parent, propName){
		if (is.fn(newValue)){
			if (newValue.mfn)
				console.error("override with the mfn object itself, not the mfn.wrapper.");
			else {
				// plain old fn
				wrapper.mfn.value = newValue;
			}
		} else {
			Mfn.prototype.mockSetSub.apply(this, arguments);
		}
	}
});