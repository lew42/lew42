var is = require("util42").is;
/*
Not a bad pattern, but as opposed to Mfns, this isn't really "extendable":
- You can't modify the root fn.  You could make a new root, and copy the others over... but then they're not referencing the correct root (and the 'local' reference here is required for this to work)
- You can override the subs, because they are dynamically resolved at runtime.
*/
var assignFactory = module.exports = function(){

	var assign = function(){
		for (var i = 0; i < arguments.length; i++){
			var arg = arguments[i];
			if (is.pojo(arg)){
				for (var j in arg){
					assign.prop(this, j, arg[j]);
				}
			} else {
				assign.value(this, arg);
			}
		}
		return this;
	};

	// copied to Base3
	assign.prop = function(obj, name, value){
		if (is.fn(obj["set_"+name]))
			obj["set_"+name](value);
		else if (value && is.fn(value.assignTo)){
			value.assignTo(obj, name);
		} else {
			obj[name] = value;
		}
	};


	/*
	* obj.assign(nonPojo) --> assign.value(obj, nonPojo);
	* 
	* Could check if value.assignTo, and use that?
	* This would allow obj.assign(another); --> another.assignTo(obj) // anonymously...
	*/
	assign.value = function(obj, value){
		if (is.fn(obj.set))
			obj.set(value);
		else
			throw new Error("Must override assign.value() if you're not providing a .set() method.");
	};

	/*
	* Doesn't care what the args are, will iterate them anyway.
	* This is useful for iterating Class props (used in .extend);
	*/
	assign.dumb = function(obj, arg1, arg2){
		var arg;
		for (var i = 1; i < arguments.length; i++){
			arg = arguments[i];
			for (var j in arg){
				assign.prop(obj, j, arg[j]);
			}
		}
		return obj;
	}

	return assign;
};