var Base = require("base42/v2").Simple;
var is = require("util42").is;

var logger = require("log42");
var log = logger();


var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
var getParamNames = function(func) {
  var fnStr = func.toString().replace(STRIP_COMMENTS, '');
  var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
  return result || [];
}


var Method = module.exports = Base.extend({
	name: "Method4",
	args: "names",
	max_obj_props: 2,
	expand: true,
	instantiate: function(o){
		this.init_fn(o);
		this.init_wrapper();
		this.init();
	},
	init_fn: function(o){
		log("new Method", o);
		if (is.fn(o))
			this.fn = o;
		else if (is.obj(o)){
			if (o.assignTo && o.fn && o.fn.mfn === o){
				log("Method(Mfn(..)) pattern");
				o.assignTo(this, "fn");
			} else {
				this.assign(o);
			}
		}

		this.argNames = getParamNames(this.fn || function(){});
	},
	init: function(){},
	init_wrapper: function(){
		if (!this.fn){
			this.fn = function(){};
			console.warn("You probably want to wrap something");
		}

		var method = this;

		this.wrapper = function(){
			return method.exec(this, arguments); // notice this isn't applied, but just passed along
		};

		this.wrapper.method = this;
		this.wrapper.fn = this.fn;
		// this.wrapper.Method = this.constructor;

		// if (this.fn.mfn)
		// 	this.wrapper.mfn = this.fn.mfn;

		return this.wrapper;
	},
	exec: function(ctx, args){
		var log, ret, restore;
		
		if (ctx.log.override){
			// console.log("log.override");
			restore = true;
			ctx.log.override();
		}

		log = ctx.log;

		// open group
		if (this.expand)
			log.group.apply(console, this.methodLabel(ctx, args));
		else
			log.groupc.apply(console, this.methodLabel(ctx, args));

		// capture return value
		ret = this.fn.apply(ctx, args);
		
		// close group
		this.ret(ret, ctx, log);

		if (restore)
			logger.restore();
		return ret;
	},
	assignTo: function(obj, name){
		this.obj = obj;
		this.name = name;
		obj[name] = this.wrapper;
		return this;
	},
	methodLabel: function(ctx, args){
		// a wrapped method can be anywhere on a prototype chain, and be called by many different ctx
		var id = is.proto(ctx) ? ("prototype><" + ctx.id) : ctx.id;
		if (ctx.name){
				this.tmpName = ctx.name + "<" + ctx.constructor.name + "-" + id + ">" + "." + this.name;
		}
		return this.fnLabel(ctx, args);
	},
	arg_label: function(arg, label){
		if (this.literal_arg_values){
			label.push(arg);
		} else {
			if (is.Class(arg)){
				label.push(arg.name + "<" + arg.id + ">");
			} else if (is.fn(arg)){
				label.push("fn");
				if (arg.name)
					label.push(arg.name);
			} else if (is.obj(arg)){
				this.arg_label_obj(arg, label);
			} else {
				label.push(arg);
			}
		}
	},

	arg_label_obj: function(obj, label){
		var clone = Object.create(obj);
		var count = 0;
		if (obj.id){
			count++;
			Object.defineProperty(clone, "id", {
				value: obj.id
			})
			// clone.id = obj.id;
		}
		if (obj.name){
			count++;
			Object.defineProperty(clone, "name", {
				value: obj.name
			})
		}
		if (count < 1){
			for (var i in obj){
				if (i === "id" || i === "name" || i === "constructor")
					continue;

				if (!is.simple(obj[i]) && !is.fn(obj[i]))
					continue;

				if (is.fn(obj[i])){
					clone[i] = "<fn>";
				} else {
					clone[i] = obj[i];
				}
				
				
				count++;
				
				if (count >= 2)
					break;
			}
		}
		label.push(clone);
	},

	fnLabel: function(ctx, args){
		var name = this.tmpName || this.name || "anonymous";
		var argNames = this.argNames;

		var label = [ name + "(" ], argName;

		var arg;

		if (is.def(this.argLabel)){
			label.push(this.argLabel);
		} else if (argNames.length){

			// build argName: argValue, ...
			for (var i = 0; i < argNames.length; i++){
				argName = argNames[i];
				arg = args[i];

				if (argName)
					label.push(argName+":");
				
				this.arg_label(arg, label);

				if (i < argNames.length - 1){
					label.push(",");
				}
			}

			// add additional anonymous arguments
			if (i < args.length){
				label.push(",");
				for (i; i < args.length; i++){
					this.arg_label(args[i], label);
					if (i < args.length - 1)
						label.push(",");
				}
			}

		// the function defines no args, these are all anonymous args
		} else if (args.length){
			for (var j = 0; j < args.length; j++){
				this.arg_label(args[j], label);
				if (j < args.length - 1)
					label.push(",");
			}
		}
		label.push(")");
		return label;
	},

	ret: function(retValue, ctx, log){
		if (this.disable_return){
			log.end();
			return false;
		}
		if (is.fn(retValue)){
			retValue = retValue.toString().split("<")[0];
		}

		if (retValue === ctx){
			log.end();
			return false;
		}

		// this.contain can be undefined/"auto", true, or false
		if (!is.def(this.contain) || this.contain === "auto"){
			// log return value after the group
			if (is.def(retValue)){
				log("return", retValue);
				log.end();
			// or not at all
			} else {
				log.end();
			}
		} else if (this.contain === true){
			log("return", retValue);
			log.end();
		} else if (this.contain === false){
			log.end();
			log("  return", retValue);
		}

	}
}).assign({
	c: function(){
		var args = [].slice.call(arguments);
		return this.apply(null, [{ expand: false }].concat(args));
	}
});