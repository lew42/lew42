var Mod = require("mod42/v2");
var is = require("util42").is;
var track = require("track42");
var View = require("view42/v7");
var Q = require("q42");

var define = require("mixin42/define");
var cloner = require("mixin42/cloner");

var Sfn = Mod.extend({ name: "Sfn" }, 
	/* mixins */ define, cloner, 
{
	getter: function(ctx){
		var clone = this.protect(ctx);
		return clone ? clone.fn : this.fn;
	},
	initialize: function(){
		this.init_fn();
		this.init();
	},
	init_fn: function(){
		var self = this;
		this.fn = function(){
			if (this !== self.mod)
				console.error("Uh oh");
			return self.main.apply(self, arguments);
		};

		this.fn.sfn = this;
		
		this.fn.clone = function(){
			return this.sfn.clone.apply(this.sfn, arguments);
		};

		this.init_fn_setup();
	},
	init_fn_setup: function(){}, // ORP
	assignedTo: function(mod, name){
		// console.log('sfn.assignedTo', mod);
		if (!this.hasOwnProperty("mod") && this.adopt !== false){
			// console.log("defining sfn");
			this.mod = mod;
			this.name = name;
			this.init_define(this.mod, this.name);
		}
	},
	main: function(){}
});



// var Log = Mod.extend({
// 	name: "Log",
// 	initialize: function(){
// 		this.init_time();
// 	},
// 	init_time: function(){
// 		this.time = Date.now();
// 		console.log.apply(console, this.args);
// 	},
// 	render: function(){
// 		View(function(){
// 			View(this.time);
// 			for (var i = 0; i < this.args.length; i++){
// 				if (is.def(this.args[i]))
// 					View(this.args[i].toString());
// 				else
// 					View("undefined");
// 			}
// 		}.bind(this));
// 	}
// });


// var CaptorMixin = require("captor42"); // mixin

var LoggerView = View.extend({
	name: "LoggerView",
	collapsed: true,
	header: View.sub({
		icon: View.Icon.sub("plane"), // promote these as refs to the parent view?
		label: View.sub(function(){
			// console.log(this);
			// console.log(this.parent.parent.logr.id);
			this.append(this.parent.parent.logr.label);
		}),
		btn: View.Icon.sub("beer")
	}),
	body: View.sub({
		autoAppend: false,
		hide: [],
		content: function(){
			this.parent.logr.args && [].slice.call(this.parent.logr.args).forEach(function(arg){
				View(arg.toString());
			});
			this.parent.logr.logs.forEach(function(log){
				// console.log("sub log", log);
				log.render();
			});
		}
	}),
	behaviors: function(){
		if (this.logr.falsey)
			this.addClass("falsey");
		this.header.label.click(this.myToggle.bind(this));
		this.header.btn.click(function(){
			console.log(this.logr.bt);
		}.bind(this));
	},
	myToggle: function(){
		this.body.render().appendTo(this.$el);
		if (this.collapsed){
			this.removeClass("collapsed");
			this.collapsed = false;
			this.body.slideDown();
		} else {
			this.collapsed = true;
			this.addClass("collapsed");
			this.body.slideUp()
		}
	}
})

/*

The sfn .log that is an auto-cloner should be separate from a log that's created when we call .log...  I guess.  It doesn't really matter though.

We need a global logger, that acts as the captor.  I guess...?

*/


var captor; // this is the current captor

var Logger = module.exports = Sfn.extend({
	name: "Logger1",
	logs: [],
	initialize: function(){
		this.logs = [];
		this.previousCaptors = [];
		this.added = new Q();
		this.init_fn();
		this.init_time();
		this.init_args();

		if (this.appLogger)
			console.log("appLogger.label", this.label);

		this.init();
	},
	init_time: function(){
		this.time = Date.now();
		// console.log.apply(console, this.args);
		var name = this.mod ? this.mod.name : "?log?";
		this.label = name + " " + this.time;

		// console.log("label", this.label, this.args);

	},
	init_args: function(){
		if (this.args){
			this.label = "";
			for (var i = 0; i < this.args.length; i++){
				this.label += this.args[i] + " ";
			}
		}
	},
	init_fn_setup: function(){
		this.fn.custom = this.custom.bind(this);
		this.fn.logger = this;
		this.fn.render = this.render.bind(this);
		this.fn.group = this.group.bind(this);
	},
	group: function(str, fn){
		var log = new this.constructor({
			adopt: false,
			parent: this
		});

		// set this before add, because add --> added --> render
		log.label = str;

		this.add(log);


		log.becomeCaptor();
		fn();
		log.restoreCaptor();

		return log;
	},
	render: function(){
		// console.log("logr.render()", this.id)
		if (this.appLogger)
			console.log("appLogger.label", this.label);
		var view = new LoggerView({
			logr: this
		});
		this.added.then(function(log){
			if (view.body.isRendered){
				view.body.capture(function(){
					log.render();
				});
			}
		});
	},
	custom: function(){
		console.group("Logger.custom()");
		console.log("this", this);
		console.log("this.mod", this.mod);
		console.groupEnd();
	},
	log: function(){

	},
	add: function(log){
		log.getCaptured(this);
		this.logs.push(log);
		// console.log("logs", this.logs);
		this.added.exec(log);
		return log;
	},
	getCaptured: function(creator){
		if (captor && creator !== captor && !this.alreadyCaptured){
			this.alreadyCaptured = true;
			this.parent = captor;
			captor.add(this);
		}
	},
	becomeCaptor: function(){
		this.previousCaptors.push(captor);
		captor = this;
	},
	restoreCaptor: function(){
		captor = this.previousCaptors.pop();
	},
	main: function(){
		return this.add(new this.constructor({
			args: arguments,
			adopt: false
		}))
	}
});