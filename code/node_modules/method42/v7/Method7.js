var Base2 = require("base42/v2");
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
var getParamNames = function(func) {
  func = func || function(){};
  var fnStr = func.toString().replace(STRIP_COMMENTS, '');
  var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
  return result || [];
}


var Method = module.exports = Base2.extend({
	constructor: function Method(){
		this.instantiate.apply(this, arguments);
	},
	set: set,
	set_: function(value){
		if (is.bool(value)){
			this.set_log(value);
		}
	},
	set_log: function(bool){
		// console.info("Method.set_log", bool);
		if (bool) this.log = this.logger.log.active;
		else this.log = this.logger.log.noop;
	},
	instantiate: function(o){
		this.set.apply(this, arguments);
		this.instantiate_settings();
		this.instantiate_log();
	},
	initialize: function(){
		this.argNames = getParamNames(this.fn);
	},
	instantiate_settings: function(){
		if (this.logger && this.logger.method[this.name])
			this.set(this.logger.method[this.name]);

	},
	instantiate_log: function(){
		// in case nobody has configured it, it'll be undefined as of this point
		// the default .methods instance is an edge case - it doesn't have a .logger - it doesn't need a .log (it'll never be used by itself)
		if (!this.hasOwnProperty("log") && this.logger) 
			this.set_log(true);
	},
	exec: function(fn, ctx, args){
		this.before.apply(this, arguments);

		// debug here
		this.returnValue = fn.apply(ctx, args);

		this.after();
		return this.returnValue;
	},
	before: function(fn, ctx, args){
		if (fn !== this.fn) console.error("fn mismatch");
		// if (ctx !== this.ctx) console.error("ctx mismatch");

		// console.log(ctx, this.ctx);

		this.ctx = ctx;
		this.arguments = args;


		if (this.return !== "inline"){
			if (this.expand === false)
				this.logMethod = "groupCollapsed";
			else 
				this.logMethod = "group";
			
			this.open();
			this.opened = true;
		}
	},
	open: function(){
		this.log.fm(this.logMethod, 
			this.log.obj(this.ctx),
			"." + this.name + "(",
			this.logArguments()
		)();
	},
	after: function(){
		if (this.opened)
			this.log.end();
	},
	logArguments: function(){
		var flogs = [];
		for (var i = 0; i < this.arguments.length; i++){
			flogs.push(this.log)
		}
		return this.log.f()
	},
	// method doesn't do anything w/o proxy...
	// setting methodName: false could mean proxy && squelch...
	getProxy: function(){
		if (!this.fn)
			console.error("must provide fn to proxy");

		if (!this.ctx.log.isActive || !this.log.isActive){
			// console.warn("huh?", this.ctx.log.isActive, this.log.isActive);
			// when log: { method: { name: false }}, then method.set_log(false)...
			// we can't squelch, then...
			return this.fn;
		}

		this.proxy = new Proxy(this.fn, {
			apply: this.exec.bind(this)
		});

		return this.proxy;
	}
});