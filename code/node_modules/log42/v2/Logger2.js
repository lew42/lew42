var Base = require("base42/v4");
var is = require("util42/is");

var noop = function(){};

var ConsoleLogger = Base.extend({
	name: "ConsoleLogger1",
	methods: ["log", "group", "debug", "trace", "error", "warn", "info"],
	initialize: function(){
		this.init_logger();
	},
	init_logger: function(){}
});

var EnabledConsoleLogger = ConsoleLogger.extend({
	name: "EnabledConsoleLogger1",
	init_logger: function(){
		this.logger = console.log.bind(console);
		this.logger.type = "active";
		this.logger.on = true;

		this.methods.forEach(function(method){
			this.logger[method] = console[method].bind(console);
		}.bind(this));

		this.logger.groupc = console.groupCollapsed.bind(console);
		this.logger.end = console.groupEnd.bind(console);

		this.logger.close = function(fn, ctx){
			fn.call(ctx);
			this.end();
		};
	}
});

var DisabledConsoleLogger = ConsoleLogger.extend({
	name: "DisabledConsoleLogger1",
	init_logger: function(){
		this.logger = noop;
		this.logger.type = "noop";
		this.logger.on = false;
		this.methods.forEach(function(method){
			this.logger[method] = noop;
		}.bind(this));

		this.logger.groupc = noop;
		this.logger.end = noop;
		this.logger.close = function(fn, ctx){
			fn.call(ctx);
		};
	}
});
var clone = function(base, ext){
	var arg, extProp, baseProp;

	// protect the base (in this case its going to be a shared prototype reference)
	base = Object.create(base);

	for (var i = 1; i < arguments.length; i++){
		arg = arguments[i];
		for (var j in arg){
			extProp = arg[j];
			baseProp = base[j];
			if (is.obj(extProp) && is.obj(baseProp)){
				base[j] = clone(baseProp, extProp);
			} else if (is.Class(baseProp) && is.pojo(extProp)) {
				base[j] = baseProp.extend(extProp);
			} else {
				base[j] = extProp;
			}
		}
	}
	return base;
};
var Logger = module.exports = Base.extend({
	name: "Logger2",
	initialize: function(){
		this.active = new EnabledConsoleLogger().logger;
		this.noop = new DisabledConsoleLogger().logger;
		
		this.active.logger = this;
		this.noop.logger = this;

		console.warn("this is super confusing... make mod.log.on the boolean (true for active logger, false for noop).  then make mod.log.noop the noop log fn, and mod.log.active the active log fn...")
		this.active.active = this.active;
		this.active.noop = this.noop;

		this.noop.active = this.active;
		this.noop.noop = this.noop;

		this.active.label = function(mod){
			return mod.name + "{" + mod.constructor.name + "-" + mod.id + "}";
		};

		this.noop.label = noop;
	},
	setter: function(value){
		// .setter fn gets assigned to the parent, as .set_log()
		// `this` is the parent, NOT the Logger instance
		if (is.bool(value)){
			if (value){
				// enable
				// I think I have to hard-code the property name here, unless I want to create a scope-based binding
				this.log = this.log.active;
			} else {
				// disable
				this.log = this.log.noop;
			}
		} else if (is.pojo(value)){
			// console.log("set_log pojo", value);
			if (is.def(value.log)){
				if (value.log){
					this.log = this.log.active;
				} else {
					this.log = this.log.noop;
				}
			}
			// console.log(this._log);
			// and
			this._log = clone(this._log, value);
			// console.log(this._log);
		} else if (is.fn(value) && value.logger && value.logger instanceof Logger){
			this.log = value;
		}
	}
});
