var Assign1 = require("../v1");
var is = require("util42").is;

var Assign2 = module.exports = Assign1.extend({
	name: "Assign2",
	init: function(){
		this.init_define();
	},
	init_define: function(){
		var assign = this;

		if (!this.target) return;

		Object.defineProperty(this.target, 'assign', {
			get: function(){
				if (this.hasOwnProperty('assign'))
					return assign.fn;
				else
					new Assign2({
						target: this
					});
			},
			set: function(){
				console.warn("don't do that");
			},
			configurable: true
		});
	},

});

/*
The idea here, is that we have a Mfn that's bound to the object, and reinstalls itself any time its not an own property.  That way, assign.target can always be referenced - even though we already have it.

Maybe I make a slightly different Mfn recipe...?  This is more like the sfn recipe.

Anyway, let's just get this working.

So, the assign function will be the single entry point for this Prop experiment.

1) Create the Obj view
2) Create Props and Methods upon assignment, which each have Views that interact with the Obj view

Mmmm yes.  Here we go.


** Important **
This is NOT a drop-in inspection library.  You *have* to use .assign for everything.

Is this path the best?
A) Auto-clone .assign, and "bind" it to the target?

Configuring everything with assign is probably not the best idea.

The alternative... 



Hmm.. these auto-cloners are pretty cool.  Rather than use .props and an auto-protect system, I could just use auto-cloners.

Even for arrays and pojos...

Just install them as auto-cloners, and be done with the whole dilemma.  They automatically protect themselves... 

It might not be the fastest way, but it seems like a really simple way.

The next question:  DO WE NEED .PROPS?
If cloning was the ultimate reason, then probably not.
But, if we definitely want to have Property objects... All the configuration, events, etc, pass through those.

So, whether we do auto-cloner Properties, or use a protection function, doesn't really matter much.  It's either protect now, or protect later...


Anyway - I think I can setup most of this functionality without much of the .set nonsense.  The only thing you really need is the .assign.assignment operation/hook.


So, instead of trying to abstract everything, and make it inaccessible, just to keep a slightly smaller API/namespace .. that' stupid.

OK - So.  Now, here we go.  Alright, and now...

.props should store all the props, it's stupid not to.
.prop() can be the auto-upgrade fn, per uszhe

11:00am
Try and make ProtoProps?
A)  AutoCLonerProtoProp:  clones itself on set if !hasOwn
B)  ProtectedProps:  protected upon inst/extend using protect fn


This might be a good idea:
I want .set({ assign: { whatever: [] } }) to be a fallback to a no-nonsense, just fucking assign it functionality.

Can .set still use .assign, and we route much of the instrumentation through assign?

The use case is that empty array - whether to auto-upgrade it.  I think 

Mod({
	arr: [] // uses .set, and .set can auto-upgrade it to an auto-cloner?
		//  maybe a RubberProp (it's wearing a 'rubber', aka protection, get it?)
});

RubberProps seem like a minor performance cost for a simplicity gain.  Let's try it.


So, .assign()...
If we want to instrument, it should be decouple-able

Maybe even with the same Mod?  Maybe, a super simple, no-nonsense Mod might be in order.. But I'll have to try these out and see what sticks.

So, with log: true, we turn on instrumentation for all props/methods.

assign.assignment --> set_* or mod[name] = value;

Hmm.. one problem there, is that we either have to auto upgrade before or after the set_* anyway, or let the dev use this.assign("name", value) inside set_name() fn, which isn't the end of the world either.
	HANDLE THE BASIC CASE FIRST, IN ITS ENTIRETY, THEN COME BACK TO THE SET_* CASE...
	EITHER REMOVE SET_* FROM ASSIGN ENTIRELY, OR... 

	Quick note on this:  set_*() --> this.assign(*, value) won't work, it'll infinitely loop...

	There might be a need for this.assign("name", value, special = false), which skips the set_*, so then within set_*(), you can use this.assign(*, value, false);

 
























*/