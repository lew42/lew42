var Mod = require("mod42/v2");
var is = require("util42").is;


var Method = module.exports = Mod.extend({
	name: "Method2",
	set: function(value){
		if (is.fn(value))
			this.fn = value;
		else if (is.bool(value))
			this.log = value;
	},
	initialize: function(){
		this.count = 0;
		this.init_wrapper();
		this.init();
	},
	init_wrapper: function(){
		if (!this.fn){
			this.fn = function(){};
			console.warn("You probably want to wrap something");
		}

		var method = this;

		this.wrapper = function(){
			return method.exec(this, arguments); // notice this isn't applied, but just passed along
		};

		this.wrapper.wrapped = true;
		this.wrapper.method = this;
		this.wrapper.fn = this.fn;
		this.wrapper.Method = this.constructor;

		if (this.fn.mfn)
			this.wrapper.mfn = this.fn.mfn;

		if (this.fn.clone){ // for mfn
			// console.warn("Attempting to wrap a mfn..");
			this.wrapper.clone = function(){
				return new this.Method(this.mfn.clone.apply(this.mfn, arguments));
				// I think we can Object.create...
			};
		}


		return this.wrapper;
	},
	exec: function(ctx, args){
		var ret;
		console.group(this.name);
		ret = this.fn.apply(ctx, args);
		console.groupEnd();
		return ret;
	},
	assignedTo: function(mod, name){
		this.mod = mod;
		this.name = name;
		mod[name] = this.wrapper;
	}
}).assign({
	method: function(){
		return this.apply(null, arguments).fn;
	}
});

// otherwise, if you say var method = Method.method, then the window becomes the ctx...
// !! but then this has to be re-bound on .extend...
Method.method = Method.method.bind(Method);