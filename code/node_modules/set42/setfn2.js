var is = require("util42/is");
var setfn2 = function(){
	var arg;
	for (var i = 0; i < arguments.length; i++){
		arg = arguments[i];

		// pojo arg
		if (is.pojo(arg)){

			if (this._set_prop$){			
				// iterate over arg props
				for (var j in arg){
					if (this["set_"+j]){
						this["set_"+j](arg[j]);


					// maybe we intercept, and return true
					// if we don't return, or return false, then continue to do the default
					} else if (!this._set_prop$(arg[j], j)){
						// careful, setfn1 uses different arg vs arg[j] structure
							// (i refactored this one a little so _set_prop$ matches _set_prop)
						setfn2._set_prop.call(this, arg[j], j);
					}
				}
			} else {
				for (var j in arg){
					setfn2._set_prop.call(this, arg[j], j);
				}
			}

		// non-pojo arg
		} else if (this._set_value){
			this._set_value(arg);

		// oops
		} else {
			console.warn("not sure what to do with", arg);
		}
	}

	return this; // important
};

setfn2._set_prop = function(arg, j){
	// set_*
	if (this["set_" + j]){
		this["set_" + j](arg);

	// assign
	} else if (is.simple(this[j])){
		this[j] = arg;

	// allow overrides
	} else if (this[j] && this[j]._set_sub){
		this[j] = this[j]._set_sub(arg, this, j);

	// recursive protect/set
	} else if (this[j] && this[j].set) {
		// readopt?
		// only auto-clone non-references (aka, direct children)
		// if you set against a reference, it should probably throw an error... you shouldn't ever modify references with .set... 
		if (this.hasOwnProperty(j) || !this[j].clone)
			this[j].set(arg);
		else
			this[j] = this[j].clone(arg);

	// "assign" prop will just call assign
	} else if (j === "assign") {
		this.assign(arg);

	// existing prop is a pojo - "extend" it
	} else if (is.pojo(this[j])){
		if (this.hasOwnProperty(j))
			set.call(this[j], arg);
		else {
			this[j] = setfn2.call(Object.create(this[j]), arg);
		}

	// everything else, assign
	} else {
		// basically just arrays and fns...
		// console.warn("what are you", arg);
		this[j] = arg;
	}
};

module.exports = setfn2;