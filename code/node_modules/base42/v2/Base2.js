var Base1 = require("../v1");
var is = require("util42/is");
var Mod = require("mod42/v1");


var DevBase = module.exports = Base1.extend({
	createConstructor: function(){
		var DevBase = function(){
			var instance = this.__config.apply(this, arguments) || this;
			instance.instantiate.apply(instance, arguments);
			return instance;
		};
		return DevBase;
	},
	__config: function(o){
		this.__config_log(o);
		return this.__config_proxy(o);
	},
	__config_log: function(o){
		if (is.pojo(o) && is.def(o.log)){
			this.log = this.log.logger.clone(o.log).log;
			delete o.log;
		}
	},
	__config_proxy: function(o){
		if (this.log.isActive){
			return this.log.logger.getProxy(this);
		} else {
			return this;
		}
	}
	// clone: function(){
	// 	// !! Cloning this way might be dangerous:  auto-inheriting new properties of the underlying object could have unpredictable results
	// 	// BUT, if you only clone prototype.instances, then it's almost certain you won't be modifying prototypes (without extending/cloning/protecting)
	// 	var clone = Object.create(this);
	// 	clone = clone.config.apply(clone, arguments) || clone;
	// 	clone.instantiate.apply(clone, arguments);
	// 	return clone;
	// }
}).assign({
	extend: function(o){
		var opts = {}, Ext;

		// we need to configure the prototype, like we do for instances
		// we don't want the o.log property getting assigned to the prototype...
		// extract the o.log value before calling the Base1.extend
		if (is.pojo(o) && is.def(o.log)){
			opts.log = o.log;
			delete o.log;
		}
		
		// Base1.extend will assign all the args...
		Ext = Base1.extend.apply(this, arguments);

		// now we can handle the .log config, mocking the original `o` with `opts`
		if (is.def(opts.log))
			Ext.prototype.__config_log(opts);

		return Ext;
	}
});


var NOOP = function(){};

var getLogBase = function(on){
	var methods = ["log", "group", "debug", "trace", "error", "warn", "info"];
	
	// activeLogBase
	var active = console.log.bind(console);
	
	// noopLogBase
	var noop = function(){};
	
	active.isActive = true;
	noop.isActive = false;

	methods.forEach(function(method){
		active[method] = console[method].bind(console);
		noop[method] = NOOP;
	});

	active.groupc = console.groupCollapsed.bind(console);
	noop.groupc = NOOP;

	active.end = console.groupEnd.bind(console);
	noop.end = NOOP;

	active.close = function(fn, ctx){
		if (fn) fn.call(ctx);
		this.end();
	};
	noop.close = function(fn, ctx){
		if (fn) fn.call(ctx);
	};

	active.noop = noop;
	active.active = active;
	noop.active = active;
	noop.noop = noop;

	// `on` is passed in as a fn arg
	return is.def(on) && !on ? noop : active;
};



// method could extend logger
// although, method will clone its parent logger, so it can extend the .log...?

// BUT, the problem with binding everything to the logger, is that when we clone it, it can't be bound to the clone - we need it bound to the method...

// Maybe I can export the necessary building blocks that build/bind the .log, and just import them into the method, so that it can build it itself, and then bind it to itself...

/*
Base({
	log: {
		methods: {...},
		method: {
			methodName: {
				...
			}
		}
	}
});

config options:
methodName: true || false || {
	log: true || false || fn --> .shouldLog,
		// affects proxying?
		// if parent.log is on, and this has been turned off, should still proxy to squelch?
	args: true || false || ["on", "!off"] || {
		argName: true || false || "style: to; append: here;" || {
			str: "alternative label" || fn,
			style: ["append"] || "override"
		}
	}
}
*/

var Method = Mod.extend({
	constructor: function Method(){
		this.instantiate.apply(this, arguments);
	},
	set_: function(value){
		if (is.bool(value)){
			this.set_log(value);
		}
	},
	set_log: function(bool){
		if (bool) this.log = this.logger.log.active;
		else this.log = this.logger.log.noop;
	},
	instantiate: function(o){
		this.set.apply(this, arguments);
		this.instantiate_settings();
		this.instantiate_log();
		this.initialize();
	},
	instantiate_settings: function(){
		if (this.logger && this.logger.method[this.name])
			this.set(this.logger.method[this.name]);
	},
	instantiate_log: function(){
		// in case nobody has configured it, it'll be undefined as of this point
		if (!this.hasOwnProperty("log") && this.logger) // the default .methods instance is an edge case - it doesn't need a .log (it'll never be used by itself)
			this.set_log(true);
	},
	initialize: function(){

	},
	exec: function(fn, ctx, args){
		var ret;
		console.group(this.name + "(", args, ")");
		ret = fn.apply(ctx, args);
		console.groupEnd();
		return ret;
	},
	// method doesn't do anything w/o proxy...
	// setting methodName: false could mean proxy && squelch...
	getProxy: function(){
		if (!this.fn)
			console.error("must provide fn to proxy");

		if (!this.ctx.log.isActive || !this.log.isActive){
			console.warn("huh?");
			return this.fn;
		}

		this.proxy = new Proxy(this.fn, {
			apply: this.exec.bind(this)
		});

		return this.proxy;
	}
});


var Flog = Base1.extend({
	method: "log",
	all: "",
	constructor: function Flog(){
		this.instantiate.apply(this, arguments);
	},
	instantiate: function(){
		this.assign.apply(this, arguments);

		if (is.pojo(this.args[0])){
			this.assign(this.args[0]);
			this.args = [].slice.call(this.args, 1);
		}

		this.build();
	},
	build: function(){
		this.str = "";
		this.styles = [];
		
		for (var i = 0; i < this.args.length; i++)
			this.buildArg(this.args[i]);

		this.log = console[this.method].bind.apply(console[this.method], [console].concat([this.str], this.styles));
		this.log.flog = this;

		return this.log;
	},
	buildArg: function(arg){
		var styles;
		if (is.str(arg)){
			this.str += "%c" + arg;
			this.styles.push(this.all);
		} else if (is.arr(arg)){
			this.str += "%c" + arg[0];
			this.styles.push(arg[1] + ";" + this.all);
		} else if (is.fn(arg) && arg.flog){
			this.str += arg.flog.str;
			styles = arg.flog.styles.slice(0).map(function(style){
				return style + ";" + this.all; 
			}.bind(this));
			this.styles = this.styles.concat(styles);
		}
	}
});

/*
Ugh - method config is tricky

methodName: {
	args: function(){
		returns log.f();
	}
	arg: {
		argName: true || false || fn(){
			returns log.f();
		}
	}
}

If a methodName is set as an obj, such as the one above, and then override it with:

methodName: false

Then we lose all that config.  We want to convert that to { log: false }...


Mod({
	log: {
		method: {
			name: true || false || {
				log: true || false || nothing
			}

			name doesn't exist
				create new Settings
				+ true/false --> this.log = true
				+ { } --> 

			name is bool?  no it couldn't be...
			name is Settings object
				+ bool --> override .log prop
				+ {} --> merges it down
		}
	}
});
*/



var FNOOP = function(){
	return NOOP;
}

var Logger = Mod.extend({
	constructor: function Logger(){
		this.instantiate.apply(this, arguments);
	},
	api: {},
	method: {},
	methods: new Method(),
	set_log: function(bool){
		this.log = getLogBase(bool);
		this.log.logger = this;
	},
	set_: function(value){
		if (is.bool(value))
			this.set_log(value);
	},
	// method has to be a pojo, so it can have ANY prop name
	set_method: function(pojo){
		if (!this.hasOwnProperty("method"))
			this.method = Object.create(this.method);

		for (var i in pojo){
			if (is.bool(pojo[i]))
				pojo[i] = { log: pojo[i] };
			if (this.method[i]){
				if (this.method.hasOwnProperty(i))
					this.set.call(this.method[i], pojo[i]);
				else 
					this.method[i] = this.set.call(Object.create(this.method[i]), pojo[i]);
			} else {
				this.method[i] = pojo[i];
			}
		}
	},
	// creates a .log which is exported immediately
	initialize: function(){
		this.initialize_std();
		// build out the api, regardless of whether log.isActive
		this.initialize_api();
	},
	initialize_std: function(){
		this.log.active.obj = this.obj;
		this.log.noop.obj = FNOOP;

		this.log.active.f = this.f;
		this.log.noop.f = FNOOP;
	},
	f: function(){
		return new Flog({
			args: arguments
		}).log;
	},
	fm: function(method){
		return new Flog({
			args: [].slice.call(arguments, 1),
			method: method
		}).log;
	},
	initialize_api: function(){
		for (var i in this.api){
			if (is.fn(this.api[i])){
				this.log.active[i] = this.api[i];
				this.log.noop[i] = FNOOP;
			} else if (is.pojo(this.api[i])){
				if (this.api[i].active)
					this.log.active[i] = this.api[i].active;
				if (this.api[i].noop)
					this.log.noop[i] = this.api[i].noop;
			}
		}
	},
	excludes: ["log", "hasOwnProperty"],
	getProxy: function(mod){ // each method call, which creates a unique instance, can have its own reference to the created .proxy
			// in which case, it can't have a .proxy() getter.
			// so it's called .get_proxy()
			// maybe we name this .get_proxy() also, even though its not storing .proxy?
			// or call it getProxy(), which sort of makes that distinction
		if (typeof Proxy !== "undefined"){
			return new Proxy(mod, {
				get: this.getter.bind(this)
			});
		} else {
			console.warn("Proxy is undefined.");
			return mod;
		}
	},
	getter: function(ctx, prop){
		const value = ctx[prop];

		if (is.fn(value) && this.excludes.indexOf(prop) === -1){
			return this.methods.clone({
				logger: this,
				ctx: ctx,
				fn: value,
				name: prop
			}).getProxy();
		} else {
			return value;
		}
	},
	// use this to construct this.log, and methods can use it to get a copy that they can customize
	build: function(){
		var log = console.log.bind(console);
		// add the standard fns 
		// and the custom api
		// also create the noop api for std and custom
		return log;
	},
	clone: function(){
		var clone = Object.create(this);
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
});

DevBase.prototype.log = new Logger(false).log;