var Mfn = require("mfn42");
var is = require("util42").is;

var SetMfn = module.exports = Mfn.extend({
	name: "SetMfn",
	instantiate: function(){
		if (this.set)
			this.set.apply(this, arguments);
		else
			this.assign.apply(this, arguments);
		
		this.init();
	},
	main: function(mod){
		for (var i = 1; i < arguments.length; i++){
			this.arg(mod, arguments[i]); // keep mod as first arg
		}
		return mod; // important
	},
	/* change this to objSpecial, and put the props[prop] override in that method, and then revert back to plain this.obj() for pojos*/
	arg: function(mod, arg){
		if (is.pojo(arg))
			this.obj(mod, arg);
		else
			this.other(mod, arg);
	},
	other: function(mod, arg){
		this.value.call(mod, arg);
	},
	obj: function(mod, obj){
		for (var i in obj){
			this.prop(mod, i, obj[i]);
		}
		return mod; // used in .objProp()
	},
	prop: function(mod, prop, value){
		// this should work for pojos...so no funny business

		var currentValue = mod[prop],
			hasOwn = mod.hasOwnProperty(prop);

		// should probably move these to .special, so a pojo can have set_* functions that aren't invoked?
			// if props[set_*], then it would be a Prop object, not a fn...
			// should pojos get set/extended differently?
				// no invocation, but with deep extend?p
		if (is.fn(mod["set_" + prop])) {
			mod["set_" + prop](value);
			
		} else if (is.undef(currentValue)){
				// or is.simple() / non referential?
				// bool, num, str...
			this.assignProp(mod, prop, value);

		} else if (is.Class(currentValue)) {
			this.ClassProp(mod, prop, value);

		// then we can't override a cloneable property...
		// for example, if currentValue is a view, and we're trying to swap it out with another view...
		// this would just clone the original...
		} else if (currentValue.clone && !hasOwn){
			this.assignProp(mod, prop, mod[prop].clone(value));

		} else if (currentValue.set) {
			if (!hasOwn) console.error("uh oh");
			this.propWithSet(mod, prop, value);

		} else if (is.fn(currentValue)) {
			this.fnProp(mod, prop, value);

		} else if (is.obj(currentValue)){
			this.objProp(mod, prop, value);

		} else if (is.arr(currentValue)){
			this.arrProp(mod, prop, value);

		} else {
			this.assignProp(mod, prop, value);
		}
	},
	arrProp: function(mod, prop, value){
		if (!mod.hasOwnProperty(prop)){
			console.warn("always wear protection");
		}

		var current = mod[prop];
		if (is.arr(value)){
			current.push.apply(current, value);
		} else if (is.pojo(value)){
			// i think this should allow { push: ..., unshift: ..., etc }
			// unshift: [] to call (apply) without args?
			this.obj(current, value);
		} else {
			current.push(value);
		}
	},
	propWithSet: function(mod, prop, value){
		this.assignProp(mod, prop, mod[prop].set(value));
	},
	ClassProp: function(mod, prop, value){
		if (is.Class(value)){
			this.assignProp(mod, prop, value);
		} else if (mod.hasOwnProperty(prop)) {
			mod[prop].prototype.set(value);
		} else {
			// maybe handle [arr, of, values]
			if (is.arr(value))
				console.warn("array could be applied here");
			this.assignProp(mod, prop, mod[prop].extend(value)); // protect mod's prototype
		}
	},
	assignProp: function(mod, prop, value){
		mod[prop] = value;
	},
	fnProp: function(mod, prop, value){
		if (is.fn(value)){
			this.assignProp(mod, prop, value);
		} else {
			if (is.arr(value))
				mod[prop].apply(mod, value);
			else
				mod[prop].call(mod, value);
		}
	},
	// for obj props without .set... (usually a pojo, but not necessarily)
	objProp: function(mod, prop, value){
		if (is.obj(value)){
			if (mod.hasOwnProperty(prop))
				this.obj(mod[prop], value)
			else
				this.assignProp(mod, prop, this.obj(Object.create(mod[prop]), value));
		} else {
			console.warn("whoops");
		}
	},
	value: function(value){
		// ctx here will be the mod
		// a slight deviation from the norm, but I think it makes sense
		console.warn("not sure how to set this");
	},
	override: function(sub, value, parent, name){
		if (value instanceof sub.constructor){
			parent.set.mfn.assignProp(parent, name, value);
			return true;
		} else {
			return false;
		}
	},
	sub: function(sub, value, parent, name){
		if (!this.override(sub, value, parent, name)){

			// clone/extend and override?
			if (!parent.hasOwnProperty(name)){
				if (is.Class(sub)){
					parent.set.mfn.assignProp(parent, name, sub.extend(value));
				} else if (sub.clone){
					parent.set.mfn.assignProp(parent, name, sub.clone(value));
					
				}
				
			}

			// just continue with normal .set
			this.arg(sub, value); // ?

		}
	}
});

var set = SetMfn().fn;

SetMfn.set = set;
SetMfn.prototype.set = set;