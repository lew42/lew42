We can initialize/build upon adoption...

this.append({
	sub: View(fn(){ })
});

In which case the fn is semi-synchronous.

However, doing a full delay might be better anyway, to access siblings.

For example, if we then do:

if (condition){
	this.append({
		another: View(...)
	});
} else {
	this.append({
		another: View2(...)
	})
}

If, inside the first `.sub`, we want to access this.parent.another, it won't be ready, unless we wait until after they've been created.

If these dependencies happen in the right order (a subsequent child depends on a previous child), then we're find - no probs.  But if a previous child depends on a subsequent child, you'd have to then call an update function afterwards.  I suppose that's not a major problem... 

And, the `.another` could call `this.parent.sub.update_something()`.  This makes a strongly coupled view, but.. that's the point.