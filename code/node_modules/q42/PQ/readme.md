A "PromiseQ" could be promisified:
- For every .exec, we use Promise.all(cbs.map((cb) => cb()) )

Then we get something like:

pq.append(cb)
pq.exec().then()

A priority system might be useful

pq.last()
	// as opposed to .append, which immediately adds it
	// .last could optionally take a priority:
	.last(priority)
	priority defaults to 0
	higher priority means that it happens last-er

pq.first()


PQS
PromiseQ-Sequential
	CBs are delayed until the finishing of the next

PQP
PromiseQ-Parallel
	CBs don't wait for the previous

For either - we have the option of returning a Promise.
If we return a promise from a sequential PQ, then it means "wait to proceed"
Proceeding meaning, execution of the next CB

If we return a promsie from a parallel PQ, then it means "wait to finish"
Finishing meaning, resolution of the "all" promise.  This would be the default, based on my last pattern.



These options:
1) Ordering via priority:
	.first(priority)
	.append() // default
	.prepend() // optional
	.last(priority)

// if first or last is used, a priority should be required (fire a warning if not)

2) Delay next CB vs Delay final


OR - Just have 2 phases
By default, we have .add --> append or prepend
Then, we have .then, which is its own promisified cb array

It could even be nested Qs..

PQ.exec(){
	Promise.all(cbs.map((cb)=>cb()))
		.then(this.then.exec());
}

Basically, we just add a sub PQ to the PQ, in order to have 2 stages.
We could have as many stages as desired.

And, any PQ.set(fn) --> add, so from the mod level:

mod.set({
	init: fn(){}, // add to initPQ
	init: {
		then: fn(){} // add to sub initPQ
	}
});

With this dynamic system, you basically create named "hooks" to add things to.  init.then is just a PQ...

You could even add a PQ to init?

mod.set({
	init: {
		newPQ: PQ() // the question is, does this get auto-Qd?
		// if init.add(pq) --> the cb array should allow fns and Promises, and Qs, and PromiseQs
	},
	init: {
		existingPQ: fn || promise || Q || PQ // --> add
		existingPQ: {
			reset: fn
		},
		existingPQ: PQ({ // if existingPQ.submissive, always override
						 // if existingPQ.dominant, always append 
			override: true
		})
	}
})