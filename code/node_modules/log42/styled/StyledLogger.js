var Base2 = require("base42/v2");


/*

new StyledLogMethod
or

this.log.custom("nameOfMethod", { config });
 --> must assign the new method to both the enabled logger, and disabled logger as a noop

Let's focus on the enabled

this.log.obj() or whatever - these custom methods might just create an instance of a Logger object that generates the bound method...

So we might have a LoggerFactory that creates the .log instance, and then those instances have a .custom method, or something?


Strict log.whatever() signatures:
 - take certain args, in a certain order.

We then need to apply styling to them...

this.log.whatever(a, b, c, d)
	create a new StyledLogMethod
	add StyledLogArgs

Do we need drop-ins?  Probably not...  I don't know if any of the "formatted" data will be anything other than strings and numbers (strings).


Composability
To compose them externally, its easier to make/return the args on a console-bound method.
I suppose interally this is fine too - although just getting the args is all we need.

Most styled log fns will take very specific args.  Maybe an optional arg, or conditional argument signature, but I'm not sure if any will be open-ended, where they might take another 'styled' 



FORMATTED CONSOLE BOUND LOG FNS CAN HAVE .ARGS AND ALSO .CHILDREN?
Let's say a this.log.prop('objProp', this.objProp) comes in
It's an object, so we want to return an objProp logger...

This isn't a great example, because we can do whatever we need to internally.  But, if you were composing, you could potentially pass a flag that indicates to upgrade to a group, and add some child log statements...





Examples

// must have a name, but... should we always log the value first?
this.log.prop()

The issue here is for optional naming of values..
But, if you use the "var" log method, you're specifically saying, this is a named variable, and I'm going to give you the name


this.log.value(any) --> unnamed value, could be any type
	str, num, bool, undef, null, NaN, fn, arr, obj

// anonymous array
this.log.arr(arr <,name> <,num>)
	number of indices to show


really, names should be required... 

this.log.var("myVar", myVar);
this.log.obj(pojo, <, name ><, ["name", "or", "names"]>);


this.log.prop("myProp", this.myProp);
	
	// get line numbers? - adds a lot of complexity
	// also creates a lot of potential relabelling of file changes (especially with many small files...)
	// many times a method call is perfectly indicative of a file change, but once you start adding line numbers, you kinda need to add the file groups...
	// i had some good stuff going with those file groups though... they looked pretty good
	// i might want to throw in some blank log lines (optionally) to help break things up (especially for groups, to visualize the hierarchy...)
			// this can probably be done without file groups :()
	[#] this.myProp == "value"
				       123
				       	true | false
				       undefined, null, NaN, etc
				       <fn>
				       {}
				       []


this.log.id(this);


// composed
this.log.parent(this.parent);
--> this.parent == [i][parentName][ParentClass][#234]

*/
var StyledLogMethod = module.exports = Base2.extend({
	name: "StyledLogger",
	initialize: function(){},
	create: function(){
		// can be console.log, console.group, console.warn, etc
		var consoleMethod = console[this.method];

		// create the logger fn that's to be returned from the custom logger fn
		var logger = consoleMethod.bind.apply(consoleMethod, )
	}
});

