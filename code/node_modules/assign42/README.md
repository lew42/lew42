# assign

assign currently allows .assign("propName", propValue) as an alternative to the set-like .assign("one", {}, "three") all getting passed in and... 

Maybe .assign("value") gets passed to a very simple .set() method, that is basically an "ORP".  Then you could have some similar functionality.

In fact, that definitely seems like the way to go...

Base("something") --> base.set("something");

Then when defining a Class, you can say:

Class = Base.extend({
	set: function(value){
		this.value = value; // for example
	}
});

And then

Class("value") --> .set() --> .value = "value"

And when we upgrade .set to a more advanced form that still supports set: fn(value){ ... }, it should all be familiar.

MMmmm, good.

## assign.prop

The assign fn can have assign.prop available.  Its like the mfn subs (needs ctx as first arg), but maybe *added* to the assign fn, so you can call obj.assign.prop(obj, "propName", propValue);

## "add to" vs "copy to" vs "move to"

In computing and design, we have a number of options when we want to use something in another location.

### add to

By default, we should just reference the original.  The smart way to do this, is to automatically fork the reference if it gets edited, rather than apply edits back to the original.

When you say, "add A to B", the term 'add' could mean, 'make a reference to A and add it to B'.

If you make changes, and it does a smart/auto fork, should it be set up to automatically try to merge changes?  It could ask you when you're making your initial change how you want to fork it.

### copy to

If you want to sever the connection, you'd copy it.  It could still keep a link to the original, and by default, update you of changes, and allow merging.  But 'copy to' would set things up to NOT automatically merge changes through.

### move to

If you already have a reference to something, or an actual something, you might want to reorganize where it lives.  If you're moving it, it disappears from the original location, and moves to the new one.

In general, you might have most things stored in a global db, and only have references to them.  That way, you can just delete the reference without worrying about deleting the contents.