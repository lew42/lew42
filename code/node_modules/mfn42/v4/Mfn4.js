var Base = require("base42/v5");
var is = require("util42").is;

var Mfn = module.exports = Base.extend({
	name: "Mfn4",
	Logged: Base.prototype.Logged.extend({
		name: "LoggedMfn",
		Method: Base.prototype.Logged.prototype.Method.extend({
			name: "MfnMethod",
			// before: function(fn, ctx, args){
			// 	// fn is the Mfn's sub function
			// 	// ctx is the mfn instance
			// 	// we need to get the parent mod from args...?
			// 	// but that relies on the mod being in the first position, which isn't always the case (set.value, for example)
			// 	// console.log(args);
			// 	this.open(fn, ctx, args);
			// }
		})
	}),
	settable: true,
	eval: true,
	set: { // fake it till you make it
		mfn: {
			assignTo: function(self, parent, name){
				debugger;
				self.wrap(parent, name);
			}
		}
	},
	initialize: function(){
		this.makeWrapper();
	},
	makeNormalWrapper: function(){
		var mfn = this;

		
		// this fn signature is different for Mfn and simple method wrappers
		this.wrapper = function(){
			// `this` is the parent mod that the wrapper is assigned to
			if (this.log.on){
				var previousLog = mfn.log;
				mfn.log = this.log;
				var proxy = new mfn.Logged({
					mod: mfn
				}).proxy();
				var ret = proxy.exec.apply(proxy, [this].concat([].slice.call(arguments)));
				mfn.log = previousLog;
				return ret;
			}
			// normal mfn execution
			return mfn.exec.apply(mfn, [this].concat([].slice.call(arguments)));
		};
	},
	makeEvaledWrapper: function(){
		// this name can't collide with 'this.name', otherwise the eval'd code thinks `mfn` was the function itself, since this.name was "mfn" in my test
		var $elf = this;

		// swap this out for production, this is just for stack trace
		this.wrapper = eval("(function " + this.name + "(){\r\n"
			+ 	"\treturn $elf.exec.apply($elf, [this].concat([].slice.call(arguments)));\r\n" 
			+ "})");
	},
	makeWrapper: function(){
		if (false && this.eval){
			this.makeEvaledWrapper();
		} else {
			this.makeNormalWrapper();
		}

		this.makeWrapper_();
	},
	makeWrapper_: function(){
		this.wrapper.mfn = this;

		if (this.settable){
			this.wrapper.set = {
				mfn: {
					sub: this.mockSetSub 
				}
			};
		}

		this.api(); // orp
	},
	api: function(){},
	mockSetSub: function(wrapper, newValue, parent, propName){
		// override
		if (newValue instanceof Mfn){
			console.info("overridding mfn");
			// even though this probably goes straight to newValue.set.assignTo, we'll give the parent a chance to instrument or whatever
			parent.set.assignProp(parent, propName, newValue);
		
		// protect?
		} else if (is.pojo(newValue)){
			if (parent.hasOwnProperty(propName)){ // maybe this is ok
				console.warn("Is this safe?  Are you sure the mfn is unique to this object?");
				wrapper.mfn.assign(newValue);
			} else { // protect.
				wrapper.mfn.clone(newValue).wrap(parent, propName);
			}
		} else {
			console.error("what to do");
		}
	},
	// exec logic could be dumped directly into the wrapper, which reduces call stack... 
	// leave this alone, for now
	exec: function(ctx, arg1, arg2){ /*implement here*/ },
	wrap: function(parent, name){
		if (this.hasOwnProperty("name") && this.name !== name){
			console.error("Name mismatch.  Once mfn is directly assigned, you probably don't want to inadvertently share it?  If you assign the same mfn.wrapper to 2 different objects, and later .set against that mfn, it will modify it in place - and because its a shared reference, both instances will be modified.");
		}
		this.name = name;
		this.makeWrapper(name); // depends on name!
		parent[name] = this.wrapper;
	}
});

Mfn.prototype.set_log({
	exec: {
		expand: true
	}
});