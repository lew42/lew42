var Base = require("base42/v1");
var Debug = require("base42/debug");
var is = require("util42").is;

var Method = require("method42/v6");

var Mfn = module.exports = Base.extend({
	name: "Mfn4",
	log: true,
	extendable: true,
	eval: true,
	makeNormalWrapper: function(){
		var method = this;

		// this fn signature is different for Mfn and simple method wrappers
		this.wrapper = function(){
			return method.exec.apply(method, [this].concat([].slice.call(arguments)));
		};
	},
	makeEvaledWrapper: Method(function(){
		// this name can't collide with 'this.name', otherwise the eval'd code thinks `mfn` was the function itself, since this.name was "mfn" in my test
		var $elf = this;

		// swap this out for production, this is just for stack trace
		this.wrapper = eval("(function " + this.name + "(){\r\n"
			+ 	"\treturn $elf.exec.apply($elf, [this].concat([].slice.call(arguments)));\r\n" 
			+ "})");
	}),
	makeWrapper: function(){
		if (this.eval){
			this.makeEvaledWrapper();
		} else {
			this.makeNormalWrapper();
		}

		this.makeWrapper_();
	},
	makeWrapper_: function(){
		this.wrapper.mfn = this;

		if (this.extendable){
			// mocks the .set functionality, so if we try to set against a mfn, it will clone itself (which is necessary, since it doesn't have a real .set algorithm...)
			this.wrapper.set = {
				sub: function(currentValue, newValue, parent, name){
					if (is.fn(newValue)){
						console.warn("absolute override (assign), or assign the incoming function to replace the existing .exec (formerly known as .main)")
					} else if (!is.pojo(newValue)){
						console.warn("not sure what to do here");
					}

					if (parent.hasOwnProperty(name)){
						console.warn("upgrade this to .set.  I don't think assign is fine here, though");
						currentValue.mfn.assign(newValue);
					} else {
						currentValue.clone(newValue).assignTo(parent, name);
					}
				}
			};
		}
	},
	// exec logic could be dumped directly into the wrapper, which reduces call stack... 
	// leave this alone, for now
	exec: function(ctx, arg1, arg2){ /*implement here*/ },
	wrap: function(parent, name){
		if (this.hasOwnProperty("name") && this.name !== name){
			console.error("Name mismatch.  Once mfn is directly assigned, you probably don't want to inadvertently share it?  If you assign the same mfn.wrapper to 2 different objects, and later .set against that mfn, it will modify it in place - and because its a shared reference, both instances will be modified.");
		}
		this.name = name;
		this.makeWrapper(name); // depends on name!
		parent[name] = this.wrapper;
	},
	assignTo: function(parent, name){
		this.wrap(parent, name);
	}
});