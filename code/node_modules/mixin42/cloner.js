var track = require("track42");
/*
deps:
	define mixin (defines a property on another object)
	.name: name of property, as defined using define
	.export: name of property to export

This is specifically a mixin for a Prop-like object.  That is, an object where this.name is the name of itself on its parent.  This mixin should probably go in the prop42 folder..
*/
module.exports = {
	getter: function(ctx){
		var clone = this.protect(ctx);
		return clone ? clone : this.value ? this.value : this;
	},
	setter: function(value, ctx){
		/* When we auto-clone and re-assign, then redefine, this gets triggered.  In those cases, a noop is fine.  But what if its a real assignment?  We should probably handle the reassignment differently.  Instead of passing through .assign, just call assignedTo manually... */
		console.warn("Override logic needs to go here");
	},
	protect: function(ctx){
		var clone;
		if (!ctx.hasOwnProperty(this.name)){
			if (!ctx.assign.mfn){
				console.error("cloner must be used with assign.mfn");
				return false;
			}
			clone = this.clone();
			// this needs to hit the .assignedTo, which it doesn't seem to be..
			clone.assignedTo(ctx, this.name);
			// ctx.assign(this.name, clone);

			return clone;
		}
		return false;
	},
	clone: function(){
		var clone = Object.create(this);
		track(clone);
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
};