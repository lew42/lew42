var Base2 = require("base42/v2");
var is = require("util42/is");

var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
var getParamNames = function(func) {
  func = func || function(){};
  var fnStr = func.toString().replace(STRIP_COMMENTS, '');
  var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
  return result || [];
};

var noop = function(){};
noop.noop = true;

var fnoop = function(){
	return noop;
};

fnoop.noop = true;


var container, lastContainers = [];

var MethodFlarg = Base2.extend({
	constructor: function MethodFlarg(){
		this.instantiate.apply(this, arguments);
	},
	isActive: true,
	instantiate: function(){
		this.set.apply(this, arguments);
		this.makeWrapper();
	},
	_set_value: function(value){
		if (is.bool(value))
			this.isActive = value;
		else if (is.fn(value))
			this.fn = value;
	},
	makeWrapper: function(){
		var self = this;
		this.wrapper = function(){
			return self.main.apply(self, [this].concat([].slice.call(arguments)));
		};
		this.wrapper.mfn = this;

		this.wrapper.clone = function(){
			return this.mfn.clone.apply(this.mfn, arguments).wrapper;
		};

		this.wrapper.set = function(){
			this.mfn.set.apply(this.mfn, arguments);
		};

	},
	main: function(method){
		if (this.isActive){
			return this.fn.call(method);
		} else {
			return "DO_NOT_LOG";
		}
	}
});

var Method = module.exports = Base2.extend({
	constructor: function Method(){
		this.instantiate.apply(this, arguments);
	},
	logMethod: "group",
	fnoop: fnoop,
	expand: false,
	_set_value: function(value){
		if (is.bool(value)){
			this.set_log(value);
		}
	},
	inline: function(){
		this.log.f(this.method(), "=>", this.returnValue);
	},
	set_log: function(value){
		// console.info("Method.set_log", value);
		if (is.bool(value)){
			if (value) this.log = this.logger.log.active;
			else this.log = this.logger.log.noop;

			this.shouldLog = function(){
				return this.log.isActive;
			};
		} else if (is.fn(value)){
			this.shouldLog = value;
		}
	},
	instantiate: function(o){
		this.set.apply(this, arguments);
		this.instantiate_settings();
		this.instantiate_log();
		this.initialize();
	},
	initialize: function(){
		this.argNames = getParamNames(this.fn);
	},
	instantiate_settings: function(){
		if (this.logger && this.logger.method[this.methodName]){
			// console.log("method settings for " + this.methodName, this.logger.method[this.methodName]);
			this.set(this.logger.method[this.methodName]);
		}

	},
	instantiate_log: function(){
		// so, methods will have the .logger reference, eventually, but in the .method instances, its not hasOwn
		// maybe there's a better way to setup the default .log?
			// maybe we don't set it up until exec time, and set it to the context's .log
		if (!this.hasOwnProperty("log") && this.logger) 
			this.set_log(true);
	},
	exec: function(fn, ctx, args){
		this.before.apply(this, arguments);

		// debug here
		this.returnValue = fn.apply(ctx, args);

		this.after();
		return this.returnValue;
	},
	before: function(fn, context, args){
		// tracks the currently executing method
		this.logger.currentMethod.set(this);

		if (fn !== this.fn) console.error("fn mismatch");

		// if (context._$_$_isTarget)
		// 	debugger;
		if (context !== this.logger.proxy)
			console.warn("hmm");

		if (!this.log.isActive)
			console.error("implement squelching");
		// !! if !this.log.isActive, squelch
			// 1) don't log anything - the log methods on this object have .flog chaining, and so they can't run if !log.isActive
			// 2) set the ctx.log = ctx.log.noop;
			// 3) restore the ctx.log in .after();


		this.context = context;
		this.arguments = args;


		// if (this.parentMethod && this.parentMethod.context === this.context){
		// 	this.set({ ctx: false })
		// }


		if (this.return !== "inline"){
			if (this.expand === false)
				this.logMethod = "groupCollapsed";
			else 
				this.logMethod = "group";
			
			// hmm, this conditional check might not be necessary with the .fnoop pattern..
			if (this.shouldLog()){
				this.group();
				if (this.group !== this.fnoop)
					this.opened = true;
			}
		}
	},
	group: function(){
		this.log.fm(this.logMethod, this.ctx(), this.method())();
	},
	ctx: new MethodFlarg(function(){
		return this.log.mod(this.context);
		// return this.log.f(
		// 	// ["i", "font-weight: bold"],
		// 	// " ", 
		// 	[" " + this.context.name, "font-weight: normal"],
		// 	["{"+this.context.constructor.name+ "-" + this.context.id + "} ", "font-style: italic; color: #666"]
		// ).all("background: rgba(0,0,0,0.1); padding: 2px 0px;");
	}).wrapper,
	method: new MethodFlarg(function(){
		return this.log.f(".", this.name(), "( ", this.args(), " );").all("font-weight: normal");
	}).wrapper,
	args: function(){
		var flog = this.log.f();
		// debugger;
		for (var i = 0; i < this.arguments.length; i++){
			// if (this.arg[])
			// if (this.argNames[i])

				flog.f(this.arg(this.arguments[i], this.argNames[i]));
			
			if (i < this.arguments.length - 1)
				flog.f(", ");
		}
		return flog.build();

		// if this.argNames[i] && this.arg[this.argNames[i]]
			// then use that ()
		// else, use the default .arg(value [, name])
	},
	arg: function(value, name){
		return this.log.var(value, name).all("background: rgba(0,0,0,0.075); border-bottom: 1px solid rgba(0,0,0,0.075);");
	},
	name: function(){
		return this.methodName;
	},
	inline: function(){
		return this.method().s("=>")
	},
	after: function(){
		this.logger.currentMethod.restore();
		if (this.opened){
			this.log.end();

			container = lastContainers.pop();
		}
	},
	// method doesn't do anything w/o proxy...
	// setting methodName: false could mean proxy && squelch...
	getProxy: function(){
		if (!this.fn)
			console.error("must provide fn to proxy");

		/* Check ctx.log.logger.method.name  */

		if (!this.context.log.isActive && !this.log.isActive){
			console.warn("implement this");
			// console.warn("huh?", this.ctx.log.isActive, this.log.isActive);
			// when log: { method: { name: false }}, then method.set_log(false)...
			// we can't squelch, then...
			return this.fn;
		} else if (this.context.log.isActive && !this.log.isActive){
			// console.warn("implement squelching?");
			return this.fn;
			this.squelch = true;
		} else if (!this.context.log.isActive && this.log.isActive){
			// console.warn("implement this");
			return this.fn;
			this.amplify = true;
		}

		this.proxy = new Proxy(this.fn, {
			apply: this.exec.bind(this)
		});

		return this.proxy;
	}
});