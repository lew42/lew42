var Base = require("base42/v1");
var is = require("util42/is");

var set = require("set42/setfn1");
var Logger = require("log42/v3");


var lowerCaseFirstChar = function(str){
	return str[0].toLowerCase() + str.substring(1);
};

var Mod = module.exports = Base.extend({
	// createConstructor: function(){
	// 	return function Mod(){
	// 		this.instantiate.apply(this, arguments);
	// 	}
	// },
	// createConstructor: function(){
	// 	return function Mod(){
	// 		if (!(this instanceof Mod))
	// 			return new (Mod.bind.apply(Mod, [null].concat([].slice.call(arguments))));
	// 		var instance = this.__config.apply(this, arguments) || this;
	// 		instance.instantiate.apply(instance, arguments);
	// 		return instance;
	// 	};
	// },
	name: "Mod",
	/*
I think the _$_args: arguments method might be better than this, for detecting `new`?  Well, no - because then you're going to double-'new', if you actually use 'new'..  The only way to detect if you've actually used `new` is if it's an instance?

	> or its just designed to be used as a method, like this.something() is a constructor.  the contextual constructor pattern is good for this...
	> that could be combined with the args...

Maybe you put an indentifier on every prototype?

The prototype identifier would have to be...
* non-enum
* created before the createConstructor function runs, and hard-coded into the constructor?
	For example:  if this._$_$_id !== "xyZ823ev0", return new...

The one edge case, if you assign the constructor to self, or try to invoke the constructor directly:

this.constructor("yo");
// here, this._$_$_id will equal the proper prototype id...

But, this edge case can be handled, if we check if 

	// correction: no- I don't think that works
	// this.constructor(...) will not make a new instance, and we need it to

Constructor !== this.constructor && this._$_$_id !== "xyZ823ev0"
	return new Constructor({ _$_$_arguments: arguments })

BUT, then we have several cases to fall through to:
1) user used `new`, and we have real arguments
2) the auto-new feature was hit, and we have _$_$_arguments

If we handle those 2 cases, the only clash we might have, is if you actually want to use the _$_$_arguments property.
	*/
	createConstructor: function(o){
		var name = (o && o.name) || this.name + "Ext";
		o && delete o.name;
		eval("var " + name + ";");
		var constructor = eval("(" + name + " = function " + name + "(){\r\n\
		if (!(this instanceof " + name + "))\r\n\
			return new (" + name + ".bind.apply(" + name + ", [null].concat([].slice.call(arguments)) ));\r\n\
		var instance = this.__config.apply(this, arguments) || this;\r\n\
		instance.instantiate.apply(instance, arguments);\r\n\
		return instance;\r\n\
	});");
		return constructor;
	},
	__config: function(o){
		this.__config_log(o);
		return this.__config_proxy(o);
	},
	__config_log: function(o){
		if (is.pojo(o) && is.def(o.log)){
			this.log = this.log.logger.clone(o.log).log;
			delete o.log;
		}
	},
	__config_proxy: function(o){
		if (this.log.isActive){
			return this.log.logger.getProxy(this);
		} else {
			return this;
		}
	},
	instantiate: function(){
		this.set.apply(this, arguments);
		this.initialize.apply(this, arguments);
	},
	initialize: function(){},
	set: set,
	set_log: function(){
		this.log = this.log.logger.clone.apply(this.log.logger, arguments).log;
	},
	/*
	* Caveats to cloning:
	*  - properties can show through (live inheritance)
	*  - reinstantiating an object might be unpredictable - it depends on what kind of state your object has, and what happens in instantiate.  Also, if any external side effects.
	*/
	clone: function(){
		var clone = Object.create(this);
		clone = clone.__config.apply(clone, arguments) || clone;
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
}).assign({
	extend: function(o){
		var opts = {};

		// we need to configure the prototype, like we do for instances
		// we don't want the o.log property getting assigned to the prototype...
		// extract the o.log value before calling the Base1.extend
		if (is.pojo(o) && is.def(o.log)){
			opts.log = o.log;
			delete o.log;
		}
		
		// Base1.extend will assign all the args...
		// Ext = Base.extend.apply(this, arguments);
		var Ext = this.getConstructor(o);

		// Setup inheritance
		Ext.prototype = Object.create(this.prototype);
		Ext.prototype.constructor = Ext;
		// don't override .name if used differently
		if (this.prototype.name === lowerCaseFirstChar(this.name))
			Ext.prototype.name = lowerCaseFirstChar(Ext.name);

		// Set all arguments to the new prototype
		Ext.prototype.set.apply(Ext.prototype, arguments);

		// now we can handle the .log config, mocking the original `o` with `opts`
		if (is.def(opts.log))
			Ext.prototype.__config_log(opts);

		return Ext;
	}
});



Mod.prototype.log = new Logger(false).log;