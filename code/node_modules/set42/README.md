# Set

There are several cases:  **In fact, these cases are applicable to .assign too, so I should introduce them there**.

Mod(...)
	--> new Mod().set(...)
Mod.extend(...)
	--> Mod.extend().prototype.set(...)

mod.set(...)
Mod.set(...)
Mod.prototype.set(...)

## Unique cases, in addition to the basic ones above

parent.set({
	mod: ...
});

Mod({
	sub: ...
})
	--> new Mod().set({ sub: ... })
	=== new Mod().sub.set({}) // ??

	// these aren't EXACTLY the same
	// with the second version, the sub.set() has no awareness of the parent.
	// when we use parent.set({ sub: ... }), we can pass this awareness to the sub.set()

	// also, if we were to use parent.sub.set(..), there's no easy way to have 2 cases:
		// 1.  Override parent.sub = newValue
		// 2.  Modify the .sub directly

	// or, a 3rd case, which is something in between, or a combination of the two:
		// 3.  Protect the prototype chain:  clone the sub module, modify it, and 'override' or assign it on top of the existing sub

## The read-only problem

This is very helpful - we can have prototype modules that are shared among all instances.  And if we treat it as 'read only', we can get away with it (as long as we're sure not to modify it unintentionally by 1 instance, and inadvertently affect ALL instances).

But, what if we need a unique instance when we want to use it? 
Well - there are 2 types of 'protection':  the simplest form of protection just means, block the unintentional modification of the prototype chain.

But then there's the concept of a unique direct child.

This is kind of a hard concept:

If you have a sub module that protects itself when modified, it can still be in 'shared' mode - meaning all extensions/clones can use the modified version.  And this can happen anywhere in the chain:  we just protect the chain.

Ok, so the other case, is when a READ ONLY pattern won't work.  We need a UNIQUE sub module, if/when we need to use it.  So we'll take the same precautions and protect the prototype chain.  But in this case, WE NEED TO PROTECT THE PROTOTYPE CHAIN WHEN WE **READ** THE SUB MODULE, not just when we modify it.  In other words, the sub module can't be shared.  

The best examples are nested modules that are direct children of the parent module.  

## Trouble lurks ahead

It's easy to see that if we only protect when we're modifying w/ .set, we completely miss out on a very common pattern:

parent.sub.something(); // --> we're not 'modifying' the sub module directly.  We're not using .set to modify its properties or methods.  This is basically a read-only process, until we execute the function.  

## I suppose the only time this really matters, is when you have a .parent reference - when you've adopted

So, let's say a child module has been adopted.  The parent may or may not have a direct handle to it, but probably has some sort of reference (in a one-off array, or obj, or whatever).

When we extend, and use .set({ sub: ... }), we can accurately clone and re-establish the parent reference via reassigning the prop: parent.set.mfn.assignProp --> subClone.set.mfn.assignTo(parent).

BUT, that's only half the battle.  Because again, what happens if we never touch the sub module?  If we need to call a method on it..

Let's take a stupid simple composition example:

Creature
	.jumper
		.jump() --> transforms the <x,y,z> position of the creature
			that means creature.jumper.jump(creature), OR
			creature.jumper.creature === creature 
				&& creature.jumper.jump() 
					--> this<jumper>.creature // we don't need to pass creature to the jump() method, because we have a reference to the creature on the jumper obj, which is `this` for jump().

SO!  A very simple parent reference situation.  Making your modules generic/relative by taking the parent reference with every method isn't a terrible solution, but then you add an argument to every object.

I can't really judge the two - maybe its way easier just to do that.  But, to me it makes the code less readable.  The .jumper.jump() abstraction is already kinda tricky...

Although, you could just map it with
creature.jump() --> this.jumper.jump(this);

> The major benefit to 'real' sub modules, is that you can
 - make the syntax really simple and clean
 - rely on any number of references, rather than a whole bunch of fn args
 - and for something like a view, having `this.parent` always available is really handy
 - and, for views, and sub views, you could alias any number of related views and objects, so that you can then just call methods:  this.something() without having to remember the long fn arg syntax
 - you can see ugly-long fn args in Set.  even 4 args makes it much harder to call a funcion - you'll never remember the right order
 - and frankly, it's hard to have a consistent order...

##  ANYWAY, the problem with protecting only on set: 

If we have a child view, for example... We need to rely on it being unique.  We don't want to modify the prototype chain.  

**To do this, we need to either clone on every "get", which has been my first approach**.

Or, you need to batch the cloning.  I think this is a better approach.

