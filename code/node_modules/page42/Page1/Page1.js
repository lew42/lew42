var Mod1 = require("mod42/Mod1");
var View = require("view42");
var util = require("util42");
var Path = require("path42");

var Cols = require("grid").Cols;

var PageView = Cols.extend({
	name: "PageView",
	addClass: "page"
});

var Promise = require("bluebird");

var Page1 = module.exports = Path.extend({
	View: View,
	instantiate: function(){
		this.pages = [];
		this.cbs = [];
		return Mod1.prototype.instantiate.apply(this, arguments);
	},
	initialize: function(){
		// this.render();
	},
	set_route: function(route){
		this.route = route;
		route.page = this;

		if (this.route.part.length){
			this.set_name(this.route.part);
		}

		route.then(function(){
			this.activate();
		}.bind(this));
	},
	getParentPageFromRoute: function(){
		// console.group("getParentPageFromRoute", this.name);
		var route = this.route.parent;
		while (route){
			if (route === this.app.route){
				// we don't want to parent to the homepage, so switch this to the app itself...
				// console.log("parent: app");
				this.app.add(this);
				route = false;
				break;
			}
			if (route.page){
				// console.log("parent", route.page.name);
				route.page.add(this);
				route = false;
				break;
			} else {
				route = route.parent;
			}
		}
		// console.groupEnd();
		return false;
	},
	preview: function(){
		// when captured, this view needs to gain access to the current pageview's right column
		View("page preview").click(function(){
			this.activate();
		});
	},
	render: function(){
		// if (this.parent && this.parent.view && this.parent.view.right){
		// 	this.parent.view.right.captureFn(function(){
		// 		this.view = new this.View({
		// 			left: this.content.bind(this)
		// 		})
		// 	}.bind(this));
		// 	this.rendered = true;
		// } else {
		// 	console.warn("non-captured page view");
		// 	// this.view = View(this.route.path, "non-captured");
		// }

		this.app.view.right.captureFn(function(){
			this.view = new this.View(this.content.bind(this));
		}.bind(this));
		this.rendered = true;
	},
	content: function(){
		View(this.name).addClass("card");
	},
	activate: function(){
		if (!this.isActiveNode()){
			if (this.root.activeNode !== this.app)
				this.root.activeNode.deactivateSelf().then(this.activateSelf.bind(this));
			else
				this.activateSelf();
		}
	},
	activate2: function(push){
		if (push !== false)
			this.push();

		// console.log("activate", this.name);
		if (this.isActiveNode()){
			console.warn("already active page");
			return Promise.resolve();
		} else if (this.isActive()){
			return this.activeChild().deactivate()
				.then(function(){
					// I think we're guaranteed to be rendered here, also..
					// no need to transition here, it's already active, and only needs to be marked as activeNode
					this.root.activeNode = this;
				}.bind(this))
				// .then(this.push.bind(this));
		} else if (!this.parent.isActiveNode()){
			return this.parent.activate(false)
				.then(this.activateSelf.bind(this))
				// .then(this.push.bind(this));;
		} else {
			// console.log("parent", this.parent.name, "isActiveNode")
			return this.activateSelf()
				// .then(this.push.bind(this));
		}
	},
	push: function(){
		this.route && this.route.activate();
	},
	in: function(){
		return this.view.$el.fadeIn().promise();
	},
	activateSelf: function(){
		// console.log("activateSelf", this.name);
		if (!this.rendered){
			this.render();
			this.view.hide();
		}
		this.root.activeNode = this;
		this.push(); // this has to come after the above line
		return this.in();
		// return Promise.all(this.cbs.map(function(cb){
		// 	return cb.call(this);
		// }.bind(this)));
	},
	deactivate: function(){
		// console.log("deactivate", this.name);
		if (this.isActiveNode()){
			return this.deactivateSelf();
		} else if (this.isActive()){
			return this.activeChild().deactivate()
				.then(this.deactivateSelf.bind(this));
		} else {
			console.warn("not active");
			return Promise.resolve();
		}
	},
	out: function(){
		return this.view.$el.fadeOut().promise();
	},
	deactivateSelf: function(){
		// console.log("deactivateSelf", this.name);
		return this.out();
		// return Promise.all(this.dcbs.map(function(cb){
		// 	return cb.call(this);
		// }.bind(this)));
	},
	then: function(cb, dcb){
		if (cb) this.cbs.push(cb);
		if (dcb) this.dcbs.push(dcb);
		return this;
	},
	add: function(page){
		if (!(page instanceof Page1))
			console.warn("not a page");

		page.parent = this;
		page.app = page.root = this.root;

		this.pages.push(page);

		if (!this[page.name])
			this[page.name] = page;
	},
	jsName: function(name){
		var sname = util.sanitizeString(name);
		return sname.replace("-", "_");
	},
	set_name: function(name){
		this.name = this.jsName(name);
	},
	logger: function(){
		console.group(this.name);
		console.log("parent", this.parent && this.parent.name);
		for (var i = 0; i < this.pages.length; i++){
			this.pages[i].logger();
		}
		console.groupEnd();
	}
});
/*
Page setup:
Page's are instantiated inside a .page.js file.  This means there is no route, initially.

And, we're planning on using the route.parent.page.view..

We need App to be a root page...


If pages have 1 main view, and any number of links to it, that just simply call "page.activate", then we need the page $el placed into the correct container before activation.

The app will be the root "page", but without a URL.
When app.activate() ..?
When the router is activated(), then the homepage transitions in.

The homepage is just like a first level page.

HOME
ONE
TWO
THREE

And we just treat "/" as HOME

This means we need a container to put the HOME, and all first level pages into.

This could be a 2 column container, where the left col is the nav.


Page activation, and linkage with routes:

homepage.activate() --> homepage.route.activate(), where homepage.route is the router.

ONE.activate()

The page.cbs() will look at page.parent/activeChild, and 





If pages are to have multiple views, then each view needs to have its own root.

Let's assume each page has 1 view?

If I want tests to use pages... That should still work.  The only thing that's not possible, is activating the page when a list view is clicked, for example..

page.list()
--> can just create a link to the main page



Sub Pages that actually exist within another page, can appear that way, and can have 0 right margin.

Pages that link to another parent, however, should look like buttons, with right margin.









Immediately instantiated:

req.ctx.keys.each:
	- req(page)
	- use page.route if its a route, use page.route to make a route, if its a string, and fallback to using the req.ctx key as the route
	- add route to page, if not already
	- add page to route

page.activate:
	// sequential deactivate/activate + promise logic...
	if (!this.isActiveNode()){
	
	}

page.activateSelf()
	this.render() ??




Multi-view items (aka split view, or.. tabs, or whatever)

[ preview ][ full view ]

When we render a page.preview() into another page, we need to also register the preview's click handler to look for ...

page.preview() --> creates a new PagePreview, captures it, and parent's it to the parent page?  No, it parents it to the capturing view...

Treat a page as the "root":
	For any view that's captured, pass along the .page property
	This allows any sub view to know which page it's on
	Then, any capturing sub view can easily 
		view.add.view --> addedView.page = view.page
		// just passes it along to all captured views
		// view.page is the PageView 
		// maybe view.pageview?
		// and/or
		// view.page.page === the Page instance
		// view.pageview.page // makes the most sense

	Then, the page.preview() knows its parent pageview, which has a .right column, so that when the page.preview is cloned? 

	page.preview.clone() vs page.preview() --> new this.PagePreview()

	When the page.preview is made, it looks at its .pageview.right, and uses that as the container for its click event.





Page is NOT a view...
Page could have a .view, that represents its main route

Pages could also have a path part that's used to make a relative path.
page.subPagePath

Below is a bad example..
/some-ui/v3/ would have .route.part == "v3"
But, if we were adding that to another page, we'd probably want "some-ui/v3" as the subPagePath....

Or, each page could have a "root", which is an arbitrarily defined parent that it uses for various things, like the subPagePath...

page.route.part = "two"
	// could be something like /test/pkg/folder/file/two/

page.subPagePath = "/pkg/folder/file/two/";
	// doesn't have to be a single part
	// this is then added to wherever you are:

/some-post/pkg/folder/file/two/

So, clearly we can have sparse pages..
And, we don't absolutely need routes for all of the parts?
I suppose, if it makes them, its not a big deal...

If you go to /some-post/pkg/, which would exist as a route, but have no page, then an auto-interim-page-forwarder page could be used...

No, this should happen at the Route level - for interim routes that don't have pages, we should create a special route that matches until you find a route with viable actions.

That way, all the route parts can exist, in between /one/ and /one/two/three/four/five/, even though only /one/ and /five/ have viable actions.

The .viable flag could be used to denote this... 
Or, we just consider .cbs.length as .viable
When matching, if we matchChildren, and end on a non-viable route (like /two/, /three/, or /four/, above), then we should keep looking for the first viable child (which would usually just be one...)


Server side rendering is probably best:
I don't think we can do real 404s without it...
A client-side 404 is good for users, but we can't have a fresh request to an unknown URL return a real http 404, if we're using fallbacks..

With server side rendering, each route has its own folder/file to return, and a path that should 404 won't have that folder/file, so it'll throw a real 404...
*/