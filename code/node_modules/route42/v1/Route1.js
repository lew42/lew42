var Base2 = require("base42/v2");
var Base3 = require("base42/v3");
var is = require("util42").is;
var shared = require("../shared");

var Method = require("method42/v4");


var cleanPathParts = function(pathParts){
	if (pathParts[0] === "")
		pathParts = pathParts.slice(1);

	if (pathParts[pathParts.length - 1] === "")
		pathParts = pathParts.slice(0, -1);

	return pathParts;
};
getParts = function(path){
	return is.arr(path) ? path :
		cleanPathParts(path.split("/"));
}

var Path = Base2.Simple.extend({
	name: "Path",
	initialize: function(){
		this.children = [];
		this.init();
	},
	path: function(){
		if (this.parent)
			return this.parent.path() + this.part + "/";
		else
			return "/" + this.part + "/";
	},
	get: function(path){
		var parts;
		if (is.str(path))
			parts = shared.parts(path);
		else if (is.arr(path))
			parts = path;

		for (var i = 0; i < this.children.length; i++){
			// this.children[i].get()
		}
	}
});

var Route = Base3.extend({
	name: "Route1",
	// log: true,
	initialize: function(){
		this.cbs = [];
		this.routes = {};
		this.init();
	},
	// path: "one/two/three" || ["one", "two", "three"]
	find: function(path){
		var parts = getParts(path), // ensure ["one", "two", "three"]
			firstPart = parts[0], // "one"
			rest;

		if (firstPart in this.routes){
			rest = parts.slice(1);
			return (rest.length && this.routes[firstPart].find(rest)) // look for a deeper match
				|| { route: this, remainder: rest }; // or, this is it
		} else {
			return false;
		}
	},
	path: function(){
		if (this.parent)
			return this.parent.path() + this.part + "/";
		else
			return "/" + this.part + "/";
	},
	make: function(path, options){
		var parts = getParts(path),
			part = parts[0],
			rest = parts.slice(1),
			route;

		if (!(part in this.routes)){
			route = new Route({
				part: part,
				parent: this
			}, options);

			
			this.routes[part] = route;
			
			if (rest.length) 
				return route.make(rest, options);
			else 
				return route;

		} else {
			console.warn("Attempted to re.make() a path that already exists.");
			// Shouldn't use .make directly.  Other methods, such as .add
			// will check if it exists, and return that...
		}

		return false;
	},
	add: function(path, options){
		var parts = getParts(path),
			match = this.find(parts);
		
		if (match){
			if (match.remainder.length){
				this.log("Partial match:", match.route.path, "found, plus remainder:", match.remainder);
				return match.route.make(match.remainder, options);
			} else {
				this.log("Exact route:", match.route.path, "already exists.");
				return match.route;
			}
		} else {
			this.log("No match found.  Make all.");
			return this.make(parts, options);
		}
	},
	set_parent: function(parent, name){
		this.parent = parent;
		this.router = parent.router;
	},
	makeFullPath: function(){
		if (this.part){	
			if (this.parent){
				this.parts = this.parent.parts.slice(0)
			} else {
				this.parts = [];
			}

			this.parts.push(this.part);

			this.path = "/" + this.parts.join("/") + "/";
			return this.path;
		}
	},
	set_path: function(path){
		if (path.indexOf("/") > -1){
			console.warn("bridging needed");
		} else {
			this.part = path;
			this.name = this.part;
		}
	},
	each: function(fn){
		var ret;
		for (var i = 0; i < this.routes.length; i++){
			ret = fn.call(this, this.routes[i], i);
			if (ret) // return truthy breaks the loop, falsey continues
				return ret;
		}
	},
	match: function(parts){
		if (parts[0] === this.part){
			return this.matchChildren(parts.slice(1));
		} else {
			return false;
		}
	},
	matchChildren: function(parts){
		var childMatch;
		if (parts.length){
			childMatch = this.each(function(route){
				// console.log("child:", route);
				// truthy breaks loop, falsey continues search
				return route.match(parts);
			});
		}

		return childMatch || {
			route: this,
			remainder: parts
		};
	},
	bridge: function(parts){
		var next = this;
		for (var i = 0; i < parts.length; i++){
			this.log(next.path, "+", parts[i]);
			next = next.add(parts[i]);
		}
		return next;
	},
	add: function(path){
		// get the parts
		var parts = shared.parts(path), route, parent;

		this.log.debug("Attempting to add", parts);

		// search for an existing child
		var match = this.matchChildren(parts);

		if (match){
			// exact match was found 
			if (!match.remainder.length){
				// this does happen, out of order.  I think this is ok, for now
				// console.warn("attempting to re-add an existing route");
				this.log("Exact route:", match.route.path, "already exists.");
				return match.route;
			
			// a partial match
			} else {
				this.log("Partial match:", match.route.path, "found, plus remainder:", match.remainder);
				// even if only 1 remainder, parent becomes the match.route (bridge loops through an empty array, and returns self)
				this.log("Only bridge until the second-to-last part.");
				parent = match.route.bridge(match.remainder.slice(0, -1));
			}
		} else {
			this.log("No match found.  Bridge from this until second-to-last part.");
			// again, even if parts.length is 1, this should still work
			parent = this.bridge(parts.slice(0, -1));
		}

		this.log("Using parent:", parent.path);

		// set a potential/long/path to just the last path part
		path = parts[parts.length - 1];

		route = new Route({
			parent: parent,
			path: path
		});

		this.routes.push(route);

		return route;
	},
	push: function(){
		if (window.location.pathname === this.path){
			// console.warn("path matches, no need to push");
			// this happens on first load.. i think this is ok for now
		} else {
			window.history.pushState(null, null, this.path);
			this.googleAnalytics();
		}
	},
	googleAnalytics: function(){
		if (ga){
			ga('set', {
				page: this.path,
				// title: this.page.name //?
			});

			ga('send','pageview');
		}
	},
	isActiveNode: function(){
		return this.router.activeNode === this;
	},
	activate: function(push){
		if (!this.isActiveNode()){
			this.router.activeNode = this;
			if (push !== false)
				this.push();
			this.exec();
		} else {
			// console.warn("already active route");
		}
	},
	exec: function(){
		this.cbs.forEach(function(cb){
			cb.call(this);
		}.bind(this));
	},
	then: function(cb){
		this.cbs.push(cb);
		return this;
	},
	_logger: function(){
		console.group(this.part);
		this.each(function(route){
			route._logger();
		});
		console.groupEnd();
	},
	rematch: function(){
		var match = this.router.getMatch();
		if (match.route === this)
			return false;
		
		match.route.remainder = match.remainder;
		match.route.activate(false);
		return true;
	}
});

var Router = module.exports = Route.extend({
	name: "Router1",
	listen: true,
	// log: true,
	// needs to come before path
	set_path: function(path){
		this.path = path;
		this.parts = shared.parts(this.path);
		this.part = this.parts[this.parts.length - 1];
	},
	initialize: function(){
		this.router = this;
		this.cbs = [];
		this.routes = [];
		if (!is.def(this.path))
			this.set_path("/");

		window.addEventListener("popstate", this.listener.bind(this));

		this.init();
	},
	listener: function(location, action){
		// toggled by routes, to skip when the action originates from ourselves
		if (this.listen){
			this.matchAndActivate();
		}
	},
	getCurrentURLPathParts: function(){
		// an attempt to make the router work when dropped on any given relative page
		return shared.parts(window.location.pathname.replace(this.path, ""));
	},
	matchAndActivate: function(){
		this.log("matchAndActivate()");
		var match = this.getMatch();
		if (match){
			this.log("match", match);
			match.route.remainder = match.remainder;
			match.route.activate(false);
		}
		return this;
	},
	match: function(parts){
		return this.matchChildren(parts);
	},
	getMatch: function(){
		return this.matchChildren(this.getCurrentURLPathParts());
	}
});

/*
Alternative, simpler API

route.match("some/path/or" || "single-part");


Loop through sub routes, and match?
If we don't use the parts, and map the first part to the first child route..
It's worked well, I don't know why I should change that part.

So, the router and route structure is basically just a tree, with activations.
I think it's working.  I could always come back...



Use cases
1. Initial load and popstate:  any arbitrary URL to match
2. Add arbitrary paths, potentially based on a folder structure.  I'd like to keep this in effect, even if I'm using my own "loader" system (which honestly might not happen for a while...);
3. route.activate() and route.activate(false)


*/