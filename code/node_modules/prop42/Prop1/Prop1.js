var Value1 = require("value42/Value1");
var Q1 = require("q42/Q1");
var track = require("track42");
var copy = require("copy42")().fn;
var is = require("util42").is;

var View = require("view42");

var PropView = View.Bar.extend({
	name: "PropView",
	content: function(){
		View.Icon("circle");
		View(this.mod.name).addClass("name");
		this.value = View(this.mod.value);
	},
	bindings: function(){
		this.mod.changed.add(function(value){
			this.value.text(value);
		}.bind(this));
	}
});

var ArrPropView = PropView.extend({
	name: "ArrPropView",
	content: function(){
		View.Icon("bars");
		View(this.mod.name).addClass("name");
		this.value = View("[" + this.mod.value.length + "]"); 
	}
});

var Prop1 = module.exports = Value1.extend({
	name: "Prop1",
	View: PropView,
	render: function(){
		new this.View({
			mod: this
		})
	},
	instantiate: function(){
		this.inst_value();
		Value1.prototype.instantiate.apply(this, arguments);
	},
	inst_value: function(){
		// should we have different Prop classes to wrap different types of values?
			// and - even for specific cases of values
			// you could customize the .set and .clone functionality at a very granular level that way - without having to modify the .set algorithm

		// could be any type of value
			// pojo --> copy
			// mod --> clone?
				// clone --> direct child?
					// direct child --> clone()
					// not direct child --> nothing
				// no clone fn --> nothing? - this is an edge case, I would think all mods should have a .clone fn
			// the presence of ".clone" could indicate whether its a mod?
			// arr -> copy
			// simple value --> copy
			// Class --> 

		// this.parent isn't available until after .set...
		if (this.value && this.value.clone)
			this.value = this.value.clone({
				parent: this.parent
			});
		else 
			this.value = copy(this.value);
	},
	initialize: function(){
		if (this.parent){
			this.changed.ctx = this.parent;
			this.init_define();
			if (this.parent && this.parent.props)
				this.parent.props[this.name] = this;
		}
		this.init();
	},
	init_define: function(){
		var name = this.name;
		var prop = this;

		Object.defineProperty(this.parent, name, {
			get: function(){
				return prop.getter(this);
			},
			set: function(value){
				prop.setter(value, this);
			},
			configurable: true
		});
	},
	setter: function(value, ctx){
		if (ctx.hasOwnProperty(this.name)){
			if (ctx !== this.parent)
				console.error("ctx/parent mismatch");
			this.set_value(value);
		} else {
			console.warn("I don't think this should happen");
			this.clone({
				parent: ctx
			})
		}
	},
	getter: function(ctx){
		if (ctx !== this.parent)
			console.error("ctx/parent mismatch");

		if (!ctx.hasOwnProperty(this.name)){
			if (!is.simple(this.value))
				console.warn("potentially dangerous lookup");
				// if the user modifies the prototype's value...
		}

		return this.get_value();
	},
	clone: function(o){
		var clone = Object.create(this);
		track(clone);
		if (o && o.parent){
			clone.parent = o.parent;
			delete o.parent;
		}
		clone.proto = this;
		clone.instantiate.apply(clone, arguments);
		return clone;
	}
});