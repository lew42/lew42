var is = require("util42/is");
var Base4 = require("../v4/");
var createMorphicConstructor = require("./createMorphicConstructor");
var Logger = require("log42/v2");
var logger = Logger();



var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
var getParamNames = function(func) {
  func = func || function(){};
  var fnStr = func.toString().replace(STRIP_COMMENTS, '');
  var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
  return result || [];
}



var LogArgs = Base4.extend({
	name: "LogArgs",
	initialize: function(){
		this.styled = [];
	},
	add: function(str, style){
		this.styled.push({str: str, style: style});
	},
	appendStyle: function(css){
		this.styled[this.styled.length - 1].style += css;
	},
	getArgumentArray: function(){
		var args = [], str = "";
		
		for (var i = 0; i < this.styled.length; i++){
			str += "%c" + this.styled[i].str;
		}

		args.push(str);

		for (var i = 0; i < this.styled.length; i++){
			args.push(this.styled[i].style);
		}

		return args;
	},
	// log: function(){   // args() ---> getArgumentArray()
	// 	console.log.apply(console, this.args());
	// },
	// group: function(){
	// 	console.group.apply(console, this.args());
	// },
	// groupCollapsed: function(){
	// 	console.groupCollapsed.apply(console, this.args());
	// },
	// getLog: function(){
	// 	return console.log.bind.apply(console.log, [console].concat(this.args()));
	// },
	mod: function(mod){
		this.add(mod.name, "font-weight: bold;");
		this.add("{" + mod.constructor.name + "-" + mod.id + "}", "font-weight: normal; color: #666;");
	},
	method: function(name){
		this.add("."+name + "( ", "font-weight: bold;");
	},
	closeMethod: function(){
		this.add(" )", "font-weight: bold;");
	},
	str: function(str){
		this.add('"' + str + '"', "color: red;");
	},
	num: function(num){
		this.add(num, "color: blue;");
	},
	bool: function(bool){
		this.add(bool ? "true":"false", "color: purple;");
	},
	Class: function(cls){
		this.add(cls.name + "<" + cls.id + ">", "font-weight: bold;");
	},
	fn: function(fn){
		this.add( fn.name ? fn.name + "()" : "anon()", "color: #ff3700;");
	},
	var: function(value, name){
		if (name)
			this._name(name);
		this.value(value);
	},
	_name: function(name){
		this.add(name + ": ", "color: purple; font-weight: normal;");
	},
	value: function(value){
		if (is.str(value))
			this.str(value);
		else if (is.bool(value))
			this.bool(value);
		else if (is.num(value))
			this.num(value);
		else if (is.Class(value))
			this.Class(value);
		else if (is.fn(value))
			this.fn(value);
		else if (is.mod(value))
			this.mod(value);
		else if (is.obj(value))
			this.obj(value);
		else if (is.arr(value))
			this.arr(value);
		else
			this.str(value.toString());
	},
	sep: function(){
		this.add(", ", "font-weight: normal;");
	},
	values: function(values, names){
		if (names && names.length){
			for (var i = 0; i < names.length; i++){
				this.var(values[i], names[i]);
				if (i < names.length - 1)
					this.sep();
			}

			if (i < values.length){
				this.sep();
				this.values(values.slice(i));
			}
		} else if (values && values.length){
			for (var i = 0; i < values.length; i++){
				this.var(values[i]);
				if (i < values.length - 1)
					this.sep();
			}
		}
	},
	call: function(fn){},
	obj: function(obj){
		var bg = "background: #eee; border-bottom: 1px solid #ddd;";
		var length = 0;
		for (var i in obj) length++;
		var keys = Object.keys(obj);
		this.add(obj.constructor.name + " {", bg + "padding-left: 5px;");
		for (var i = 0; i < keys.length; i++){
			this._name(keys[i]);
			this.appendStyle(bg);
			this.value(obj[keys[i]]);
			this.appendStyle(bg);
			if (i < keys.length - 1){
				this.add(", ", "font-weight: normal;" + bg);
			}
		}
		this.add("}", bg + "padding-right: 5px");

	},
	arr: function(arr){
		this.add("["+ arr.length + "]", "color: blue;");
	}
});


// var styled = new LogArgs();
// styled.add("one", "color: blue");
// styled.add("two");
// styled.add("three", "color: red; padding: 50px; background: grey;");
// styled.log();
// styled.group();
// styled.groupCollapsed();
// styled.getLog()();


var _Base = Base4.extend({
	name: "_Base5"
}).assign({
	createConstructor: createMorphicConstructor
});

/*

// the override function does the restore behaviour for you
this.log.override(another, function(){
	another.whatever();
}.bind(this)); // keep context
// if `this.log` is on, it turns another.log on, and then restores it
// if `this.log` is off, it turns another.log off, and then restores it
// you could do this conditionally. let's say 1 object seems to be exceptionally noisey:

if (another.id === 53){
	this.log.override(another, function(){
		another.whatever();
	});
}

or how about 

this.log.overrideIf(another.id === 53, another, function(){
	
}.bind(this));

But, this could just be an optional syntax for the standard override...
If the first value is boolean, it's treated as a conditional override.

This means you don't have to write the same code within the fn and outside the fn.  If the condition passes, the override happens.  If not, it still runs the function, but doesn't do the override.

*** In reality, these very specific overrides are probably unlikely... ***

What might be more likely, is a unidirectional conditional override:

this.log.on(another.id === 53, another, function(){
	... code goes here... (except for arguments);
}.bind(this));

This would be useful, to turn a particular instance on, but only for a short period of time...

*/

var Method = _Base.extend({
	name: "Method93",
	logMethod: "groupCollapsed",
	inline: false,
	args: true,
	log: logger.active,
	set_log: logger.setter,
	LogArgs: LogArgs,
	suppress: function(){
		// still wrap, so we can turn mod.log off and then restore it
	},
	initialize: function(){
		this.initialize_settings();
		this.resolve("return"); // converts return: fn --> value
		this.resolve("expand");
		if (this.expand)
			this.logMethod = "group";
		this.logArgs = new this.LogArgs();

		this.argNames = getParamNames(this.fn);
	},
	initialize_settings: function(){
		// merge settings onto self
		if (is.bool(this.settings)){
			this.set_log(this.settings);
		} else if (is.obj(this.settings)){
			if (is.def(this.settings.log)){
				if (is.bool(this.settings.log))
					this.set_log(this.settings.log);
				else
					console.error("this should only be bool?");
				delete this.settings.log;
			}
			this.assign(this.settings);
		}
	},
	/*
	*  The proxy is essentially the same thing as `this.fn`.
	*  The proxy allows us to 'listen' to fn calls.
	*  We use `get_proxy()` inside the proxied obj [huh?...].
	*  When this fn proxy is called, it will call `this.exec`.
	*/
	get_proxy: function(){
		if (!this.proxy){
			if (!this.fn)
				console.error("must provide fn to proxy");

			if (!this.mod.log.on || !this.log.on)
				return this.fn;

			this.proxy = new Proxy(this.fn, {
				apply: this.exec.bind(this)
			})
		}
		return this.proxy;
	},
	exec(fn, ctx, args){
		if (!this.log.on) debugger;
		// when debugging: skip over (CTRL+') this line
		this.before.apply(this, arguments);

		// step into (CTRL+;) this fn.apply to see the actual fn call
		/* --> debug here --> */ this.returnValue = fn.apply(ctx, args);

		// step out (CTRL+SHIFT+;)
		this.after();
		return this.returnValue;
	},
	before(fn, ctx, args){
		// if !this.mod.log.on, should we suppress all?
		// if !this.settings.log, we should suppress this
		if (fn !== this.fn) 
			console.error("fn mismatch");

		if (ctx.id !== this.mod.id)
			console.error("ctx/mod mismatch");

		this.ctx = ctx;
		this.arguments = args; // ntbcw (not to be confused with) this.args, which is the API boolean
		this.build();
		this.open();
	},
	build: function(){
		this.logArgs.mod(this.ctx);
		this.logArgs.method(this.name);
		this.logArgs.values(this.arguments, this.argNames);
		this.logArgs.closeMethod();
	},
	open: function(){
		if (this.return !== "inline")
			console[this.logMethod].apply(console, this.logArgs.getArgumentArray());
	},
	after: function(){
		this.return_switch();
	},
	getLogArgs: function(){
		return this.getPrefix()
			.concat(this.getFnArgs(), [");"]);
	},
	getFnArgs: function(){
		return this.args ? this.buildArgs() : [];
	},
	buildArgs: function(){
		this.filterArgs();
		this.separateArgs();
	},
	filterArgs: function(){
		this.arguments = this.arguments.map(function(arg){
			if (is.fn(arg))
				return "<fn>";
			else if (arg && arg.id){
				return this.buildLabel(arg);
			} else {
				return arg;
			}
		}.bind(this));
	},
	separateArgs: function(){
		var args = [];
		for (var i = 0; i < this.arguments.length; i++){
			args.push(this.arguments[i]);
			if (i < this.arguments.length - 1)
				args.push(",")
		}
	},
	buildLabel: function(obj){
		return obj.name + "{" + obj.constructor.name + "-" + obj.id + "}";
	},
	buildPrefix: function(){
		return ["%c" + this.buildLabel(this.ctx) + "%c." + this.name + "(", "font-weight: normal", "font-weight: bold"];
	},
	getPrefix: function(){
		return this.prefix ? this.buildPrefix() : [this.name + "("];
	},
	resolve: function(prop, arg1, arg2){
		 if (is.fn(this[prop]))
			this[prop] = this[prop].apply(this, [].slice.call(arguments, 1));
		return this[prop];
	},
	return_switch: function(){
		var ret = this.return;
		ret = is.def(ret) ? ret : "auto"; // undefined --> "auto"
		if (ret)
			this["return_" + ret]();
		// if this.return === false, then we noop
	},
	return_contain: function(){
		// exaggerated indentation?
		this.log("-------- return", this.returnValue);
		this.log.end();
	},
	return_expose: function(){
		// slight indentation to match group indentation
		this.log.end();
		this.log("--- return", this.returnValue);
	},
	return_auto: function(){
		if (is.def(this.returnValue))
			this.return_expose();
		else
			this.log.end();
	},
	return_inline: function(){
		console.log.apply(console, this.getInlineLogArgs());
	}
});

/*
In order for .set({ log: { config } }) --> ._log..
We need to do this on the Mod that has .set, not the base.

The immediate problem I'm seeing, is that Mfn are only Base modules.

Can we modify the config... manually?
Can we use an external/standalone .set?

set(base, { log: {...} })
// ===
base.set({ log: {...} })
*/

var extend = function(base, ext){
	var arg, prop;
	for (var i = 1; i < arguments.length; i++){
		arg = arguments[i];
		for (var j in arg){
			prop = arg[j];
			if (is.obj(prop) && is.obj(base[i])){
				extend(Object.create(base[i]), prop);
			} else {
				base[i] = prop;
			}
		}
	}
	return base;
};
var Logged = _Base.extend({
	name: "Logged",
	Method: Method,
	excludes: ["log", "hasOwnProperty"],
	proxy: function(){
		var logged = this;
		var mod = this.mod;
		return new Proxy(mod, {
			get: this.getter.bind(this)
		})
	},
	getter: function(target, prop){
		var ret;
		// console.group(target, prop);
		if (target !== this.mod)
			console.error("target/mod mismatch");

		const value = target[prop];

		if (is.fn(value) && this.excludes.indexOf(prop) === -1){
			ret = new this.Method({
				mod: this.mod,
				fn: value,
				name: prop,
				settings: target._log[prop]
			});
			ret = ret.get_proxy();
			// console.log('ret', ret);
			// console.groupEnd();
			return ret;
		} else {
			// console.log('value', value);
			// console.groupEnd();
			return value;
		}
	}
});

var Base = module.exports = _Base.extend({
	name: "Base5",
	log: logger.noop,
	set_log: logger.setter,
	Logged: Logged,
	_log: {
		set_log: false,
		log: false,
		initialize: {
			expand: true,
			return: false
		},
		instantiate: {
			prefix: true,
			expand: true,
			return: false
		}
	}, // holds the log config data
	config: function(o){
		this.constructor.track(this);
		this.config_name(o);
		this.config_log(o);
		return this.config_proxy();
	},
	config_proxy: function(){
		if (this.log.on){
			return new this.Logged({
				mod: this
			}).proxy();
		} else {
			return this;
		}
	},
	config_name: function(o){
		// o could be a fn that has a .name, or other module with .name
		// we only want pojo
		if (is.pojo(o) && is.def(o.name)){
			this.name = o.name;
			delete o.name;
		}
	},
	config_log: function(o){
		var logSettings;
		if (is.pojo(o) && is.def(o.log)){
			logSettings = o.log;
			delete o.log;
			this.set_log(logSettings);
		}
	},
	instantiate: function(){
		this.assign.apply(this, arguments);
		this.initialize && this.initialize.apply(this, arguments);
	},
	clone: function(){
		var clone = Object.create(this);
		clone = clone.config.apply(clone, arguments) || clone;

		// maybe restrict 'morphing' to proxy only
		// morphing to an instantiated object will then cause this to reinstantiate (eew)
		clone.instantiate && clone.instantiate.apply(clone, arguments);
		return clone;
	},
	call: function(fn){
		fn.call(this); // mod.call(function(){})
							// might as well fn.call(mod) ...
		// or
		// mod.call({ method: arg }) --> mod.method(arg)
		// or
		// mod.apply({ method: [args, ... ] }) --> mod.method.apply..
	},
	apply: function(arr){
		/*
		.assign({ call: {}, or apply: {} }) could both do their thing, instead of actual assignment?

		Or, a variation on .set could be .apply?
		And in set, if you want to apply, you would .set({ apply: { method: [...] } })

		Hmm...
		*/
	}
})


/*

function(mod){
		var logged = this;
		this.mod = mod;

		// cached proxies
		this.methods = {};

		var proxy = new Proxy(mod, {
			get(target, prop){
				const value = target[prop];
				if (is.fn(value)){
					// if (logged.methods[prop]){

					// 	if (logged.methods[prop].constructor !== target._log.Method){
					// 		console.warn("rebase");
					// 	}
					// 	if (target._log && is.def(target._log.methods[prop])){
					// 		if (target._log.methods[prop] === logged.methods[prop].settings){
					// 			// no settings have changed, use cached method
					// 			return logged.methods[prop];
					// 		} else {
					// 			return new logged.Method({
					// 				fn: value,
					// 				settings: target._log.methods[prop]
					// 			});			
					// 		}
					// 	}
					// }
					return new Proxy(value, {
						apply: function(target, it, args){
							var logArgs = args.slice(0);
							logArgs = logArgs.map((arg) => {
								return is.fn(arg) ? "<fn>" : arg;
							});
							console.groupCollapsed.apply(console, [prop +"("].concat(logArgs).concat([")"]));
							var ret = target.apply(it, args);
							console.log("return", ret);
							console.groupEnd();
							return ret;
						}
					})
				} else {
					// console.log(prop, value);
					return value;
				}
			}
		});
		return proxy;
	}

	*/