var Mod = require("mod42/v2");
var util = require("util42");
var is = util.is;
var Method2 = require("../v2");
var track = require("track42");

var define = require("mixin42/define");
var cloner = require("mixin42/cloner");

var Logger = require("log42/v1")

var btc = 0;

/*
TODO:  abstract this auto-cloner functionality
TODO:  abstract this Sfn functionality between Mfn, Logger, and Method
*/
var count = 0;

var Method = module.exports = Method2.extend({ name: "Method3" }, 
	/* mixins */ define, cloner, 
{
	log: Logger(),
	getter: function(ctx){
		var clone = this.protect(ctx);
		return clone ? clone.wrapper : this.wrapper;
	},
	assignedTo: function(parent, name){
		this.mod = parent;
		this.name = name;
		this.init_define(this.mod, this.name);
	},
	exec: function(ctx, args){
		var ret;

		if (ctx !== this.mod){
			// console.log(this.mod.constructor.name, ctx.constructor.name);
			// console.log(ctx.constructor.isExtensionOf(this.mod.constructor));
			if (!ctx.constructor.isExtensionOf(this.mod.constructor))
				console.warn("Oops?  I suppose this could happen when a method from another object is applied to 'this'.  For example, when you do MyBase.prototype.whatever.apply(this, arguments).");
		}

		// if (btc < 3){
		// 	console.group("bt");
		// 	btc++;
			var bts = util.getBacktrace();
			// bts.forEach(function(bt){
			// 	console.log(bt.fullPathAndLine);
			// })
			this.bt = bts[2];
		// 	console.log((new Error).stack);
		// 	console.groupEnd();
		// }

		// if (ctx.log){
		// 	/**/
		// 	console.error("TODO: Give method its own .log.  Link the method.log to the ctx/parent .log, so that all method.logs also get added to parent.log?")
		// 	ctx.log("method.exec", '[ name:', this.name, '][ ctx:', ctx, '][ args:', args, ']');
		// } else {

			var label;

			if (is.fn(this.mod.label)){
				label = this.mod.label();
			} else {
				label = this.mod.name + "{" + this.mod.constructor.name + "-" + this.mod.id + "}";
			}

			label += "." + this.name + "()";

			var log = this.log.group(label, function(){
				this.log("call count", ++this.count);
				ret = this.fn.apply(ctx, args);
				var rlog = this.log("return", (is.def(ret) && ret.toString()) || "undefined");

				if (ret === false)
					rlog.parent.falsey = true;
				
				// this.rlog = rlog;
			}.bind(this));
		// }

		log.bt = bts[2].fullPathAndLine;

		// if (ctx.log){
		// 	ctx.log("method.exec", "[ ret:", ret, ']');
		// }

		return ret;
	}
});