var is = require("util42/is");
var Base = require("base42/v1");

var ViewCaptor = require("../ViewCaptor");

ViewCaptor.previousCaptors = [];
ViewCaptor.set_captor = function(newCaptor){
	this.previousCaptors.push(this.captor);
	this.captor = newCaptor;
};
ViewCaptor.restore = function(){
	this.captor = this.previousCaptors.pop();
};
ViewCaptor.capture = function(view){
	if (this.captor){
		if (view.$el)
			this.captor.append(view);
		else
			this.captor.append(view.el);
	}
};
ViewCaptor.viewable = function(any){
	if (is.str(any)){
		var ret = document.createTextNode(any);
		console.log(any)
		console.dir(ret);
		window.lastTextNode = ret;
		return ret;
	} else if (any && any.constructor && any.constructor.name === "jQuery"){
		return any[0];
	} else {
		console.warn("todo");
	}
};

var View = module.exports = Base.extend({
	name: "View1",
	set: function(value){
		if (is.def(value))
			this.content = value;
	},
	initialize: function(){
		this.el = document.createElement("div");
		
		ViewCaptor.capture(this);

		this.render();
	},
	render: function(){

		if (is.def(this.content))
			this.append(this.content);
	},
	prepend: function(v){
		// this.content.unshift?
		this.el.insertBefore(ViewCaptor.viewable(v), el.childNodes[0]);
		return this;
	},
	append: function(v){
		this.el.appendChild(ViewCaptor.viewable(v));
		return this;
	}
});

/*

## Async rendering advantage:
How do we batch DOM patches?  Either invoke a .buffer()... or, do it automatically via async rendering:
1. Any number of updates come through
2. No DOM manipulations (yet)
3. On nextTick, then we can make the updates

## Build vs Update vs Render vs...?
- tracking CSS:  classes is an array, and we can add/remove?
- tag?  document.createElement("tagname")
- attr?


## content functions
Rather than build a view out of static components, why not allow render functions, or nested views that rerender?


## Bindings
View(mod.on("whatever"))
--> mod.on("whatever").then(view.update.bind(view)), where view.update is a fn that takes a new value as its first arg, passes it into the viewable fn, and then appends it.

*/