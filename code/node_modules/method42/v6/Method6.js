var Base = require("base42/v1");
var is = require("util42").is;

var Method = module.exports = Base.extend({
	name: "Method6",
	expand: true,
	enabled: true,
	eval: true,
	override: true,
	set: function(value){
		if (is.bool(value)){
			this.set_log(value);
		} else if (is.fn(value)){
			this.fn = value;
		}
	},
	makeNormalWrapper: function(){
		var method = this;

		// this fn signature is different for Mfn and simple method wrappers
		this.wrapper = function(){
			return method.exec.apply(method, [this].concat([].slice.call(arguments)));
		};
	},
	makeEvaledWrapper: function(){
		var method = this;

		// swap this out for production, this is just for stack trace
		this.wrapper = eval("(function " + this.name + "(){\r\n"
			+ 	"\treturn method.exec.apply(method, [this].concat([].slice.call(arguments)));\r\n" 
			+ "})");
	},
	makeWrapper: function(){
		if (this.eval){
			this.makeEvaledWrapper();
		} else {
			this.makeNormalWrapper();
		}

		this.makeWrapper_();
	},
	makeWrapper_: function(){
		this.wrapper.method = this;
	},
	// exec logic could be dumped directly into the wrapper, which reduces call stack... 
	// leave this alone, for now
	exec: function(ctx, arg1, arg2){
		this.open.apply(this, arguments);

		/* --> */ var ret = this.fn.apply(ctx, [].slice.call(arguments, 1));

		this.close(ctx);

		return ret;
	},
	open: function(ctx){
		var log; // either this.log, if hasOwn, or the ctx's log

		// this is used to reset ctx's log state, if we change it
		this.ctxLastLogger = false;
		this.restore = false;

		// Method has specified its own log state, so use that.
		if (this.hasOwnProperty("log")){

			// and override ctx.log
			if (this.log.active !== ctx.log.active && this.override){
				this.ctxLastLogger = ctx.log;
				// console.log("ctx.log.active", ctx.log.active, "now this.log.active", this.log.active);
				ctx.log = this.log;
			}
		} else {
			// otherwise, just use ctx.log
			this.log = ctx.log;
			this.restore = true;
		}

		if (this.expand){
			this.log.group.apply(null, this.label.apply(this, arguments));
		} else {
			this.log.groupc.apply(null, this.label.apply(this, arguments));
		}
	},
	close: function(ctx){
		this.log.end();

		if (this.ctxLastLogger)
			ctx.log = this.ctxLastLogger;

		// if we got from !hasOwn to overriding this.log, we want to reset back to !hasOwn
		if (this.restore)
			delete this.log;

		this.ctxLastLogger = false;
		this.restore = false;
	},
	label: function(ctx){
		return ["%c" + ctx.name + "{" + ctx.constructor.name + "-" + ctx.id + "}" + "%c." + this.name + "()", "font-weight: normal;", "font-weight: bold"];
	},
	wrap: function(parent, name){
		if (this.hasOwnProperty("name") && this.name !== name){
			console.error("Method name mismatch.  You probably want to clone instead of renaming...");
		}
		this.name = name;
		this.makeWrapper(name); // depends on name!
		parent[name] = this.wrapper;
	},
	shouldWrap: function(parent, name){
		// if method.log is set to "off", we still want to wrap, so that we can silence the method...
		return parent.log.active || (this.hasOwnProperty("log") && this.log.active);
	},
	assignTo: function(parent, name){
		if (this.shouldWrap(parent, name))
			this.wrap(parent, name);
		else
			parent[name] = this.fn; // noop
	}
}).assign({
	expand: function(){
		var args = [].slice.call(arguments);
		args.push({ expand: true });
		return this.apply(null, args);
	}
});

/*
Potential log.method sub configs

log.method.squelch(...)
equivalent to
log.method({squelch: true}, ...)

squelch
--> log: false
--> wrap: true
--> override: true (uses log state, which here is false)

verbose
--> log: true
--> wrap: true
--> override: true

defaults
--> log: ctx's .log state
--> wrap: ctx's .log state? // we only wrap when log: true then
--> override: if log is auto, it shouldn't 

If we only accept wrappers when log: true, then the only time in which we'd get to a wrapped method, where the ctx's log was false, is if we extend and turn log: false, or set this.log = this.log.off, or something.  Not likely, but possible.

If method has its own shouldLog state (different from its own .log state), but a 'shouldLog' flag...  Then we can turn logging off for a method, and then conditionally turn it back on?  No, this is too tricky.

We could use method hasOwn .log to configure the logging.  If hasOwn, then we assume log has been set to true/false, and then we use that.

Otherwise, if !hasOwn, even though .log is available and has a state, it hasn't been explicitly set.  And if !hasOwn, we treat it as an "auto" state, and use the log state of the ctx.

What's the use case?  If we have a bunch of Methods, and leave log->auto, then they noop, and nothing happens.  Then when we want to turn logging on, we just uncomment the line, log: true, and everything starts making noise.

Maybe we use 3 log states:
- log: false --> don't wrap, don't log, nuthin
- log: true --> accept wraps, and turn logging on
- log: auto --> accept wraps, but don't log

The log: auto would be nice, in that it allows wrappers, so that then when we want to turn logging on for a specific object, we can do so.

We can then set log: false at the Base level, for performance assessment (all Methods should noop). 

The tricky part there, is how do you go from false --> auto?  Maybe you use hasOwn check, so that it always defaults to auto every time you extend, and you have to manually set log: false...?

That's not a bad solution.  The problem is, it's a TON of micro managing this thing...

You want to be able to flip one configuration point, and know for sure that nothing funky is going on... 

log.method.x() --> noop? aka, wrap: false
log.xmethod()?
log.method.noop() is probably the best
*/