var Page = require("page42");
var util = require("util42");
var is = util.is;

var Test2 = module.exports = Page.extend({
	name: "Test",
	pass: 0,
	fail: 0,
	enabled: true,
	autoCapture: true,
	set: {
		other: function(test, arg){
			if (is.str(arg))
				test.set_name(arg);
			else
				test.setContent(arg);
		}
	},
	initialize: function(){
		this.tests = [];
		this.url = sanitize(this.name);
		this.getCaptured();
		this.initRootTest();
		this.init_route();
		this.init();
	},
	rootTest: function(){},
	initRootTest: function(){
		if (!this.parent){
			// wasn't captured
			this.rootTest = this;
			this.remainder = this.
		}
	},
	init_route: function(){
		/*
God damnit. This shit shouldn't be so fucking hard.  But its impossible to get any simplicity here, because of the way I'm trying to adapt it.

- the root test won't have a route until after initialization
- when the root test gets set_route...


And, the whole concept of re-running test suites for other classes... I really don't think that's going to work very well...

When view is captured, it doesn't get a .parent..

1) app loads .test.js pages
2) .test.js page exports a Test page
3) test gets a route added to it
	this will be all root test pages
4) all test pages will be parented to another
5) nothing else happens, until a test route is matched
6) when it matches, the route.activates, and the test page activates
7) when the route.activates, the page renders
8) when the page renders, it executes its content function, which is the test fn now?
9) when the root test fn runs, new sub pages can be created
10) when a new sub page is captured, it gets added to the root page
11) when it gets added, now it has to be a... "on-demand" or "lazy" test page.  that is, it may or may not run:

The inner test page can add a route to the parent pages' route.
But, how is it activated?

We need to check immediately if the route's .remaining parts match



		if its a root test, loaded by the test page / app, then the route will get set from above.  The page will also get added wherever.

		But, the route will get added after init.

		None of the tests should even have a parent in init...

		The root route will be initialized immediately, and rendered (executed) when the route is activated.

		So, the root test page will get a route added to it immediately, and before rendering.

		The Page has a set_route method.

		!! route compliance:
		if the root test is named the same as the route, we can ignore the name

		But, if the route is named differently, we should only run the page when it has the extra route path?  

		Ugh...

		/test/pkg42/Pkg2/ --> test("another")
			requires route to be /test/pkg42/Pkg2/another/ ??

		The root test page's name shouldn't be a big deal...

		So, yea, just ignore the root pages name.  No matching.

		If the parent test page has a route...?


		what if a test has already run?  can we get it to re-run?

		Honestly, what's the point?  Just to see console logs again?
		It's not like the code can actually run again.  I suppose the user could trigger the debugger, but is rerunning a test like that a good idea?

		After the first pass, the state might be messed up


		Ok - so test pages get refreshed...
		How do we do that?

		Via a flag on the .route that uses window.location instead of history.push...


		*/
	}
});