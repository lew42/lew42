var Base = require("base42/v2");
var is = require("util42").is;

/*
* Method5 is relying on the old .log pattern.  Method6 uses the new one.
*/

var Method = module.exports = Base.extend({
	name: "Method5",
	enabled: true,
	eval: true,
	initialize: function(fn){
		this.init_fn(fn);
		// this.init_wrapper();
		this.init();
	},
	init_fn: function(fn){
		if (!is.fn(fn))
			this.log.warn("Method wrapper cannot be safely executed without a .fn!");

		this.fn = fn;
	},
	makeNormalWrapper: function(){
		var method = this;

		// maybe we can eval something to give this a name?  lets see how it appears in the call stack

		// this fn signature is different for Mfn and simple method wrappers
		this.wrapper = function(){
			return method.exec.apply(method, [this].concat([].slice.call(arguments)));
		};
	},
	makeEvaledWrapper: function(){
		var method = this;

		// swap this out for production, this is just for stack trace
		this.wrapper = eval("(function " + this.name + "(){\r\n"
			+ 	"\treturn method.exec.apply(method, [this].concat([].slice.call(arguments)));\r\n" 
			+ "})");
	},
	makeWrapper: function(){
		if (this.eval){
			this.makeEvaledWrapper();
		} else {
			this.makeNormalWrapper();
		}

		this.makeWrapper_();
	},
	makeWrapper_: function(){
		this.wrapper.method = this;
	},
	// exec logic could be dumped directly into the wrapper, which reduces call stack... 
	// leave this alone, for now
	exec: function(ctx, arg1, arg2){
		if (!this.open(ctx))
		/* --> */ return this.fn.apply(ctx, [].slice.call(arguments, 1));

		/* --> */ var ret = this.fn.apply(ctx, [].slice.call(arguments, 1));

		this.close(ctx);

		return ret;
	},
	open: function(ctx){
		if (!this.enabled)
			return false;
		
		this.restore = false;
		this.lastLogger = false;

		// allow method to override log state
		if (this.log.override){
			
			if (!this.log.enabled){
				this.tmpWarning();
				return false; // aborts logging ASAP
			} else {
				console.warn("Do we really want to override?  This could default to true.. but might get noisy");
			}

			this.restore = true;
			this.log.override();

		// otherwise, use ctx's logger
		} else {
			// this needs to happen before the override
			// store previous .logger
			this.lastLogger = this.log;

			// use ctx's logger
			this.log = ctx.log;

			// let ctx override global state
			if (ctx.log.override){
				this.restore = true;
				ctx.log.override();
			}
		}

		if (this.expand){
			this.log.group(this.label(ctx));
		} else {
			this.log.groupc(this.label(ctx));
		}

		return true;
	},
	tmpWarning: function(){
		console.warn("Maybe have separate flags for logging and squelching?  Currently setting log => false for either the Method or the ctx will kill the wrapper ASAP.  This means it won't squelch internal logs.  If you wanted to set log => false and have it silence everything inside (which you probably do), then we need another way to say, 'kill wrapper asap'.  But in reality, 'killing the wrapper' should be done via an unwrapping process, and is different than turning logging off.  Maybe .set({ log: { wrap: false } }) could handle it..?  Or debug: false.  Whatever...");
	},
	close: function(ctx){
		if (this.restore)
			this.log.restore();
		
		this.restore = false;

		if (this.lastLogger)
			this.log = this.lastLogger;

		this.lastLogger = false;
	},
	label: function(ctx){
		return this.log.labelize(ctx) + "." + this.name + "()";
	},
	assignTo: function(parent, name){
		if (this.enabled){
			if (this.hasOwnProperty("name") && this.name !== name){
				console.warn("Method name mismatch.  You probably want to clone instead of renaming...");
			} else {
				this.name = name;
				this.makeWrapper();
			}
			parent[name] = this.wrapper;
		} else {
			parent[name] = this.fn;
		}
	}
});